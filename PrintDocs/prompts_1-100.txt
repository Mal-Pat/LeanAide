/--`cantorFunction c (f : â„• â†’ Bool)` is `Î£ n, f n * c ^ n`, where `true` is interpreted as `1` and `false` is interpreted as `0`. It is implemented using `cantorFunctionAux`. -/def Cardinal.cantorFunction : â„ â†’ (â„• â†’ Bool) â†’ â„ := fun c f => âˆ‘' (n : â„•), Cardinal.cantorFunctionAux c f n
/--If `x` is an `I`-multiple of the submodule spanned by `f '' s`, then we can write `x` as an `I`-linear combination of the elements of `f '' s`. -/theorem Submodule.mem_ideal_smul_span_iff_exists_sum.{u, v, u_4} : âˆ€ {R : Type u} {M : Type v} [inst : CommSemiring R]   [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (I : Ideal R) {Î¹ : Type u_4} (f : Î¹ â†’ M) (x : M),   x âˆˆ I â€¢ Submodule.span R (Set.range f) â†” âˆƒ a, âˆƒ (_ : âˆ€ (i : Î¹), a i âˆˆ I), (a.sum fun i c => c â€¢ f i) = x := â‹¯
/--Given two commutative squares ``` a --Ï†--> b --Ïˆ--> c |        |        | v        v        v R --f--> S --g--> T ``` such that `Ï† â‰« Ïˆ` and `Ï†` are strongly cocartesian, then so is `Ïˆ`. -/protected theorem CategoryTheory.Functor.IsStronglyCocartesian.of_comp.{vâ‚, vâ‚‚, uâ‚, uâ‚‚} : âˆ€ {ğ’® : Type uâ‚} {ğ’³ : Type uâ‚‚}   [inst : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®] [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} ğ’³]   (p : CategoryTheory.Functor ğ’³ ğ’®) {R S T : ğ’®} {a b c : ğ’³} {f : R âŸ¶ S} {g : S âŸ¶ T} {Ï† : a âŸ¶ b} {Ïˆ : b âŸ¶ c}   [p.IsStronglyCocartesian f Ï†]   [p.IsStronglyCocartesian (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp Ï† Ïˆ)]   [p.IsHomLift g Ïˆ], p.IsStronglyCocartesian g Ïˆ := â‹¯
/--A constructive version of `Classical.skolem` for `Encodable` types. -/theorem Encodable.skolem.{u_1, u_2} : âˆ€ {Î± : Type u_1} {Î² : Î± â†’ Type u_2} {P : (x : Î±) â†’ Î² x â†’ Prop}   [(a : Î±) â†’ Encodable (Î² a)] [(x : Î±) â†’ (y : Î² x) â†’ Decidable (P x y)],   (âˆ€ (x : Î±), âˆƒ y, P x y) â†” âˆƒ f, âˆ€ (x : Î±), P x (f x) := â‹¯
/--Box product of simple graphs. It relates `(aâ‚, b)` and `(aâ‚‚, b)` if `G` relates `aâ‚` and `aâ‚‚`, and `(a, bâ‚)` and `(a, bâ‚‚)` if `H` relates `bâ‚` and `bâ‚‚`. -/def SimpleGraph.boxProd.{u_1, u_2} : {Î± : Type u_1} â†’   {Î² : Type u_2} â†’     SimpleGraph Î± â†’       SimpleGraph Î² â†’         SimpleGraph           (Î± Ã—             Î²) := fun {Î±} {Î²} G H =>   { Adj := fun x y => G.Adj x.1 y.1 âˆ§ x.2 = y.2 âˆ¨ H.Adj x.2 y.2 âˆ§ x.1 = y.1, symm := â‹¯, loopless := â‹¯ }
/--Turn an element of a type `F` satisfying `CocompactMapClass F Î± Î²` into an actual `CocompactMap`. This is declared as the default coercion from `F` to `CocompactMap Î± Î²`. -/def CocompactMapClass.toCocompactMap.{u_1, u_2, u_3} : {F : Type u_1} â†’   {Î± : Type u_2} â†’     {Î² : Type u_3} â†’       [inst : TopologicalSpace Î±] â†’         [inst_1 : TopologicalSpace Î²] â†’           [inst_2 : FunLike F Î± Î²] â†’             [CocompactMapClass F Î± Î²] â†’               F â†’                 CocompactMap Î±                   Î² := fun {F} {Î±} {Î²} [TopologicalSpace Î±] [TopologicalSpace Î²] [FunLike F Î± Î²]     [CocompactMapClass F Î± Î²] f =>   let __src := â†‘f;   { toContinuousMap := __src, cocompact_tendsto' := â‹¯ }
/--`x + y` has exactly the same moves as `y + x`. -/@[irreducible] protected theorem SetTheory.PGame.add_comm.{u_1} : âˆ€ (x y : SetTheory.PGame),   (x + y).Identical (y + x) := â‹¯
/--The ring homomorphism from `R` to `R[Sâ»Â¹]`, mapping `r : R` to the fraction `r /â‚’ 1`. -/def OreLocalization.numeratorRingHom.{u_1} : {R : Type u_1} â†’   [inst : Semiring R] â†’     {S : Submonoid R} â†’       [inst_1 : OreLocalization.OreSet S] â†’         R â†’+*           OreLocalization S             R := fun {R} [Semiring R] {S} [OreLocalization.OreSet S] =>   let __spread.0 := OreLocalization.numeratorHom;   { toMonoidHom := __spread.0, map_zero' := â‹¯, map_add' := â‹¯ }
/--A Lie ring module may be pulled back along a morphism of Lie algebras.  See note [reducible non-instances]. -/def LieRingModule.compLieHom.{u, v, w, wâ‚} : {R : Type u} â†’   {Lâ‚ : Type v} â†’     {Lâ‚‚ : Type w} â†’       (M : Type wâ‚) â†’         [inst : CommRing R] â†’           [inst_1 : LieRing Lâ‚] â†’             [inst_2 : LieAlgebra R Lâ‚] â†’               [inst_3 : LieRing Lâ‚‚] â†’                 [inst_4 : LieAlgebra R Lâ‚‚] â†’                   [inst_5 : AddCommGroup M] â†’                     [LieRingModule Lâ‚‚ M] â†’                       (Lâ‚ â†’â‚—â…Râ† Lâ‚‚) â†’                         LieRingModule Lâ‚                           M := fun {R} {Lâ‚} {Lâ‚‚} M [CommRing R] [LieRing Lâ‚] [LieAlgebra R Lâ‚] [LieRing Lâ‚‚]     [LieAlgebra R Lâ‚‚] [AddCommGroup M] [LieRingModule Lâ‚‚ M] f =>   { bracket := fun x m => â…f x, mâ†, add_lie := â‹¯, lie_add := â‹¯, leibniz_lie := â‹¯ }
/--The identity morphism of an object in `P.Comma L R Q W`. -/def CategoryTheory.MorphismProperty.Comma.id.{u_1, u_2, u_3, u_4, u_5, u_6} : {A : Type u_1} â†’   [inst : CategoryTheory.Category.{u_4, u_1} A] â†’     {B : Type u_2} â†’       [inst_1 : CategoryTheory.Category.{u_5, u_2} B] â†’         {T : Type u_3} â†’           [inst_2 : CategoryTheory.Category.{u_6, u_3} T] â†’             {L : CategoryTheory.Functor A T} â†’               {R : CategoryTheory.Functor B T} â†’                 {P : CategoryTheory.MorphismProperty T} â†’                   {Q : CategoryTheory.MorphismProperty A} â†’                     {W : CategoryTheory.MorphismProperty B} â†’                       [Q.ContainsIdentities] â†’                         [W.ContainsIdentities] â†’                           (X : CategoryTheory.MorphismProperty.Comma L R P Q W) â†’                             X.Hom                               X := fun {A} [CategoryTheory.Category.{u_4, u_1} A] {B}     [CategoryTheory.Category.{u_5, u_2} B] {T} [CategoryTheory.Category.{u_6, u_3} T] {L} {R} {P} {Q} {W}     [Q.ContainsIdentities] [W.ContainsIdentities] X =>   { left := CategoryTheory.CategoryStruct.id X.left, right := CategoryTheory.CategoryStruct.id X.right, w := â‹¯,     prop_hom_left := â‹¯, prop_hom_right := â‹¯ }
/--An angle in a right-angled triangle expressed using `arccos`. -/theorem InnerProductGeometry.angle_add_eq_arccos_of_inner_eq_zero.{u_1} : âˆ€ {V : Type u_1} [inst : NormedAddCommGroup V]   [inst_1 : InnerProductSpace â„ V] {x y : V},   inner â„ x y = 0 â†’ InnerProductGeometry.angle x (x + y) = Real.arccos (â€–xâ€– / â€–x + yâ€–) := â‹¯
/--In the presence of the strict Segal condition, a path of length `n` can be "composed" by taking the diagonal edge of the resulting `n`-simplex. -/def SSet.StrictSegal.spineToDiagonal.{u} : {X : SSet} â†’   X.StrictSegal â†’     {n : â„•} â†’       X.Path n â†’         X.obj           (Opposite.op             (SimplexCategory.mk               1)) := fun {X} sx {n} f => CategoryTheory.SimplicialObject.diagonal X (sx.spineToSimplex f)
/--`unitsMap` is a group homomorphism that maps units of `ZMod m` to units of `ZMod n` when `n` divides `m`. -/def ZMod.unitsMap : {n m : â„•} â†’ n âˆ£ m â†’ (ZMod m)Ë£ â†’* (ZMod n)Ë£ := fun {n m} hm => Units.map â†‘(ZMod.castHom hm (ZMod n))
/--A variant of `hasDerivAtFilter_finCons` where the derivative variables are free on the RHS instead. -/theorem hasDerivAtFilter_finCons'.{u, u_1} : âˆ€ {ğ•œ : Type u} [inst : NontriviallyNormedField ğ•œ] {x : ğ•œ} {n : â„•}   {F' : Fin n.succ â†’ Type u_1} [inst_1 : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)]   [inst_2 : (i : Fin n.succ) â†’ NormedSpace ğ•œ (F' i)] {Ï† : ğ•œ â†’ F' 0} {Ï†s : ğ•œ â†’ (i : Fin n) â†’ F' i.succ} {Ï†' : F' 0}   {Ï†s' : (i : Fin n) â†’ F' i.succ} {l : Filter ğ•œ},   HasDerivAtFilter (fun x => Fin.cons (Ï† x) (Ï†s x)) (Fin.cons Ï†' Ï†s') x l â†”     HasDerivAtFilter Ï† Ï†' x l âˆ§ HasDerivAtFilter Ï†s Ï†s' x l := â‹¯
/--Test for convergence of the `p`-series: the real-valued series `âˆ‘' n : â„•, (n ^ p)â»Â¹` converges if and only if `1 < p`. -/theorem Real.summable_nat_pow_inv : âˆ€ {p : â„•}, (Summable fun n => (â†‘n ^ p)â»Â¹) â†” 1 < p := â‹¯
/--Composition with a linear isometry on the right preserves the norm of the iterated derivative within a set. -/theorem LinearIsometryEquiv.norm_iteratedFDerivWithin_comp_right.{uE, uF, uG, u_1} : âˆ€ {ğ•œ : Type u_1}   [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ğ•œ E]   {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {G : Type uG} [inst_5 : NormedAddCommGroup G]   [inst_6 : NormedSpace ğ•œ G] {s : Set E} (g : G â‰ƒâ‚—áµ¢[ğ•œ] E) (f : E â†’ F),   UniqueDiffOn ğ•œ s â†’     âˆ€ {x : G},       g x âˆˆ s â†’ âˆ€ (i : â„•), â€–iteratedFDerivWithin ğ•œ i (f âˆ˜ â‡‘g) (â‡‘g â»Â¹' s) xâ€– = â€–iteratedFDerivWithin ğ•œ i f s (g x)â€– := â‹¯
/--The underlying map `B â†’ M` of a derivation `M.Derivation f` when `M : ModuleCat B` and `f : A âŸ¶ B` is a morphism in `CommRingCat`. -/def ModuleCat.Derivation.d.{v, u} : {A B : CommRingCat} â†’   {M : ModuleCat â†‘B} â†’ {f : A âŸ¶ B} â†’ M.Derivation f â†’ â†‘B â†’ â†‘M := fun {A B} {M} {f} D b => â†‘D b
/--Nonnegative rational numbers. -/def Â«termâ„šâ‰¥0Â» : Lean.ParserDescr := Lean.ParserDescr.node `Â«termâ„šâ‰¥0Â» 1024 (Lean.ParserDescr.symbol "â„šâ‰¥0")
/--`J` is connected if: given any function `F : J â†’ Î±` which is constant for any `jâ‚, jâ‚‚` for which there is a morphism `jâ‚ âŸ¶ jâ‚‚`, then `F` is constant. This can be thought of as a local-to-global property.  The converse of `constant_of_preserves_morphisms`. -/theorem CategoryTheory.IsPreconnected.of_constant_of_preserves_morphisms.{vâ‚, uâ‚} : âˆ€ {J : Type uâ‚}   [inst : CategoryTheory.Category.{vâ‚, uâ‚} J],   (âˆ€ {Î± : Type uâ‚} (F : J â†’ Î±), (âˆ€ {jâ‚ jâ‚‚ : J} (x : jâ‚ âŸ¶ jâ‚‚), F jâ‚ = F jâ‚‚) â†’ âˆ€ (j j' : J), F j = F j') â†’     CategoryTheory.IsPreconnected J := â‹¯
/--The set of closed points. -/def closedPoints.{u_1} : (X : Type u_1) â†’   [TopologicalSpace X] â†’ Set X := fun X [TopologicalSpace X] => {x | IsClosed {x}}
/--The coinduced topology on `M` from a family of continuous linear maps into `M`, which is the finest topology that makes it into a topological module and makes every map continuous. -/def TopModuleCat.coinduced.{u, u_1, u_2} : {R : Type u} â†’   [inst : Ring R] â†’     [inst_1 : TopologicalSpace R] â†’       {M : ModuleCat R} â†’         {I : Type u_1} â†’           {X : I â†’ TopModuleCat R} â†’             ((i : I) â†’ (X i).toModuleCat âŸ¶ M) â†’               TopModuleCat R := fun {R} [Ring R] [TopologicalSpace R] {M} {I} {X} f =>   have this := â‹¯;   have this_1 := â‹¯;   TopModuleCat.of R â†‘M
/--In an Râ‚€ space, the closure of a singleton is a compact set. -/theorem isCompact_closure_singleton.{u_1} : âˆ€ {X : Type u_1} [inst : TopologicalSpace X] [R0Space X] {x : X},   IsCompact (closure {x}) := â‹¯
/--An optional doc string. -/@[reducible] def ToAdditive.Config.doc : ToAdditive.Config â†’ Option String := fun self => self.3
/--Composition of morphisms in the indexing diagram for wide (co)equalizers. -/def CategoryTheory.Limits.WalkingParallelFamily.Hom.comp.{w} : {J : Type w} â†’   {X Y Z : CategoryTheory.Limits.WalkingParallelFamily J} â†’     CategoryTheory.Limits.WalkingParallelFamily.Hom J X Y â†’       CategoryTheory.Limits.WalkingParallelFamily.Hom J Y Z â†’         CategoryTheory.Limits.WalkingParallelFamily.Hom J X           Z := fun {J} x x_1 x_2 x_3 x_4 =>   match x, x_1, x_2, x_3, x_4 with   | x, .(x), x_5, CategoryTheory.Limits.WalkingParallelFamily.Hom.id .(x), h => h   | .(CategoryTheory.Limits.WalkingParallelFamily.zero), .(CategoryTheory.Limits.WalkingParallelFamily.one),     .(CategoryTheory.Limits.WalkingParallelFamily.one), CategoryTheory.Limits.WalkingParallelFamily.Hom.line j,     CategoryTheory.Limits.WalkingParallelFamily.Hom.id CategoryTheory.Limits.WalkingParallelFamily.one =>     CategoryTheory.Limits.WalkingParallelFamily.Hom.line j
/--The isomorphism `(K.restriction e).X i â‰… K.X i'` when `e.f i = i'`. -/def HomologicalComplex.restrictionXIso.{u_1, u_2, u_3, u_4} : {Î¹ : Type u_1} â†’   {Î¹' : Type u_2} â†’     {c : ComplexShape Î¹} â†’       {c' : ComplexShape Î¹'} â†’         {C : Type u_3} â†’           [inst : CategoryTheory.Category.{u_4, u_3} C] â†’             [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] â†’               (K : HomologicalComplex C c') â†’                 (e : c.Embedding c') â†’                   [inst_2 : e.IsRelIff] â†’                     {i : Î¹} â†’                       {i' : Î¹'} â†’                         e.f i = i' â†’                           ((K.restriction e).X i â‰…                             K.X                               i') := fun {Î¹} {Î¹'} {c} {c'} {C} [CategoryTheory.Category.{u_4, u_3} C]     [CategoryTheory.Limits.HasZeroMorphisms C] K e [e.IsRelIff] {i} {i'} h =>   CategoryTheory.eqToIso â‹¯
/--`OrderDual` as a functor. -/def FinBddDistLat.dual.{u_1} : CategoryTheory.Functor FinBddDistLat   FinBddDistLat := { obj := fun X => FinBddDistLat.of (â†‘X.toDistLat)áµ’áµˆ,   map := fun {X Y} f => FinBddDistLat.ofHom (BoundedLatticeHom.dual (FinBddDistLat.Hom.hom f)),   map_id := FinBddDistLat.dual._proof_1, map_comp := @FinBddDistLat.dual._proof_2 }
/--**Alias** of `SetRel.comp_univ`.-/theorem SetRel.comp_right_top.{u_1, u_2, u_3} : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} (R : SetRel Î± Î²),   R.comp Set.univ = {(a, _c) | a âˆˆ R.dom} := â‹¯
/--The range of the inclusion map is a normal additive subgroup. -/theorem AddGroupExtension.normal_inl_range.{u_1, u_2, u_3} : âˆ€ {N : Type u_1} {E : Type u_2} {G : Type u_3}   [inst : AddGroup N] [inst_1 : AddGroup E] [inst_2 : AddGroup G] (S : AddGroupExtension N E G), S.inl.range.Normal := â‹¯
/--Any `S`-module M is also an `R`-module via a ring homomorphism `f : R âŸ¶ S` by defining `r â€¢ m := f r â€¢ m` (`Module.compHom`). This is called restriction of scalars. -/def ModuleCat.RestrictScalars.obj'.{v, uâ‚, uâ‚‚} : {R : Type uâ‚} â†’   {S : Type uâ‚‚} â†’     [inst : Ring R] â†’       [inst_1 : Ring S] â†’         (R â†’+* S) â†’ ModuleCat S â†’ ModuleCat R := fun {R} {S} [Ring R] [Ring S] f M =>   have x := Module.compHom (â†‘M) f;   ModuleCat.of R â†‘M
/--The canonical fork on `f g : A âŸ¶ B` given by the equalizer. -/def CommRingCat.Under.equalizerFork.{u} : {R : CommRingCat} â†’   {A B : CategoryTheory.Under R} â†’     (f g : A âŸ¶ B) â†’       CategoryTheory.Limits.Fork f         g := fun {R} {A B} f g =>   CategoryTheory.Limits.Fork.ofÎ¹ (AlgHom.equalizer (CommRingCat.toAlgHom f) (CommRingCat.toAlgHom g)).val.toUnder â‹¯
/--**Alias** of `FreeAbelianGroup.lift_neg`.-/theorem FreeAbelianGroup.lift_neg'.{u, u_1} : âˆ€ {Î± : Type u} {G : Type u_1} [inst : AddCommGroup G] (f : Î± â†’ G),   FreeAbelianGroup.lift (-f) = -FreeAbelianGroup.lift f := â‹¯
/--The identity morphism in the category of covers of a scheme. -/def AlgebraicGeometry.Scheme.Cover.Hom.id.{v, u} : {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme} â†’   [P.ContainsIdentities] â†’     {X : AlgebraicGeometry.Scheme} â†’       (ğ’° : AlgebraicGeometry.Scheme.Cover P X) â†’         ğ’°.Hom           ğ’° := fun {P} [P.ContainsIdentities] {X} ğ’° =>   { idx := fun j => j, app := fun x => CategoryTheory.CategoryStruct.id (ğ’°.obj x), app_prop := â‹¯, w := â‹¯ }
/--Two spheres intersect in at most two points in a two-dimensional subspace containing their centers; this is a version of `eq_of_dist_eq_of_dist_eq_of_mem_of_finrank_eq_two` for bundled spheres. -/theorem EuclideanGeometry.eq_of_mem_sphere_of_mem_sphere_of_mem_of_finrank_eq_two.{u_1, u_2} : âˆ€ {V : Type u_1}   {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P]   [inst_3 : NormedAddTorsor V P] {s : AffineSubspace â„ P} [FiniteDimensional â„ â†¥s.direction],   Module.finrank â„ â†¥s.direction = 2 â†’     âˆ€ {sâ‚ sâ‚‚ : EuclideanGeometry.Sphere P} {pâ‚ pâ‚‚ p : P},       sâ‚.center âˆˆ s â†’         sâ‚‚.center âˆˆ s â†’           pâ‚ âˆˆ s â†’             pâ‚‚ âˆˆ s â†’               p âˆˆ s â†’ sâ‚ â‰  sâ‚‚ â†’ pâ‚ â‰  pâ‚‚ â†’ pâ‚ âˆˆ sâ‚ â†’ pâ‚‚ âˆˆ sâ‚ â†’ p âˆˆ sâ‚ â†’ pâ‚ âˆˆ sâ‚‚ â†’ pâ‚‚ âˆˆ sâ‚‚ â†’ p âˆˆ sâ‚‚ â†’ p = pâ‚ âˆ¨ p = pâ‚‚ := â‹¯
/--An elementary embedding of first-order structures is an embedding that commutes with the realizations of formulas. -/def FirstOrder.Â«term_â†ªâ‚‘[_]_Â» : Lean.TrailingParserDescr := Lean.ParserDescr.trailingNode `FirstOrder.Â«term_â†ªâ‚‘[_]_Â» 25 0   (Lean.ParserDescr.binary `andthen     (Lean.ParserDescr.binary `andthen       (Lean.ParserDescr.binary `andthen (Lean.ParserDescr.symbol " â†ªâ‚‘[") (Lean.ParserDescr.cat `term 0))       (Lean.ParserDescr.symbol "] "))     (Lean.ParserDescr.cat `term 0))
/--The inf of a set of orthogonal subspaces equals the subspace orthogonal to the sup. -/theorem Submodule.sInf_orthogonal.{u_1, u_2} : âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : RCLike ğ•œ]   [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E] (s : Set (Submodule ğ•œ E)),   â¨… K âˆˆ s, Ká—® = (sSup s)á—® := â‹¯
/--The inner set in the inductive construction towards Urysohn's lemma -/@[reducible] protected def Urysohns.CU.C.{u_2} : {X : Type u_2} â†’   [inst : TopologicalSpace X] â†’     {P : Set X â†’ Set X â†’ Prop} â†’ Urysohns.CU P â†’ Set X := fun X [TopologicalSpace X] P self => self.1
/--Finite measures yield elements of the `WeakDual` of bounded continuous nonnegative functions via `MeasureTheory.FiniteMeasure.testAgainstNN`, i.e., integration. -/def MeasureTheory.FiniteMeasure.toWeakDualBCNN.{u_1} : {Î© : Type u_1} â†’   [inst : MeasurableSpace Î©] â†’     [inst_1 : TopologicalSpace Î©] â†’       [OpensMeasurableSpace Î©] â†’         MeasureTheory.FiniteMeasure Î© â†’           WeakDual NNReal             (BoundedContinuousFunction Î©               NNReal) := fun {Î©} [MeasurableSpace Î©] [TopologicalSpace Î©] [OpensMeasurableSpace Î©] Î¼ =>   { toFun := fun f => Î¼.testAgainstNN f, map_add' := â‹¯, map_smul' := â‹¯, cont := â‹¯ }
/--If `s` is a subfield of a normed field `F`, then `s` is equipped with an induced normed field structure. -/def SubfieldClass.toNormedField.{u_5, u_6} : {S : Type u_5} â†’   {F : Type u_6} â†’     [inst : SetLike S F] â†’       [inst_1 : NormedField F] â†’         [SubfieldClass S F] â†’           (s : S) â†’             NormedField               â†¥s := fun {S} {F} [SetLike S F] [NormedField F] [SubfieldClass S F] s =>   NormedField.induced (â†¥s) F (SubringClass.subtype s) â‹¯
/--Auxiliary definition for `extFunctor`. -/def CategoryTheory.Abelian.extFunctorObj.{w, v, u} : {C : Type u} â†’   [inst : CategoryTheory.Category.{v, u} C] â†’     [inst_1 : CategoryTheory.Abelian C] â†’       [CategoryTheory.HasExt C] â†’         C â†’           â„• â†’             CategoryTheory.Functor C               AddCommGrp := fun {C} [CategoryTheory.Category.{v, u} C] [CategoryTheory.Abelian C]     [CategoryTheory.HasExt C] X n =>   { obj := fun Y => AddCommGrp.of (CategoryTheory.Abelian.Ext X Y n),     map := fun {X_1 Y} f => AddCommGrp.ofHom ((CategoryTheory.Abelian.Ext.mkâ‚€ f).postcomp X â‹¯), map_id := â‹¯,     map_comp := â‹¯ }
/--A GrÃ¶nwall-like inequality: if `f : â„ â†’ â„` is continuous on `[a, b]` and satisfies the inequalities `f a â‰¤ Î´` and `âˆ€ x âˆˆ [a, b), liminf_{zâ†’x+0} (f z - f x)/(z - x) â‰¤ K * (f x) + Îµ`, then `f x` is bounded by `gronwallBound Î´ K Îµ (x - a)` on `[a, b]`.  See also `norm_le_gronwallBound_of_norm_deriv_right_le` for a version bounding `â€–f xâ€–`, `f : â„ â†’ E`. -/theorem le_gronwallBound_of_liminf_deriv_right_le : âˆ€ {f f' : â„ â†’ â„} {Î´ K Îµ a b : â„},   ContinuousOn f (Set.Icc a b) â†’     (âˆ€ x âˆˆ Set.Ico a b, âˆ€ (r : â„), f' x < r â†’ âˆƒá¶  (z : â„) in nhdsWithin x (Set.Ioi x), (z - x)â»Â¹ * (f z - f x) < r) â†’       f a â‰¤ Î´ â†’ (âˆ€ x âˆˆ Set.Ico a b, f' x â‰¤ K * f x + Îµ) â†’ âˆ€ x âˆˆ Set.Icc a b, f x â‰¤ gronwallBound Î´ K Îµ (x - a) := â‹¯
/--This instance is useful when talking about Bernoulli sequences of random variables or binomial random graphs. -/def Set.instMeasurableSpace.{u_1} : {Î± : Type u_1} â†’ MeasurableSpace (Set Î±) := fun {Î±} => id inferInstance
/--Pads `l : List Î±` on the left with repeated occurrences of `a : Î±` until it is of length `n`. If `l` already has at least `n` elements, it is returned unmodified.  This is a tail-recursive version of `List.leftpad`, used at runtime.  Examples:  * `[1, 2, 3].leftPadTR 5 0 = [0, 0, 1, 2, 3]`  * `["red", "green", "blue"].leftPadTR 4 "blank" = ["blank", "red", "green", "blue"]`  * `["red", "green", "blue"].leftPadTR 3 "blank" = ["red", "green", "blue"]`  * `["red", "green", "blue"].leftPadTR 1 "blank" = ["red", "green", "blue"]` -/def List.leftpadTR.{u} : {Î± : Type u} â†’   â„• â†’ Î± â†’ List Î± â†’ List Î± := fun {Î±} n a l => List.replicateTR.loop a (n - l.length) l
/--Restricts a finpartition to avoid a given element. -/def Finpartition.avoid.{u_1} : {Î± : Type u_1} â†’   [inst : GeneralizedBooleanAlgebra Î±] â†’     [DecidableEq Î±] â†’       {a : Î±} â†’         Finpartition a â†’           (b : Î±) â†’             Finpartition               (a \                 b) := fun {Î±} [GeneralizedBooleanAlgebra Î±] [DecidableEq Î±] {a} P b =>   Finpartition.ofErase (Finset.image (fun x => x \ b) P.parts) â‹¯ â‹¯
/--The equality of two terms as a bounded formula. -/def FirstOrder.Â«term_='_Â» : Lean.TrailingParserDescr := Lean.ParserDescr.trailingNode `FirstOrder.Â«term_='_Â» 88 88   (Lean.ParserDescr.binary `andthen (Lean.ParserDescr.symbol " =' ") (Lean.ParserDescr.cat `term 89))
/--We have `[0, W] = 0` for all vector fields `W`: this depends on the junk value 0 if `W` is not differentiable. -/theorem VectorField.mlieBracket_zero_left.{u_1, u_2, u_3, u_4} : âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ]   {H : Type u_2} [inst_1 : TopologicalSpace H] {E : Type u_3} [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ğ•œ E]   {I : ModelWithCorners ğ•œ E H} {M : Type u_4} [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M]   {W : (x : M) â†’ TangentSpace I x}, VectorField.mlieBracket I 0 W = 0 := â‹¯
/--Shows that the partial denominators `báµ¢` correspond to an integer. -/theorem GenContFract.exists_int_eq_of_partDen.{u_1} : âˆ€ {K : Type u_1} {v : K} {n : â„•} [inst : Field K]   [inst_1 : LinearOrder K] [IsStrictOrderedRing K] [inst_3 : FloorRing K] {b : K},   (GenContFract.of v).partDens.get? n = some b â†’ âˆƒ z, b = â†‘z := â‹¯
/--Number of major (hard) page faults (disk I/O required) -/@[reducible] def Std.Internal.IO.Process.ResourceUsageStats.majorPageFaults : Std.Internal.IO.Process.ResourceUsageStats â†’   UInt64 := fun self => self.8
/--**Alias** of the forward direction of `convex_iff_pointwise_add_subset`.  ---  Alternative definition of set convexity, in terms of pointwise set operations. -/theorem Convex.set_combo_subset.{u_1, u_2} : âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : Semiring ğ•œ]   [inst_1 : PartialOrder ğ•œ] [inst_2 : AddCommMonoid E] [inst_3 : SMul ğ•œ E] {s : Set E},   Convex ğ•œ s â†’ âˆ€ â¦ƒa b : ğ•œâ¦„, 0 â‰¤ a â†’ 0 â‰¤ b â†’ a + b = 1 â†’ a â€¢ s + b â€¢ s âŠ† s := â‹¯
/--**Alias** of the forward direction of `Multiset.disjoint_right`.-/theorem Disjoint.notMem_of_mem_right_multiset.{u_1} : âˆ€ {Î± : Type u_1} {s t : Multiset Î±},   Disjoint s t â†’ âˆ€ {a : Î±}, a âˆˆ t â†’ a âˆ‰ s := â‹¯
/--The inverse function is approximated linearly on `f '' s` by `f'.symm`. -/theorem ApproximatesLinearOn.to_inv.{u_1, u_2, u_3} : âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2}   [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F]   [inst_4 : NormedSpace ğ•œ F] {f : E â†’ F} {f' : E â‰ƒL[ğ•œ] F} {s : Set E} {c : NNReal}   (hf : ApproximatesLinearOn f (â†‘f') s c) (hc : Subsingleton E âˆ¨ c < â€–â†‘f'.symmâ€–â‚Šâ»Â¹),   ApproximatesLinearOn (â†‘(hf.toPartialEquiv hc).symm) (â†‘f'.symm) (f '' s) (â€–â†‘f'.symmâ€–â‚Š * (â€–â†‘f'.symmâ€–â‚Šâ»Â¹ - c)â»Â¹ * c) := â‹¯
/--If `it` is an iterator, then `it.map f` is another iterator that applies a function `f` to all values emitted by `it` and emits the result.  In situations where `f` is monadic, use `mapM` instead.  **Marble diagram:**  ```text it         ---a --b --c --d -e ----âŠ¥ it.map     ---a'--b'--c'--d'-e'----âŠ¥ ```  (given that `f a = a'`, `f b = b'` etc.)  **Termination properties:**  * `Finite` instance: only if `it` is finite * `Productive` instance: only if `it` is productive  **Performance:**  For each value emitted by the base iterator `it`, this combinator calls `f`. -/def Std.Iterators.IterM.map.{w, w'} : {Î± Î² Î³ : Type w} â†’   {m : Type w â†’ Type w'} â†’     [Std.Iterators.Iterator Î± m Î²] â†’       [inst : Monad m] â†’         (f : Î² â†’ Î³) â†’           Std.IterM m Î² â†’             Std.IterM m               Î³ := fun {Î± Î² Î³} {m} [Std.Iterators.Iterator Î± m Î²] [Monad m] f it =>   Std.Iterators.IterM.mapWithPostcondition (fun b => pure (f b)) it
/--Checks whether a key is present in a map, returning the associated value, and inserts a value for the key if it was not found.  If the returned value is `some v`, then the returned map is unaltered. If it is `none`, then the returned map has a new value inserted.  Equivalent to (but potentially faster than) calling `get?` followed by `insertIfNew`.  Uses the `LawfulEqCmp` instance to cast the retrieved value to the correct type. -/def Std.DTreeMap.Const.getThenInsertIfNew?.{u, v} : {Î± : Type u} â†’   {cmp : Î± â†’ Î± â†’ Ordering} â†’     {Î² : Type v} â†’       Std.DTreeMap Î± (fun x => Î²) cmp â†’         Î± â†’           Î² â†’             Option Î² Ã—               Std.DTreeMap Î± (fun x => Î²)                 cmp := fun {Î±} {cmp} {Î²} t a b =>   let p := Std.DTreeMap.Internal.Impl.Const.getThenInsertIfNew? t.inner a b â‹¯;   (p.1, { inner := p.2, wf := â‹¯ })
/--**Alias** of `Irrational.sub_ratCast`.-/theorem Irrational.sub_rat : âˆ€ (q : â„š) {x : â„}, Irrational x â†’ Irrational (x - â†‘q) := â‹¯
/--`val_v(I) = 0` for all but finitely many maximal ideals of `R`. -/theorem FractionalIdeal.finite_factors.{u_1, u_2} : âˆ€ {R : Type u_1} [inst : CommRing R] {K : Type u_2}   [inst_1 : Field K] [inst_2 : Algebra R K] [inst_3 : IsFractionRing R K] [inst_4 : IsDedekindDomain R]   (I : FractionalIdeal (nonZeroDivisors R) K),   âˆ€á¶  (v : IsDedekindDomain.HeightOneSpectrum R) in Filter.cofinite, FractionalIdeal.count K v I = 0 := â‹¯
/--The map sending a congruence relation to its underlying equivalence relation is injective. -/theorem Con.toSetoid_inj.{u_1} : âˆ€ {M : Type u_1} [inst : Mul M] {c d : Con M}, c.toSetoid = d.toSetoid â†’ c = d := â‹¯
/--Any `K`-algebra module that is 1-dimensional over `K` is simple. -/theorem is_simple_module_of_finrank_eq_one.{u, v, u_1} : âˆ€ {K : Type u} {V : Type v} [inst : DivisionRing K]   [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Type u_1} [inst_3 : Semiring A] [inst_4 : Module A V]   [inst_5 : SMul K A] [IsScalarTower K A V], Module.finrank K V = 1 â†’ IsSimpleOrder (Submodule A V) := â‹¯
/--A copy of `invOf_mul_cancel_right` for rectangular matrices. -/protected theorem Matrix.invOf_mul_cancel_right.{u_1, u_2, u_3} : âˆ€ {m : Type u_1} {n : Type u_2} {Î± : Type u_3}   [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : Semiring Î±] (A : Matrix m n Î±) (B : Matrix n n Î±)   [inst_3 : Invertible B], A * â…ŸB * B = A := â‹¯
/--If the unit and counit for the adjunction corresponding to a right adjoint functor are (pointwise) isomorphisms, then the functor is an equivalence of categories. -/theorem CategoryTheory.Functor.isEquivalence_of_isRightAdjoint.{vâ‚, vâ‚‚, uâ‚, uâ‚‚} : âˆ€ {C : Type uâ‚}   [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {D : Type uâ‚‚} [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D]   (G : CategoryTheory.Functor C D) [inst_2 : G.IsRightAdjoint]   [âˆ€ (X : D), CategoryTheory.IsIso ((CategoryTheory.Adjunction.ofIsRightAdjoint G).unit.app X)]   [âˆ€ (Y : C), CategoryTheory.IsIso ((CategoryTheory.Adjunction.ofIsRightAdjoint G).counit.app Y)], G.IsEquivalence := â‹¯
/--A [pairing heap](https://en.wikipedia.org/wiki/Pairing_heap) is a data structure which supports the following primary operations:  * `insert : Î± â†’ PairingHeap Î± â†’ PairingHeap Î±`: add an element to the heap * `deleteMin : PairingHeap Î± â†’ Option (Î± Ã— PairingHeap Î±)`:   remove the minimum element from the heap * `merge : PairingHeap Î± â†’ PairingHeap Î± â†’ PairingHeap Î±`: combine two heaps  The first two operations are known as a "priority queue", so this could be called a "mergeable priority queue". The standard choice for a priority queue is a binary heap, which supports `insert` and `deleteMin` in `O(log n)`, but `merge` is `O(n)`. With a `PairingHeap`, `insert` and `merge` are `O(1)`, `deleteMin` is amortized `O(log n)`.  Note that `deleteMin` may be `O(n)` in a single operation. So if you need an efficient persistent priority queue, you should use other data structures with better worst-case time. -/def Batteries.PairingHeap.{u} : (Î± : Type u) â†’   (Î± â†’ Î± â†’ Bool) â†’ Type (max 0 u) := fun Î± le => { h // Batteries.PairingHeapImp.Heap.WF le h }
/--**Harris-Kleitman inequality**: Any two upper sets of finsets correlate. -/theorem IsUpperSet.le_card_inter_finset.{u_1} : âˆ€ {Î± : Type u_1} [inst : DecidableEq Î±] {ğ’œ â„¬ : Finset (Finset Î±)}   [inst_1 : Fintype Î±], IsUpperSet â†‘ğ’œ â†’ IsUpperSet â†‘â„¬ â†’ ğ’œ.card * â„¬.card â‰¤ 2 ^ Fintype.card Î± * (ğ’œ âˆ© â„¬).card := â‹¯
/--Any type satisfying `AddMonoidHomClass` can be cast into `AddMonoidHom` via `AddMonoidHomClass.toAddMonoidHom`. -/def instCoeTCAddMonoidHomOfAddMonoidHomClass.{u_4, u_5, u_9} : {M : Type u_4} â†’   {N : Type u_5} â†’     {F : Type u_9} â†’       [inst : AddZeroClass M] â†’         [inst_1 : AddZeroClass N] â†’           [inst_2 : FunLike F M N] â†’             [AddMonoidHomClass F M N] â†’               CoeTC F                 (M â†’+                   N) := fun {M} {N} {F} [AddZeroClass M] [AddZeroClass N] [FunLike F M N] [AddMonoidHomClass F M N] =>   { coe := AddMonoidHomClass.toAddMonoidHom }
/--Given a topological ring `Î±` equipped with a uniform structure that makes subtraction uniformly continuous, get an equivalence between the separated quotient of `Î±` and the quotient ring corresponding to the closure of zero. -/def UniformSpace.sepQuotRingEquivRingQuot.{u_2} : (Î± : Type u_2) â†’   [inst : CommRing Î±] â†’     [inst_1 : TopologicalSpace Î±] â†’       [inst_2 : IsTopologicalRing Î±] â†’         SeparationQuotient Î± â‰ƒ+*           Î± â§¸             âŠ¥.closure := fun Î± [CommRing Î±] [TopologicalSpace Î±] [IsTopologicalRing Î±] =>   (UniformSpace.sepQuotHomeomorphRingQuot Î±).ringEquiv
/--The underlying homomorphism of `C`. -/@[reducible] def CategoryTheory.PreGaloisCategory.PointedGaloisObject.Hom.val.{uâ‚, uâ‚‚, w} : {C : Type uâ‚} â†’   [inst : CategoryTheory.Category.{uâ‚‚, uâ‚} C] â†’     [inst_1 : CategoryTheory.GaloisCategory C] â†’       {F : CategoryTheory.Functor C FintypeCat} â†’         {A B : CategoryTheory.PreGaloisCategory.PointedGaloisObject F} â†’           A.Hom B â†’             (A.obj âŸ¶               B.obj) := fun C [CategoryTheory.Category.{uâ‚‚, uâ‚} C] [CategoryTheory.GaloisCategory C] F A B self =>   self.1
/--The inverse `AffineIsometryEquiv`. -/def AffineIsometryEquiv.symm.{u_1, u_2, u_5, u_10, u_11} : {ğ•œ : Type u_1} â†’   {V : Type u_2} â†’     {Vâ‚‚ : Type u_5} â†’       {P : Type u_10} â†’         {Pâ‚‚ : Type u_11} â†’           [inst : NormedField ğ•œ] â†’             [inst_1 : SeminormedAddCommGroup V] â†’               [inst_2 : NormedSpace ğ•œ V] â†’                 [inst_3 : PseudoMetricSpace P] â†’                   [inst_4 : NormedAddTorsor V P] â†’                     [inst_5 : SeminormedAddCommGroup Vâ‚‚] â†’                       [inst_6 : NormedSpace ğ•œ Vâ‚‚] â†’                         [inst_7 : PseudoMetricSpace Pâ‚‚] â†’                           [inst_8 : NormedAddTorsor Vâ‚‚ Pâ‚‚] â†’                             (P â‰ƒáµƒâ±[ğ•œ] Pâ‚‚) â†’                               Pâ‚‚ â‰ƒáµƒâ±[ğ•œ]                                 P := fun {ğ•œ} {V} {Vâ‚‚} {P} {Pâ‚‚} [NormedField ğ•œ] [SeminormedAddCommGroup V]     [NormedSpace ğ•œ V] [PseudoMetricSpace P] [NormedAddTorsor V P] [SeminormedAddCommGroup Vâ‚‚] [NormedSpace ğ•œ Vâ‚‚]     [PseudoMetricSpace Pâ‚‚] [NormedAddTorsor Vâ‚‚ Pâ‚‚] e =>   let __src := e.symm;   { toAffineEquiv := __src, norm_map := â‹¯ }
/--The `Î´`-thickened indicator of a set `E` is the function that equals `1` on `E` and `0` outside a `Î´`-thickening of `E` and interpolates (continuously) between these values using `infEdist _ E`.  `thickenedIndicatorAux` is the unbundled `â„â‰¥0âˆ`-valued function. See `thickenedIndicator` for the (bundled) bounded continuous function with `â„â‰¥0`-values. -/def thickenedIndicatorAux.{u_1} : {Î± : Type u_1} â†’   [PseudoEMetricSpace Î±] â†’     â„ â†’ Set Î± â†’ Î± â†’ ENNReal := fun {Î±} [PseudoEMetricSpace Î±] Î´ E x => 1 - EMetric.infEdist x E / ENNReal.ofReal Î´
/--The one-element type acts trivially on every element. -/@[defeq] theorem PUnit.smul_eq'.{u_1, u_3} : âˆ€ {R : Type u_1} (r : PUnit.{u_3 + 1}) (a : R), r â€¢ a = a := â‹¯
/--If `Irreducible (cyclotomic (2 ^ k) K)` (in particular for `K = â„š`) and `k` is at least `2`, then the norm of `zeta (2 ^ k) K L - 1` is `2`. -/theorem IsCyclotomicExtension.norm_zeta_pow_sub_one_two.{u, v} : âˆ€ {K : Type u} (L : Type v) [inst : Field K]   [inst_1 : Field L] [inst_2 : Algebra K L] {k : â„•},   2 â‰¤ k â†’     âˆ€ [inst_3 : IsCyclotomicExtension {2 ^ k} K L],       Irreducible (Polynomial.cyclotomic (2 ^ k) K) â†’         (Algebra.norm K) (IsCyclotomicExtension.zeta (2 ^ k) K L - 1) = 2 := â‹¯
/--**Alias** of `eq_or_lt_of_le`.-/theorem LE.le.eq_or_lt.{u_2} : âˆ€ {Î± : Type u_2} [inst : PartialOrder Î±] {a b : Î±}, a â‰¤ b â†’ a = b âˆ¨ a < b := â‹¯
/--The composition of two based functors. -/def CategoryTheory.BasedFunctor.comp.{vâ‚„, uâ‚„, vâ‚ƒ, uâ‚ƒ, vâ‚‚, uâ‚‚, vâ‚, uâ‚} : {ğ’® : Type uâ‚} â†’   [inst : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®] â†’     {ğ’³ : CategoryTheory.BasedCategory ğ’®} â†’       {ğ’´ : CategoryTheory.BasedCategory ğ’®} â†’         {ğ’µ : CategoryTheory.BasedCategory ğ’®} â†’           CategoryTheory.BasedFunctor ğ’³ ğ’´ â†’             CategoryTheory.BasedFunctor ğ’´ ğ’µ â†’               CategoryTheory.BasedFunctor ğ’³                 ğ’µ := fun {ğ’®} [CategoryTheory.Category.{vâ‚, uâ‚} ğ’®] {ğ’³} {ğ’´} {ğ’µ} F G =>   let __Functor := F.comp G.toFunctor;   { toFunctor := __Functor, w := â‹¯ }
/--The kernel of `g.unop` is the opposite of `cokernel g`. -/def CategoryTheory.kernelUnopOp.{u_1, u_2} : {C : Type u_1} â†’   [inst : CategoryTheory.Category.{u_2, u_1} C] â†’     [inst_1 : CategoryTheory.Abelian C] â†’       {A B : Cáµ’áµ–} â†’         (g : A âŸ¶ B) â†’           Opposite.op (CategoryTheory.Limits.kernel g.unop) â‰…             CategoryTheory.Limits.cokernel               g := fun {C} [CategoryTheory.Category.{u_2, u_1} C] [CategoryTheory.Abelian C] {A B} g =>   (CategoryTheory.cokernelOpUnop g.unop).op
/--Multiplying by the trivial monoid doesn't change the structure.  This is the `AddEquiv` version of `Equiv.prodUnique`. -/def AddEquiv.prodUnique.{u_3, u_4} : {M : Type u_3} â†’   {N : Type u_4} â†’     [inst : AddZeroClass M] â†’       [inst_1 : AddZeroClass N] â†’         [Unique N] â†’           M Ã— N â‰ƒ+ M := fun {M} {N} [AddZeroClass M] [AddZeroClass N] [Unique N] =>   let __src := Equiv.prodUnique M N;   { toEquiv := __src, map_add' := â‹¯ }
/--Squashing at position `n + 1` and taking the tail is the same as squashing the tail of the sequence at position `n`. -/theorem GenContFract.squashSeq_succ_n_tail_eq_squashSeq_tail_n.{u_1} : âˆ€ {K : Type u_1} {n : â„•}   {s : Stream'.Seq (GenContFract.Pair K)} [inst : DivisionRing K],   (GenContFract.squashSeq s (n + 1)).tail = GenContFract.squashSeq s.tail n := â‹¯
/--The `ComplexShape` allowing differentials from `X (j+a)` to `X j`. (For example when `a = 1`, a homology theory indexed by `â„•` or `â„¤`) -/def ComplexShape.down'.{u_2} : {Î± : Type u_2} â†’   [inst : Add Î±] â†’     [IsRightCancelAdd Î±] â†’       Î± â†’         ComplexShape           Î± := fun {Î±} [Add Î±] [IsRightCancelAdd Î±] a => { Rel := fun i j => j + a = i, next_eq := â‹¯, prev_eq := â‹¯ }
/--A `DistribMulActionHom` between two modules is a linear map. -/theorem DistribMulActionHom.instLinearMapClassId.{u_1, u_8, u_11} : âˆ€ {R : Type u_1} {M : Type u_8} {Mâ‚ƒ : Type u_11}   [inst : AddCommMonoid M] [inst_1 : AddCommMonoid Mâ‚ƒ] [inst_2 : Semiring R] [inst_3 : Module R M]   [inst_4 : Module R Mâ‚ƒ], LinearMapClass (M â†’+[R] Mâ‚ƒ) R M Mâ‚ƒ := â‹¯
/--**Alias** of `ProperCone.pointed_toConvexCone`.-/protected theorem ProperCone.pointed.{u_1, u_2} : âˆ€ {R : Type u_1} {E : Type u_2} [inst : Semiring R]   [inst_1 : PartialOrder R] [inst_2 : IsOrderedRing R] [inst_3 : AddCommMonoid E] [inst_4 : TopologicalSpace E]   [inst_5 : Module R E] (C : ProperCone R E), (â†‘â†‘C).Pointed := â‹¯
/--A version of `cfcâ‚™_apply` in terms of `ContinuousMapZero.mkD` -/theorem cfcâ‚™_apply_mkD.{u_1, u_2} : âˆ€ {R : Type u_1} {A : Type u_2} {p : A â†’ Prop} [inst : CommSemiring R]   [inst_1 : Nontrivial R] [inst_2 : StarRing R] [inst_3 : MetricSpace R] [inst_4 : IsTopologicalSemiring R]   [inst_5 : ContinuousStar R] [inst_6 : NonUnitalRing A] [inst_7 : StarRing A] [inst_8 : TopologicalSpace A]   [inst_9 : Module R A] [inst_10 : IsScalarTower R A A] [inst_11 : SMulCommClass R A A]   [instCFCâ‚™ : NonUnitalContinuousFunctionalCalculus R A p] (f : R â†’ R) (a : A) (ha : autoParam (p a) _autoâœ),   cfcâ‚™ f a = (cfcâ‚™Hom ha) (ContinuousMapZero.mkD ((quasispectrum R a).restrict f) 0) := â‹¯
/--Reinterpret a compact open as a clopen. -/def TopologicalSpace.CompactOpens.toClopens.{u_1} : {Î± : Type u_1} â†’   [inst : TopologicalSpace Î±] â†’     [T2Space Î±] â†’       TopologicalSpace.CompactOpens Î± â†’         TopologicalSpace.Clopens Î± := fun {Î±} [TopologicalSpace Î±] [T2Space Î±] s => { carrier := â†‘s, isClopen' := â‹¯ }
/--The alternating face map complex, on objects -/def AlgebraicTopology.AlternatingFaceMapComplex.obj.{u_1, u_2} : {C : Type u_1} â†’   [inst : CategoryTheory.Category.{u_2, u_1} C] â†’     [inst_1 : CategoryTheory.Preadditive C] â†’       CategoryTheory.SimplicialObject C â†’         ChainComplex C           â„• := fun {C} [CategoryTheory.Category.{u_2, u_1} C] [CategoryTheory.Preadditive C] X =>   ChainComplex.of (fun n => X.obj (Opposite.op (SimplexCategory.mk n)))     (AlgebraicTopology.AlternatingFaceMapComplex.objD X) â‹¯
/--If `f` is any function and `g` is analytic without zero at `zâ‚€`, then `f` is meromorphic in normal form at `zâ‚€` iff `g * f` is meromorphic in normal form at `zâ‚€`. -/theorem meromorphicNFAt_mul_iff_right.{u_1} : âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {g : ğ•œ â†’ ğ•œ} {x : ğ•œ}   {f : ğ•œ â†’ ğ•œ}, AnalyticAt ğ•œ g x â†’ g x â‰  0 â†’ (MeromorphicNFAt (g * f) x â†” MeromorphicNFAt f x) := â‹¯
/--Catches errors thrown in `body`, passing them to `handler`. Errors in `handler` are not caught. -/def MonadExceptOf.tryCatch.{u, v, w} : {Îµ : semiOutParam (Type u)} â†’   {m : Type v â†’ Type w} â†’     [self : MonadExceptOf Îµ m] â†’ {Î± : Type v} â†’ m Î± â†’ (Îµ â†’ m Î±) â†’ m Î± := fun Îµ m [self : MonadExceptOf Îµ m] => self.2
/--A function is continuous on a set if and only if its composition with a partial homeomorphism on the right is continuous on the corresponding set. -/theorem PartialHomeomorph.continuousOn_iff_continuousOn_comp_right.{u_1, u_3, u_5} : âˆ€ {X : Type u_1} {Y : Type u_3}   {Z : Type u_5} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : TopologicalSpace Z]   (e : PartialHomeomorph X Y) {f : Y â†’ Z} {s : Set Y},   s âŠ† e.target â†’ (ContinuousOn f s â†” ContinuousOn (f âˆ˜ â†‘e) (e.source âˆ© â†‘e â»Â¹' s)) := â‹¯
/--Adds a `Nanosecond.Offset` to a `PlainDateTime`, adjusting the seconds, minutes, hours, and date if the nanoseconds overflow. -/def Std.Time.PlainDateTime.addNanoseconds : Std.Time.PlainDateTime â†’   Std.Time.Nanosecond.Offset â†’     Std.Time.PlainDateTime := fun dt nanos =>   Std.Time.PlainDateTime.ofTimestampAssumingUTC (dt.toTimestampAssumingUTC + nanos)
/--**Alias** of `WithBot.unbotD_eq_unbotD_iff`.-/theorem WithBot.unbot'_eq_unbot'_iff.{u_1} : âˆ€ {Î± : Type u_1} {d : Î±} {x y : WithBot Î±},   WithBot.unbotD d x = WithBot.unbotD d y â†” x = y âˆ¨ x = â†‘d âˆ§ y = âŠ¥ âˆ¨ x = âŠ¥ âˆ§ y = â†‘d := â‹¯
/--Checks if there are declarations in the current file in the namespace `{str}.Simps` that are not used. -/def Simps.checkForUnusedCustomProjs : Lean.Syntax â†’   Lean.Name â†’     Array Simps.ParsedProjectionData â†’       Lean.CoreM         Unit := fun stx str projs =>   have nrCustomProjections := List.countP (fun x => x.isCustom) projs.toList;   do   let env â† Lean.getEnv   have customDeclarations : Array Lean.Name :=     Lean.PersistentHashMap.foldl env.constants.mapâ‚‚       (fun xs nm x =>         if ((str ++ `Simps).isPrefixOf nm && !nm.isInternalDetail && !Lean.isReservedName env nm) = true then xs.push nm         else xs)       #[]   if nrCustomProjections < customDeclarations.size then       Lean.Linter.logLintIf Lean.Parser.linter.simpsUnusedCustomDeclarations stx         (Lean.toMessageData "Not all of the custom declarations " ++ Lean.toMessageData customDeclarations ++           Lean.toMessageData " are used. Double check the spelling, and use `?` to get more information.")     else pure PUnit.unit
/--The fiber of a fiber bundle core, as a convenience function for dot notation and typeclass inference -/def FiberBundleCore.Fiber.{u_1, u_2, u_3} : {Î¹ : Type u_1} â†’   {B : Type u_2} â†’     {F : Type u_3} â†’       [inst : TopologicalSpace B] â†’         [inst_1 : TopologicalSpace F] â†’           FiberBundleCore Î¹ B F â†’ B â†’ Type u_3 := fun {Î¹} {B} {F} [TopologicalSpace B] [TopologicalSpace F] x _x => F
/--Permuting vectors on both sides of a dot product is a no-op. -/theorem comp_equiv_dotProduct_comp_equiv.{v, u_2, u_3} : âˆ€ {m : Type u_2} {n : Type u_3} {Î± : Type v} [inst : Fintype m]   [inst_1 : Fintype n] [inst_2 : NonUnitalNonAssocSemiring Î±] (x y : n â†’ Î±) (e : m â‰ƒ n), x âˆ˜ â‡‘e â¬áµ¥ y âˆ˜ â‡‘e = x â¬áµ¥ y := â‹¯
/--The `p`-adic norm respects the triangle inequality: the norm of `p + q` is at most the norm of `p` plus the norm of `q`. -/theorem padicNorm.triangle_ineq : âˆ€ {p : â„•} [hp : Fact (Nat.Prime p)] (q r : â„š),   padicNorm p (q + r) â‰¤ padicNorm p q + padicNorm p r := â‹¯
/--The absolutely continuous part of a finite invariant measure of a self-map with respect to a Ïƒ-finite invariant measure is an invariant measure. -/protected theorem MeasureTheory.MeasurePreserving.withDensity_rnDeriv.{u_1} : âˆ€ {X : Type u_1} {m : MeasurableSpace X}   {Î¼ Î½ : MeasureTheory.Measure X} [MeasureTheory.IsFiniteMeasure Î¼] [MeasureTheory.SigmaFinite Î½] {f : X â†’ X},   MeasureTheory.MeasurePreserving f Î¼ Î¼ â†’     MeasureTheory.MeasurePreserving f Î½ Î½ â†’       MeasureTheory.MeasurePreserving f (Î½.withDensity (Î¼.rnDeriv Î½)) (Î½.withDensity (Î¼.rnDeriv Î½)) := â‹¯
/--An additive semigroup homomorphism `f : AddHom M N` such that `f x` additively commutes with `f y` for all `x, y` defines an additive semigroup homomorphism to `Sáµƒáµ’áµ–`. -/def AddHom.toOpposite.{u_2, u_3} : {M : Type u_2} â†’   {N : Type u_3} â†’     [inst : Add M] â†’       [inst_1 : Add N] â†’         (f : M â†’â‚™+ N) â†’           (âˆ€ (x y : M), AddCommute (f x) (f y)) â†’             M â†’â‚™+ Náµƒáµ’áµ– := fun {M} {N} [Add M] [Add N] f hf => { toFun := AddOpposite.op âˆ˜ â‡‘f, map_add' := â‹¯ }
/--Oriented angles are continuous when neither end point equals the middle point. -/theorem EuclideanGeometry.continuousAt_oangle.{u_1, u_2} : âˆ€ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V]   [inst_1 : InnerProductSpace â„ V] [inst_2 : MetricSpace P] [inst_3 : NormedAddTorsor V P]   [hd2 : Fact (Module.finrank â„ V = 2)] [inst_4 : Module.Oriented â„ V (Fin 2)] {x : P Ã— P Ã— P},   x.1 â‰  x.2.1 â†’ x.2.2 â‰  x.2.1 â†’ ContinuousAt (fun y => EuclideanGeometry.oangle y.1 y.2.1 y.2.2) x := â‹¯
/--For vectors `a x y : E`, the identity `âŸªa, xâŸ« * Ï‰ a y - Ï‰ a x * âŸªa, yâŸ« = â€–aâ€– ^ 2 * Ï‰ x y`. (See `Orientation.inner_mul_areaForm_sub` for the "applied" form.) -/theorem Orientation.inner_mul_areaForm_sub'.{u_1} : âˆ€ {E : Type u_1} [inst : NormedAddCommGroup E]   [inst_1 : InnerProductSpace â„ E] [inst_2 : Fact (Module.finrank â„ E = 2)] (o : Orientation â„ E (Fin 2)) (a x : E),   inner â„ a x â€¢ o.areaForm a - (o.areaForm a) x â€¢ (innerâ‚›â‚— â„) a = â€–aâ€– ^ 2 â€¢ o.areaForm x := â‹¯
/--In a group with zero, an existential over a unit can be rewritten in terms of `Units.mk0`. -/theorem Units.exists0.{u_3} : âˆ€ {Gâ‚€ : Type u_3} [inst : GroupWithZero Gâ‚€] {p : Gâ‚€Ë£ â†’ Prop},   (âˆƒ g, p g) â†” âˆƒ g, âˆƒ (hg : g â‰  0), p (Units.mk0 g hg) := â‹¯
/--There is no surjection from `Î± : Type u` into `Type (max u v)`. This theorem demonstrates why `Type : Type` would be inconsistent in Lean. -/theorem Function.not_surjective_Type.{u, v} : âˆ€ {Î± : Type u} (f : Î± â†’ Type (max u v)), Â¬Function.Surjective f := â‹¯
/--For every open cover of a LindelÃ¶f set, there exists a countable subcover. -/theorem IsLindelof.elim_countable_subcover_image.{u, u_1} : âˆ€ {X : Type u} {Î¹ : Type u_1} [inst : TopologicalSpace X]   {s : Set X} {b : Set Î¹} {c : Î¹ â†’ Set X},   IsLindelof s â†’ (âˆ€ i âˆˆ b, IsOpen (c i)) â†’ s âŠ† â‹ƒ i âˆˆ b, c i â†’ âˆƒ b' âŠ† b, b'.Countable âˆ§ s âŠ† â‹ƒ i âˆˆ b', c i := â‹¯
/--The order of a formal power series is exactly `n` if the `n`th coefficient is nonzero, and the `i`th coefficient is `0` for all `i < n`. -/theorem PowerSeries.order_eq.{u_1} : âˆ€ {R : Type u_1} [inst : Semiring R] {Ï† : PowerSeries R} {n : â„•âˆ},   Ï†.order = n â†”     (âˆ€ (i : â„•), â†‘i = n â†’ (PowerSeries.coeff R i) Ï† â‰  0) âˆ§ âˆ€ (i : â„•), â†‘i < n â†’ (PowerSeries.coeff R i) Ï† = 0 := â‹¯
/--The functor `WalkingParallelPair â¥¤ WalkingParallelPairáµ’áµ–` sending left to left and right to right. -/def CategoryTheory.Limits.walkingParallelPairOp : CategoryTheory.Functor CategoryTheory.Limits.WalkingParallelPair   CategoryTheory.Limits.WalkingParallelPairáµ’áµ– := {   obj := fun x =>     Opposite.op       (CategoryTheory.Limits.WalkingParallelPair.casesOn (motive := fun t =>         x = t â†’ CategoryTheory.Limits.WalkingParallelPair) x (fun h => CategoryTheory.Limits.WalkingParallelPair.one)         (fun h => CategoryTheory.Limits.WalkingParallelPair.zero) â‹¯),   map := fun {X Y} f =>     CategoryTheory.Limits.WalkingParallelPairHom.casesOn (motive := fun a a_1 t =>       X = a â†’         Y = a_1 â†’           f â‰ t â†’             (Opposite.op                 (CategoryTheory.Limits.WalkingParallelPair.casesOn (motive := fun t =>                   X = t â†’ CategoryTheory.Limits.WalkingParallelPair) X                   (fun h => CategoryTheory.Limits.WalkingParallelPair.one)                   (fun h => CategoryTheory.Limits.WalkingParallelPair.zero) â‹¯) âŸ¶               Opposite.op                 (CategoryTheory.Limits.WalkingParallelPair.casesOn (motive := fun t =>                   Y = t â†’ CategoryTheory.Limits.WalkingParallelPair) Y                   (fun h => CategoryTheory.Limits.WalkingParallelPair.one)                   (fun h => CategoryTheory.Limits.WalkingParallelPair.zero) â‹¯)))       f       (fun h =>         Eq.ndrec (motive := fun {X} =>           (f : X âŸ¶ Y) â†’             Y = CategoryTheory.Limits.WalkingParallelPair.one â†’               f â‰ CategoryTheory.Limits.WalkingParallelPairHom.left â†’                 (Opposite.op                     (CategoryTheory.Limits.WalkingParallelPair.casesOn (motive := fun t =>                       X = t â†’ CategoryTheory.Limits.WalkingParallelPair) X                       (fun h => CategoryTheory.Limits.WalkingParallelPair.one)                       (fun h => CategoryTheory.Limits.WalkingParallelPair.zero) â‹¯) âŸ¶                   Opposite.op                     (CategoryTheory.Limits.WalkingParallelPair.casesOn (motive := fun t =>                       Y = t â†’ CategoryTheory.Limits.WalkingParallelPair) Y                       (fun h => CategoryTheory.Limits.WalkingParallelPair.one)                       (fun h => CategoryTheory.Limits.WalkingParallelPair.zero) â‹¯)))           (fun f h =>             Eq.ndrec (motive := fun {Y} =>               (f : CategoryTheory.Limits.WalkingParallelPair.zero âŸ¶ Y) â†’                 f â‰ CategoryTheory.Limits.WalkingParallelPairHom.left â†’                   (Opposite.op                       (CategoryTheory.Limits.WalkingParallelPair.casesOn (motive := fun t =>                         CategoryTheory.Limits.WalkingParallelPair.zero = t â†’ CategoryTheory.Limits.WalkingParallelPair)                         CategoryTheory.Limits.WalkingParallelPair.zero                         (fun h => CategoryTheory.Limits.WalkingParallelPair.one)                         (fun h => CategoryTheory.Limits.WalkingParallelPair.zero) â‹¯) âŸ¶                     Opposite.op                       (CategoryTheory.Limits.WalkingParallelPair.casesOn (motive := fun t =>                         Y = t â†’ CategoryTheory.Limits.WalkingParallelPair) Y                         (fun h => CategoryTheory.Limits.WalkingParallelPair.one)                         (fun h => CategoryTheory.Limits.WalkingParallelPair.zero) â‹¯)))               (fun f h => Quiver.Hom.op CategoryTheory.Limits.WalkingParallelPairHom.left) â‹¯ f)           â‹¯ f)       (fun h =>         Eq.ndrec (motive := fun {X} =>           (f : X âŸ¶ Y) â†’             Y = CategoryTheory.Limits.WalkingParallelPair.one â†’               f â‰ CategoryTheory.Limits.WalkingParallelPairHom.right â†’                 (Opposite.op                     (CategoryTheory.Limits.WalkingParallelPair.casesOn (motive := fun t =>                       X = t â†’ CategoryTheory.Limits.WalkingParallelPair) X                       (fun h => CategoryTheory.Limits.WalkingParallelPair.one)                       (fun h => CategoryTheory.Limits.WalkingParallelPair.zero) â‹¯) âŸ¶                   Opposite.op                     (CategoryTheory.Limits.WalkingParallelPair.casesOn (motive := fun t =>                       Y = t â†’ CategoryTheory.Limits.WalkingParallelPair) Y                       (fun h => CategoryTheory.Limits.WalkingParallelPair.one)                       (fun h => CategoryTheory.Limits.WalkingParallelPair.zero) â‹¯)))           (fun f h =>             Eq.ndrec (motive := fun {Y} =>               (f : CategoryTheory.Limits.WalkingParallelPair.zero âŸ¶ Y) â†’                 f â‰ CategoryTheory.Limits.WalkingParallelPairHom.right â†’                   (Opposite.op                       (CategoryTheory.Limits.WalkingParallelPair.casesOn (motive := fun t =>                         CategoryTheory.Limits.WalkingParallelPair.zero = t â†’ CategoryTheory.Limits.WalkingParallelPair)                         CategoryTheory.Limits.WalkingParallelPair.zero                         (fun h => CategoryTheory.Limits.WalkingParallelPair.one)                         (fun h => CategoryTheory.Limits.WalkingParallelPair.zero) â‹¯) âŸ¶                     Opposite.op                       (CategoryTheory.Limits.WalkingParallelPair.casesOn (motive := fun t =>                         Y = t â†’ CategoryTheory.Limits.WalkingParallelPair) Y                         (fun h => CategoryTheory.Limits.WalkingParallelPair.one)                         (fun h => CategoryTheory.Limits.WalkingParallelPair.zero) â‹¯)))               (fun f h => Quiver.Hom.op CategoryTheory.Limits.WalkingParallelPairHom.right) â‹¯ f)           â‹¯ f)       (fun X_1 h =>         Eq.ndrec (motive := fun X_2 =>           Y = X_2 â†’             f â‰ CategoryTheory.Limits.WalkingParallelPairHom.id X_2 â†’               (Opposite.op                   (CategoryTheory.Limits.WalkingParallelPair.casesOn (motive := fun t =>                     X = t â†’ CategoryTheory.Limits.WalkingParallelPair) X                     (fun h => CategoryTheory.Limits.WalkingParallelPair.one)                     (fun h => CategoryTheory.Limits.WalkingParallelPair.zero) â‹¯) âŸ¶                 Opposite.op                   (CategoryTheory.Limits.WalkingParallelPair.casesOn (motive := fun t =>                     Y = t â†’ CategoryTheory.Limits.WalkingParallelPair) Y                     (fun h => CategoryTheory.Limits.WalkingParallelPair.one)                     (fun h => CategoryTheory.Limits.WalkingParallelPair.zero) â‹¯)))           (fun h =>             Eq.ndrec (motive := fun {Y} =>               (f : X âŸ¶ Y) â†’                 f â‰ CategoryTheory.Limits.WalkingParallelPairHom.id X â†’                   (Opposite.op                       (CategoryTheory.Limits.WalkingParallelPair.casesOn (motive := fun t =>                         X = t â†’ CategoryTheory.Limits.WalkingParallelPair) X                         (fun h => CategoryTheory.Limits.WalkingParallelPair.one)                         (fun h => CategoryTheory.Limits.WalkingParallelPair.zero) â‹¯) âŸ¶                     Opposite.op                       (CategoryTheory.Limits.WalkingParallelPair.casesOn (motive := fun t =>                         Y = t â†’ CategoryTheory.Limits.WalkingParallelPair) Y                         (fun h => CategoryTheory.Limits.WalkingParallelPair.one)                         (fun h => CategoryTheory.Limits.WalkingParallelPair.zero) â‹¯)))               (fun f h =>                 Quiver.Hom.op                   (CategoryTheory.Limits.WalkingParallelPairHom.id                     (CategoryTheory.Limits.WalkingParallelPair.casesOn (motive := fun t =>                       X = t â†’ CategoryTheory.Limits.WalkingParallelPair) X                       (fun h => CategoryTheory.Limits.WalkingParallelPair.one)                       (fun h => CategoryTheory.Limits.WalkingParallelPair.zero) â‹¯)))               â‹¯ f)           h)       â‹¯ â‹¯ â‹¯,   map_id := CategoryTheory.Limits.walkingParallelPairOp._proof_3,   map_comp := @CategoryTheory.Limits.walkingParallelPairOp._proof_5 }
/--This lemma is specifically designed to be used backwards, whence the specialisation to `Fin n` as the indexing type doesn't matter in practice. The more general forward direction lemma here is `Fintype.card_pi`. -/theorem Fintype.card_pi_const.{u_7} : âˆ€ (Î± : Type u_7) [inst : Fintype Î±] (n : â„•),   Fintype.card (Fin n â†’ Î±) = Fintype.card Î± ^ n := â‹¯
/--A useful lemma when dealing with uniformities. -/theorem Filter.map_swap4_eq_comap.{u_1, u_2, u_3, u_4} : âˆ€ {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_4}   {f : Filter ((Î± Ã— Î²) Ã— Î³ Ã— Î´)},   Filter.map (fun p => ((p.1.1, p.2.1), p.1.2, p.2.2)) f = Filter.comap (fun p => ((p.1.1, p.2.1), p.1.2, p.2.2)) f := â‹¯
/--`a ^ 0 = 1` -/protected theorem Semifield.zpow_zero'.{u_2} : âˆ€ {K : Type u_2} [self : Semifield K] (a : K),   Semifield.zpow 0 a = 1 := â‹¯
/--The "main pair" for an algebra `(A, Î±)` is the pair of morphisms `(F Î±, Îµ_FA)`. It is always a `G`-split pair, and will be used to construct the left adjoint to the comparison functor and show it is an equivalence. -/theorem CategoryTheory.Monad.MonadicityInternal.main_pair_G_split.{vâ‚, uâ‚, uâ‚‚} : âˆ€ {C : Type uâ‚} {D : Type uâ‚‚}   [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] [inst_1 : CategoryTheory.Category.{vâ‚, uâ‚‚} D]   {G : CategoryTheory.Functor D C} {F : CategoryTheory.Functor C D} (adj : F âŠ£ G) (A : adj.toMonad.Algebra),   G.IsSplitPair (F.map A.a) (adj.counit.app (F.obj A.A)) := â‹¯
