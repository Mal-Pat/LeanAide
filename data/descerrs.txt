Succeeded for congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂
Succeeded for trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c
Succeeded for of_eq_true : ∀ {p : Prop}, p = True → p
Succeeded for symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a
Succeeded for eq_self : ∀ {α : Sort u_1} (a : α), (a = a) = True
Succeeded for congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂
Succeeded for funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g
Succeeded for Iff.rfl : ∀ {a : Prop}, a ↔ a
Succeeded for iff_self : ∀ (p : Prop), (p ↔ p) = True
Succeeded for forall_congr : ∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a
Succeeded for implies_congr : ∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂)
Succeeded for eq_true : ∀ {p : Prop}, p → p = True
Succeeded for congr_arg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂
Succeeded for Iff.trans : ∀ {a b c : Prop}, (a ↔ b) → (b ↔ c) → (a ↔ c)
Succeeded for mul_one : ∀ {M : Type u} [inst : MulOneClass M] (a : M), a * 1 = a
Succeeded for eq_false : ∀ {p : Prop}, ¬p → p = False
Succeeded for add_zero : ∀ {M : Type u} [inst : AddZeroClass M] (a : M), a + 0 = a
Succeeded for not_false_eq_true : (¬False) = True
Succeeded for Set.ext : ∀ {α : Type u_1} {a b : Set α}, (∀ (x : α), x ∈ a ↔ x ∈ b) → a = b
Succeeded for LE.le.trans : ∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c
Succeeded for zero_add : ∀ {M : Type u} [inst : AddZeroClass M] (a : M), 0 + a = a
Succeeded for mul_comm : ∀ {G : Type u_1} [inst : CommMagma G] (a b : G), a * b = b * a
Succeeded for one_mul : ∀ {M : Type u} [inst : MulOneClass M] (a : M), 1 * a = a
Succeeded for add_comm : ∀ {G : Type u_1} [inst : AddCommMagma G] (a b : G), a + b = b + a
Succeeded for le_rfl : ∀ {α : Type u} [inst : Preorder α] {a : α}, a ≤ a
Succeeded for le_antisymm : ∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≤ a → a = b
Succeeded for LT.lt.le : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b
Succeeded for Iff.symm : ∀ {a b : Prop}, (a ↔ b) → (b ↔ a)
Succeeded for if_neg : ∀ {c : Prop} {h : Decidable c}, ¬c → ∀ {α : Sort u} {t e : α}, (if c then t else e) = e
Succeeded for eq_of_heq : ∀ {α : Sort u} {a a' : α}, HEq a a' → a = a'
Succeeded for if_pos : ∀ {c : Prop} {h : Decidable c}, c → ∀ {α : Sort u} {t e : α}, (if c then t else e) = t
Succeeded for implies_true : ∀ (α : Sort u), (α → True) = True
Succeeded for Subsingleton.elim : ∀ {α : Sort u} [h : Subsingleton α] (a b : α), a = b
Succeeded for Finset.sum_congr : ∀ {α : Type u_3} {β : Type u_4} {s₁ s₂ : Finset α} {f g : α → β} [inst : AddCommMonoid β],
  s₁ = s₂ → (∀ x ∈ s₂, f x = g x) → s₁.sum f = s₂.sum g
Succeeded for mul_assoc : ∀ {G : Type u_1} [inst : Semigroup G] (a b c : G), a * b * c = a * (b * c)
Succeeded for Nat.cast_one : ∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑1 = 1
Succeeded for sub_eq_add_neg : ∀ {G : Type u_1} [inst : SubNegMonoid G] (a b : G), a - b = a + -b
Succeeded for Subtype.ext : ∀ {α : Sort u_1} {p : α → Prop} {a1 a2 : { x // p x }}, ↑a1 = ↑a2 → a1 = a2
Succeeded for of_decide_eq_true : ∀ {p : Prop} [inst : Decidable p], decide p = true → p
Succeeded for Iff.of_eq : ∀ {a b : Prop}, a = b → (a ↔ b)
Succeeded for le_trans : ∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c
Succeeded for CategoryTheory.eq_whisker' : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] {X Y : C} {f g : X ⟶ Y},
  f = g → ∀ {Z : C} (h : Y ⟶ Z), CategoryTheory.CategoryStruct.comp f h = CategoryTheory.CategoryStruct.comp g h
Succeeded for le_refl : ∀ {α : Type u} [inst : Preorder α] (a : α), a ≤ a
Succeeded for Eq.propIntro : ∀ {a b : Prop}, (a → b) → (b → a) → a = b
Succeeded for Nat.cast_zero : ∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑0 = 0
Succeeded for LT.lt.ne' : ∀ {α : Type u} [inst : Preorder α] {x y : α}, x < y → y ≠ x
Succeeded for mt : ∀ {a b : Prop}, (a → b) → ¬b → ¬a
Succeeded for map_zero : ∀ {M : Type u_4} {N : Type u_5} {F : Type u_9} [inst : Zero M] [inst_1 : Zero N] [inst_2 : FunLike F M N]
  [inst_3 : ZeroHomClass F M N] (f : F), f 0 = 0
Succeeded for true_and : ∀ (p : Prop), (True ∧ p) = p
Succeeded for and_self : ∀ (p : Prop), (p ∧ p) = p
Failed for one_smul : ∀ (M : Type u_1) {α : Type u_6} [inst : Monoid M] [inst_1 : MulAction M α] (b : α), 1 • b = b
failed to synthesize
  HSMul ℕ α α

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Succeeded for neg_neg : ∀ {G : Type u_1} [inst : InvolutiveNeg G] (a : G), - -a = a
Succeeded for Decidable.byContradiction : ∀ {p : Prop} [dec : Decidable p], (¬p → False) → p
Succeeded for add_assoc : ∀ {G : Type u_1} [inst : AddSemigroup G] (a b c : G), a + b + c = a + (b + c)
Succeeded for pow_zero : ∀ {M : Type u_2} [inst : Monoid M] (a : M), a ^ 0 = 1
Succeeded for dif_neg : ∀ {c : Prop} {h : Decidable c} (hnc : ¬c) {α : Sort u} {t : c → α} {e : ¬c → α}, dite c t e = e hnc
Succeeded for dif_pos : ∀ {c : Prop} {h : Decidable c} (hc : c) {α : Sort u} {t : c → α} {e : ¬c → α}, dite c t e = t hc
Succeeded for Mathlib.Order.Basic._auxLemma.1 : ∀ {α : Type u} [inst : Preorder α] (a : α), (a ≤ a) = True
Succeeded for eq_comm : ∀ {α : Sort u_1} {a b : α}, a = b ↔ b = a
Succeeded for Subtype.prop : ∀ {α : Sort u_1} {p : α → Prop} (x : Subtype p), p ↑x
Succeeded for Ne.symm : ∀ {α : Sort u} {a b : α}, a ≠ b → b ≠ a
Succeeded for ite_congr : ∀ {α : Sort u_1} {b c : Prop} {x y u v : α} {s : Decidable b} [inst : Decidable c],
  b = c → (c → x = u) → (¬c → y = v) → (if b then x else y) = if c then u else v
Succeeded for le_of_lt : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b
Succeeded for div_eq_mul_inv : ∀ {G : Type u_1} [inst : DivInvMonoid G] (a b : G), a / b = a * b⁻¹
Succeeded for LT.lt.ne : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≠ b
Succeeded for Equiv.apply_symm_apply : ∀ {α : Sort u} {β : Sort v} (e : α ≃ β) (x : β), e (e.symm x) = x
Succeeded for LE.le.trans_lt : ∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b < c → a < c
Succeeded for Finset.ext : ∀ {α : Type u_1} {s₁ s₂ : Finset α}, (∀ (a : α), a ∈ s₁ ↔ a ∈ s₂) → s₁ = s₂
Succeeded for Or.elim : ∀ {a b c : Prop}, a ∨ b → (a → c) → (b → c) → c
Succeeded for Filter.Eventually.mono : ∀ {α : Type u} {p q : α → Prop} {f : Filter α}, (∀ᶠ (x : α) in f, p x) → (∀ (x : α), p x → q x) → ∀ᶠ (x : α) in f, q x
Succeeded for zero_lt_one : ∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : PartialOrder α] [inst_3 : ZeroLEOneClass α]
  [inst_4 : NeZero 1], 0 < 1
Succeeded for Classical.choose_spec : ∀ {α : Sort u} {p : α → Prop} (h : ∃ x, p x), p (Classical.choose h)
Succeeded for Eq.le : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a = b → a ≤ b
Succeeded for and_true : ∀ (p : Prop), (p ∧ True) = p
Succeeded for eq_false' : ∀ {p : Prop}, (p → False) → p = False
Succeeded for map_mul : ∀ {M : Type u_4} {N : Type u_5} {F : Type u_9} [inst : Mul M] [inst_1 : Mul N] [inst_2 : FunLike F M N]
  [inst_3 : MulHomClass F M N] (f : F) (x y : M), f (x * y) = f x * f y
Succeeded for Function.Injective.eq_iff : ∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.Injective f → ∀ {a b : α}, f a = f b ↔ a = b
Succeeded for map_one : ∀ {M : Type u_4} {N : Type u_5} {F : Type u_9} [inst : One M] [inst_1 : One N] [inst_2 : FunLike F M N]
  [inst_3 : OneHomClass F M N] (f : F), f 1 = 1
Succeeded for LT.lt.trans_le : ∀ {α : Type u} [inst : Preorder α] {a b c : α}, a < b → b ≤ c → a < c
Succeeded for sub_self : ∀ {G : Type u_3} [inst : AddGroup G] (a : G), a - a = 0
Succeeded for map_add : ∀ {M : Type u_4} {N : Type u_5} {F : Type u_9} [inst : Add M] [inst_1 : Add N] [inst_2 : FunLike F M N]
  [inst_3 : AddHomClass F M N] (f : F) (x y : M), f (x + y) = f x + f y
Succeeded for eq_or_ne : ∀ {α : Sort u_1} (x y : α), x = y ∨ x ≠ y
Succeeded for Filter.univ_mem' : ∀ {α : Type u} {f : Filter α} {s : Set α}, (∀ (a : α), a ∈ s) → s ∈ f
Succeeded for Continuous.comp : ∀ {X : Type u_1} {Y : Type u_2} {Z : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]
  [inst_2 : TopologicalSpace Z] {f : X → Y} {g : Y → Z}, Continuous g → Continuous f → Continuous (g ∘ f)
Succeeded for congr_fun : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a
Failed for CategoryTheory.Limits.comp_zero : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X Y : C}
  {f : X ⟶ Y} {Z : C}, CategoryTheory.CategoryStruct.comp f 0 = 0
don't know how to synthesize implicit argument 'α'
  @Eq (X ⟶ ?m.259) (CategoryTheory.CategoryStruct.comp f 0) 0
context:
C : Type u
inst : CategoryTheory.Category.{v, u} C
inst_1 : CategoryTheory.Limits.HasZeroMorphisms C
X Y : C
f : X ⟶ Y
Z : C
⊢ Type v

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument
  @OfNat.ofNat (X ⟶ ?m.259) 0 Zero.toOfNat0
context:
C : Type u
inst : CategoryTheory.Category.{v, u} C
inst_1 : CategoryTheory.Limits.HasZeroMorphisms C
X Y : C
f : X ⟶ Y
Z : C
⊢ OfNat (X ⟶ ?m.259) 0

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'Z'
  @CategoryTheory.CategoryStruct.comp C inst.toCategoryStruct X Y ?m.259 f 0
context:
C : Type u
inst : CategoryTheory.Category.{v, u} C
inst_1 : CategoryTheory.Limits.HasZeroMorphisms C
X Y : C
f : X ⟶ Y
Z : C
⊢ C

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument
  @OfNat.ofNat (Y ⟶ ?m.259) 0 Zero.toOfNat0
context:
C : Type u
inst : CategoryTheory.Category.{v, u} C
inst_1 : CategoryTheory.Limits.HasZeroMorphisms C
X Y : C
f : X ⟶ Y
Z : C
⊢ OfNat (Y ⟶ ?m.259) 0

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for le_of_le_of_eq : ∀ {α : Type u} {a b c : α} [inst : LE α], a ≤ b → b = c → a ≤ c
Failed for smul_zero : ∀ {M : Type u_1} {A : Type u_4} [inst : Zero A] [inst_1 : SMulZeroClass M A] (a : M), a • 0 = 0
failed to synthesize
  HSMul M ℕ (?m.887 a)

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Succeeded for sub_zero : ∀ {G : Type u_3} [inst : SubNegZeroMonoid G] (a : G), a - 0 = a
Succeeded for Int.sub_nonneg_of_le : ∀ {a b : ℤ}, b ≤ a → 0 ≤ a - b
Succeeded for not_true_eq_false : (¬True) = False
Failed for Subtype.coe_injective : ∀ {α : Sort u_1} {p : α → Prop}, Function.Injective fun a => ↑a
don't know how to synthesize implicit argument 'β'
  @Function.Injective ?m.20 ?m.20 fun a => a
context:
α : Sort u_1
p : α → Prop
⊢ Sort ?u.9

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @Function.Injective ?m.20 ?m.20 fun a => a
context:
α : Sort u_1
p : α → Prop
⊢ Sort ?u.9

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
failed to infer binder type

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for Filter.mp_mem : ∀ {α : Type u} {f : Filter α} {s t : Set α}, s ∈ f → {x | x ∈ s → x ∈ t} ∈ f → t ∈ f
Failed for zero_smul : ∀ (R : Type u_1) {M : Type u_3} [inst : Zero R] [inst_1 : Zero M] [inst_2 : SMulWithZero R M] (m : M), 0 • m = 0
failed to synthesize
  HSMul ℕ M M

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Failed for CategoryTheory.Limits.zero_comp : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X Y Z : C}
  {f : Y ⟶ Z}, CategoryTheory.CategoryStruct.comp 0 f = 0
don't know how to synthesize implicit argument 'α'
  @Eq (?m.317 ⟶ Z) (CategoryTheory.CategoryStruct.comp 0 f) 0
context:
C : Type u
inst : CategoryTheory.Category.{v, u} C
inst_1 : CategoryTheory.Limits.HasZeroMorphisms C
X Y Z : C
f : Y ⟶ Z
⊢ Type v

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument
  @OfNat.ofNat (?m.317 ⟶ Z) 0 Zero.toOfNat0
context:
C : Type u
inst : CategoryTheory.Category.{v, u} C
inst_1 : CategoryTheory.Limits.HasZeroMorphisms C
X Y Z : C
f : Y ⟶ Z
⊢ OfNat (?m.317 ⟶ Z) 0

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'X'
  @CategoryTheory.CategoryStruct.comp C inst.toCategoryStruct ?m.317 Y Z 0 f
context:
C : Type u
inst : CategoryTheory.Category.{v, u} C
inst_1 : CategoryTheory.Limits.HasZeroMorphisms C
X Y Z : C
f : Y ⟶ Z
⊢ C

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument
  @OfNat.ofNat (?m.317 ⟶ Y) 0 Zero.toOfNat0
context:
C : Type u
inst : CategoryTheory.Category.{v, u} C
inst_1 : CategoryTheory.Limits.HasZeroMorphisms C
X Y Z : C
f : Y ⟶ Z
⊢ OfNat (?m.317 ⟶ Y) 0

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for Exists.choose_spec : ∀ {α : Sort u_1} {p : α → Prop} (P : ∃ a, p a), p P.choose
Failed for SetLike.coe_injective : ∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B], Function.Injective SetLike.coe
typeclass instance problem is stuck, it is often due to metavariables
  SetLike ?m.276 ?m.277

----
Succeeded for HasSubset.Subset.trans : ∀ {α : Type u} [inst : HasSubset α] [inst_1 : IsTrans α fun x x_1 => x ⊆ x_1] {a b c : α}, a ⊆ b → b ⊆ c → a ⊆ c
Succeeded for pow_one : ∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 1 = a
Succeeded for neg_zero : ∀ {G : Type u_1} [inst : NegZeroClass G], -0 = 0
Failed for exists_prop_congr' : ∀ {p p' : Prop} {q q' : p → Prop}, (∀ (h : p), q h ↔ q' h) → ∀ (hp : p ↔ p'), Exists q = ∃ (h : p'), q' ⋯
don't know how to synthesize placeholder
context:
p p' : Prop
q q' : p → Prop
hp : p ↔ p'
h : p'
⊢ p

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Failed for LinearMap.ext : ∀ {R : Type u_1} {S : Type u_6} {M : Type u_9} {M₃ : Type u_12} [inst : Semiring R] [inst_1 : Semiring S]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₃] [inst_4 : Module R M] [inst_5 : Module S M₃] {σ : R →+* S}
  {f g : M →ₛₗ[σ] M₃}, (∀ (x : M), f x = g x) → f = g
unknown universe level 'u_12'

----
Succeeded for ite_cond_eq_true : ∀ {α : Sort u} {c : Prop} {x : Decidable c} (a b : α), c = True → (if c then a else b) = a
Failed for DFunLike.coe_injective : ∀ {F : Sort u_1} {α : Sort u_2} {β : α → Sort u_3} [i : DFunLike F α β], Function.Injective fun f => ⇑f
cannot coerce to function
  f

----
Succeeded for Int.add_one_le_of_lt : ∀ {a b : ℤ}, a < b → a + 1 ≤ b
Succeeded for congrFun : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a
Succeeded for Filter.eventually_of_forall : ∀ {α : Type u} {p : α → Prop} {f : Filter α}, (∀ (x : α), p x) → ∀ᶠ (x : α) in f, p x
Succeeded for and_false : ∀ (p : Prop), (p ∧ False) = False
Succeeded for le_top : ∀ {α : Type u} [inst : LE α] [inst_1 : OrderTop α] {a : α}, a ≤ ⊤
Succeeded for Nat.lt_of_not_le : ∀ {a b : ℕ}, ¬a ≤ b → b < a
Failed for continuous_id : ∀ {X : Type u_1} [inst : TopologicalSpace X], Continuous id
typeclass instance problem is stuck, it is often due to metavariables
  TopologicalSpace ?m.1233

----
Succeeded for lt_of_le_of_lt : ∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b < c → a < c
Succeeded for inv_inv : ∀ {G : Type u_1} [inst : InvolutiveInv G] (a : G), a⁻¹⁻¹ = a
Succeeded for Mathlib.Data.Set.Basic._auxLemma.45 : ∀ {α : Sort u_1} {p : α → Prop} {b : Prop}, (∃ x, b ∧ p x) = (b ∧ ∃ x, p x)
Succeeded for Eq.ge : ∀ {α : Type u} [inst : Preorder α] {x y : α}, x = y → y ≤ x
Succeeded for Equiv.symm_apply_apply : ∀ {α : Sort u} {β : Sort v} (e : α ≃ β) (x : α), e.symm (e x) = x
Succeeded for pow_succ : ∀ {M : Type u_2} [inst : Monoid M] (a : M) (n : ℕ), a ^ (n + 1) = a ^ n * a
Succeeded for Iff.not : ∀ {a b : Prop}, (a ↔ b) → (¬a ↔ ¬b)
Succeeded for ite_cond_eq_false : ∀ {α : Sort u} {c : Prop} {x : Decidable c} (a b : α), c = False → (if c then a else b) = b
Succeeded for Equiv.injective : ∀ {α : Sort u} {β : Sort v} (e : α ≃ β), Function.Injective ⇑e
Succeeded for bot_le : ∀ {α : Type u} [inst : LE α] [inst_1 : OrderBot α] {a : α}, ⊥ ≤ a
Succeeded for Filter.Tendsto.comp : ∀ {α : Type u} {β : Type v} {γ : Type w} {f : α → β} {g : β → γ} {x : Filter α} {y : Filter β} {z : Filter γ},
  Filter.Tendsto g y z → Filter.Tendsto f x y → Filter.Tendsto (g ∘ f) x z
Succeeded for Mathlib.Logic.Basic._auxLemma.44 : ∀ {p : Prop} {q : p → Prop}, ¬p → (∃ (h' : p), q h') = False
Succeeded for Filter.mem_of_superset : ∀ {α : Type u} {f : Filter α} {x y : Set α}, x ∈ f → x ⊆ y → y ∈ f
Failed for continuous_const : ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {y : Y}, Continuous fun x => y
typeclass instance problem is stuck, it is often due to metavariables
  TopologicalSpace ?m.844

----
Succeeded for LE.le.antisymm : ∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≤ a → a = b
Succeeded for or_true : ∀ (p : Prop), (p ∨ True) = True
Succeeded for false_and : ∀ (p : Prop), (False ∧ p) = False
Succeeded for true_or : ∀ (p : Prop), (True ∨ p) = True
Succeeded for inf_le_left : ∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b ≤ a
Failed for CategoryTheory.NatTrans.ext' : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  {F G : CategoryTheory.Functor C D} {α β : F ⟶ G}, α.app = β.app → α = β
unknown universe level 'v₁'

----
Succeeded for one_ne_zero : ∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : NeZero 1], 1 ≠ 0
Succeeded for le_of_eq : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a = b → a ≤ b
Succeeded for Prod.ext : ∀ {α : Type u_1} {β : Type u_2} {x y : α × β}, x.1 = y.1 → x.2 = y.2 → x = y
Succeeded for norm_nonneg : ∀ {E : Type u_6} [inst : SeminormedAddGroup E] (a : E), 0 ≤ ‖a‖
Failed for zero_le : ∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] (a : α), 0 ≤ a
invalid binder annotation, type is not a class instance
  CanonicallyOrderedAddCommMonoid α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for Exists.imp : ∀ {α : Sort u_1} {p q : α → Prop}, (∀ (a : α), p a → q a) → (∃ a, p a) → ∃ a, q a
Failed for mul_add : ∀ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : LeftDistribClass R] (a b c : R), a * (b + c) = a * b + a * c
unknown universe level 'x'

----
Succeeded for LT.lt.not_le : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → ¬b ≤ a
Succeeded for CategoryTheory.cancel_mono : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y Z : C} (f : X ⟶ Y) [inst_1 : CategoryTheory.Mono f]
  {g h : Z ⟶ X}, CategoryTheory.CategoryStruct.comp g f = CategoryTheory.CategoryStruct.comp h f ↔ g = h
Succeeded for Mathlib.Algebra.NeZero._auxLemma.4 : ∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : NeZero 1], (1 = 0) = False
Succeeded for Set.mem_image_of_mem : ∀ {α : Type u} {β : Type v} (f : α → β) {x : α} {a : Set α}, x ∈ a → f x ∈ f '' a
Succeeded for Mathlib.Logic.IsEmpty._auxLemma.1 : ∀ {α : Sort u_1} [inst : IsEmpty α] {p : α → Prop}, (∀ (a : α), p a) = True
Succeeded for Subtype.eq : ∀ {α : Type u} {p : α → Prop} {a1 a2 : { x // p x }}, ↑a1 = ↑a2 → a1 = a2
Succeeded for Or.resolve_left : ∀ {a b : Prop}, a ∨ b → ¬a → b
Succeeded for zero_le_one : ∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : LE α] [inst_3 : ZeroLEOneClass α], 0 ≤ 1
Succeeded for le_total : ∀ {α : Type u} [inst : LinearOrder α] (a b : α), a ≤ b ∨ b ≤ a
Succeeded for neg_mul : ∀ {α : Type u} [inst : Mul α] [inst_1 : HasDistribNeg α] (a b : α), -a * b = -(a * b)
Succeeded for em : ∀ (p : Prop), p ∨ ¬p
Succeeded for add_le_add : ∀ {α : Type u_1} [inst : Add α] [inst_1 : Preorder α]
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]
  [inst_3 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b c d : α},
  a ≤ b → c ≤ d → a + c ≤ b + d
Succeeded for or_false : ∀ (p : Prop), (p ∨ False) = p
Succeeded for mul_neg : ∀ {α : Type u} [inst : Mul α] [inst_1 : HasDistribNeg α] (a b : α), a * -b = -(a * b)
Succeeded for lt_of_lt_of_le : ∀ {α : Type u} [inst : Preorder α] {a b c : α}, a < b → b ≤ c → a < c
Succeeded for Finset.prod_congr : ∀ {α : Type u_3} {β : Type u_4} {s₁ s₂ : Finset α} {f g : α → β} [inst : CommMonoid β],
  s₁ = s₂ → (∀ x ∈ s₂, f x = g x) → s₁.prod f = s₂.prod g
Succeeded for Nat.zero_le : ∀ (n : ℕ), 0 ≤ n
Succeeded for Set.mem_univ : ∀ {α : Type u} (x : α), x ∈ Set.univ
Succeeded for le_sup_left : ∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ≤ a ⊔ b
Succeeded for Mathlib.Data.Fintype.Basic._auxLemma.1 : ∀ {α : Type u_1} [inst : Fintype α] (x : α), (x ∈ Finset.univ) = True
Succeeded for Set.image_univ : ∀ {α : Type u_1} {β : Type u_2} {f : α → β}, f '' Set.univ = Set.range f
Succeeded for DFunLike.congr_fun : ∀ {F : Sort u_1} {α : Sort u_2} {β : α → Sort u_3} [i : DFunLike F α β] {f g : F}, f = g → ∀ (x : α), f x = g x
Succeeded for IsOpen.mem_nhds : ∀ {X : Type u} {x : X} {s : Set X} [inst : TopologicalSpace X], IsOpen s → x ∈ s → s ∈ nhds x
Succeeded for one_div : ∀ {G : Type u_3} [inst : DivInvMonoid G] (a : G), 1 / a = a⁻¹
Succeeded for Nat.cast_add : ∀ {R : Type u_1} [inst : AddMonoidWithOne R] (m n : ℕ), ↑(m + n) = ↑m + ↑n
Succeeded for Set.inter_comm : ∀ {α : Type u} (a b : Set α), a ∩ b = b ∩ a
Succeeded for Int.ofNat_add : ∀ (n m : ℕ), ↑(n + m) = ↑n + ↑m
Succeeded for Mathlib.Data.Set.Defs._auxLemma.1 : ∀ {α : Type u} (x : α), (x ∈ Set.univ) = True
Succeeded for forall_congr' : ∀ {α : Sort u_1} {p q : α → Prop}, (∀ (a : α), p a ↔ q a) → ((∀ (a : α), p a) ↔ ∀ (a : α), q a)
Succeeded for Measurable.comp : ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {x : MeasurableSpace α} {x_1 : MeasurableSpace β}
  {x_2 : MeasurableSpace γ} {g : β → γ} {f : α → β}, Measurable g → Measurable f → Measurable (g ∘ f)
Failed for add_mul : ∀ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : RightDistribClass R] (a b c : R), (a + b) * c = a * c + b * c
unknown universe level 'x'

----
Succeeded for subset_closure : ∀ {X : Type u} {s : Set X} [inst : TopologicalSpace X], s ⊆ closure s
Succeeded for ne_of_gt : ∀ {α : Type u} [inst : Preorder α] {a b : α}, b < a → a ≠ b
Succeeded for Continuous.continuousAt : ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X → Y} {x : X},
  Continuous f → ContinuousAt f x
Succeeded for LT.lt.trans : ∀ {α : Type u} [inst : Preorder α] {a b c : α}, a < b → b < c → a < c
Succeeded for false_or : ∀ (p : Prop), (False ∨ p) = p
Succeeded for one_pow : ∀ {M : Type u} [inst : Monoid M] (n : ℕ), 1 ^ n = 1
Succeeded for refl : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsRefl α r] (a : α), r a a
Succeeded for Set.image_congr : ∀ {α : Type u_1} {β : Type u_2} {f g : α → β} {s : Set α}, (∀ a ∈ s, f a = g a) → f '' s = g '' s
Succeeded for Filter.EventuallyEq.symm : ∀ {α : Type u} {β : Type v} {f g : α → β} {l : Filter α}, l.EventuallyEq f g → l.EventuallyEq g f
Succeeded for le_sup_right : ∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, b ≤ a ⊔ b
Succeeded for Set.Subset.trans : ∀ {α : Type u} {a b c : Set α}, a ⊆ b → b ⊆ c → a ⊆ c
Succeeded for DFunLike.ext : ∀ {F : Sort u_1} {α : Sort u_2} {β : α → Sort u_3} [i : DFunLike F α β] (f g : F), (∀ (x : α), f x = g x) → f = g
Succeeded for inf_le_right : ∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b ≤ b
Succeeded for Finsupp.ext : ∀ {α : Type u_1} {M : Type u_5} [inst : Zero M] {f g : α →₀ M}, (∀ (a : α), f a = g a) → f = g
Succeeded for Finset.mem_univ : ∀ {α : Type u_1} [inst : Fintype α] (x : α), x ∈ Finset.univ
Succeeded for Quotient.inductionOn : ∀ {α : Sort u} {s : Setoid α} {motive : Quotient s → Prop} (q : Quotient s), (∀ (a : α), motive ⟦a⟧) → motive q
Succeeded for Int.cast_ofNat : ∀ {R : Type u} [inst : AddGroupWithOne R] (n : ℕ) [inst_1 : n.AtLeastTwo], ↑(OfNat.ofNat n) = OfNat.ofNat n
Succeeded for Mathlib.Data.Set.Defs._auxLemma.4 : ∀ {α : Type u} {β : Type v} {f : α → β} {s : Set β} {a : α}, (a ∈ f ⁻¹' s) = (f a ∈ s)
Succeeded for implies_congr_ctx : ∀ {p₁ p₂ q₁ q₂ : Prop}, p₁ = p₂ → (p₂ → q₁ = q₂) → (p₁ → q₁) = (p₂ → q₂)
Succeeded for add_le_add_left : ∀ {α : Type u_1} [inst : Add α] [inst_1 : LE α]
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {b c : α}, b ≤ c → ∀ (a : α), a + b ≤ a + c
Succeeded for AddMonoidHom.ext : ∀ {M : Type u_4} {N : Type u_5} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] ⦃f g : M →+ N⦄,
  (∀ (x : M), f x = g x) → f = g
Succeeded for exists_congr : ∀ {α : Sort u_1} {p q : α → Prop}, (∀ (a : α), p a ↔ q a) → ((∃ a, p a) ↔ ∃ a, q a)
Succeeded for Set.Subset.rfl : ∀ {α : Type u} {s : Set α}, s ⊆ s
Succeeded for Set.mem_range_self : ∀ {α : Type u} {ι : Sort u_1} {f : ι → α} (i : ι), f i ∈ Set.range f
Succeeded for not_lt : ∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a < b ↔ b ≤ a
Failed for Mathlib.Algebra.Order.Monoid.Canonical.Defs._auxLemma.7 : ∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] (a : α), (0 ≤ a) = True
invalid binder annotation, type is not a class instance
  CanonicallyOrderedAddCommMonoid α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Failed for smul_assoc : ∀ {α : Type u_6} {M : Type u_10} {N : Type u_11} [inst : SMul M N] [inst_1 : SMul N α] [inst_2 : SMul M α]
  [inst_3 : IsScalarTower M N α] (x : M) (y : N) (z : α), (x • y) • z = x • y • z
unknown universe level 'u_11'

----
Succeeded for Set.inter_subset_left : ∀ {α : Type u} (s t : Set α), s ∩ t ⊆ s
Succeeded for LE.le.trans_eq : ∀ {α : Type u} {a b c : α} [inst : LE α], a ≤ b → b = c → a ≤ c
Succeeded for Set.Subset.antisymm : ∀ {α : Type u} {a b : Set α}, a ⊆ b → b ⊆ a → a = b
Succeeded for RingHom.ext : ∀ {α : Type u_2} {β : Type u_3} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} ⦃f g : α →+* β⦄,
  (∀ (x_2 : α), f x_2 = g x_2) → f = g
Failed for MeasureTheory.measure_mono : ∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {s₁ s₂ : Set α}, s₁ ⊆ s₂ → ↑↑μ s₁ ≤ ↑↑μ s₂
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known

----
Succeeded for Classical.em : ∀ (p : Prop), p ∨ ¬p
Succeeded for CategoryTheory.cancel_epi : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y Z : C} (f : X ⟶ Y) [inst_1 : CategoryTheory.Epi f]
  {g h : Y ⟶ Z}, CategoryTheory.CategoryStruct.comp f g = CategoryTheory.CategoryStruct.comp f h ↔ g = h
Failed for dite_congr : ∀ {b c : Prop} {α : Sort u_1} {x : Decidable b} [inst : Decidable c] {x_1 : b → α} {u : c → α} {y : ¬b → α} {v : ¬c → α}
  (h₁ : b = c), (∀ (h : c), x_1 ⋯ = u h) → (∀ (h : ¬c), y ⋯ = v h) → dite b x_1 y = dite c u v
don't know how to synthesize placeholder
context:
b c : Prop
α : Sort u_1
x : Decidable b
inst : Decidable c
x_1 : b → α
u : c → α
y : ¬b → α
v : ¬c → α
h₁ : b = c
h : ¬c
⊢ ¬b

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize placeholder
context:
b c : Prop
α : Sort u_1
x : Decidable b
inst : Decidable c
x_1 : b → α
u : c → α
y : ¬b → α
v : ¬c → α
h₁ : b = c
h : c
⊢ b

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for Or.imp : ∀ {a c b d : Prop}, (a → c) → (b → d) → a ∨ b → c ∨ d
Succeeded for or_self : ∀ (p : Prop), (p ∨ p) = p
Succeeded for Quot.inductionOn : ∀ {α : Sort u} {r : α → α → Prop} {motive : Quot r → Prop} (q : Quot r), (∀ (a : α), motive (Quot.mk r a)) → motive q
Succeeded for not_le : ∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a ≤ b ↔ b < a
Succeeded for two_mul : ∀ {α : Type u} [inst : NonAssocSemiring α] (n : α), 2 * n = n + n
Succeeded for neg_add_rev : ∀ {G : Type u_1} [inst : SubtractionMonoid G] (a b : G), -(a + b) = -b + -a
Succeeded for Mathlib.Order.Basic._auxLemma.2 : ∀ {α : Type u} [inst : Preorder α] (x : α), (x < x) = False
Succeeded for compl_compl : ∀ {α : Type u} [inst : BooleanAlgebra α] (x : α), xᶜᶜ = x
Succeeded for Function.Surjective.forall : ∀ {α : Sort u_1} {β : Sort u_2} {f : α → β},
  Function.Surjective f → ∀ {p : β → Prop}, (∀ (y : β), p y) ↔ ∀ (x : α), p (f x)
Succeeded for zpow_coe_nat : ∀ {G : Type u_1} [inst : DivInvMonoid G] (a : G) (n : ℕ), a ^ ↑n = a ^ n
Failed for continuous_fst : ∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], Continuous Prod.fst
typeclass instance problem is stuck, it is often due to metavariables
  TopologicalSpace ?m.1262

----
Succeeded for and_comm : ∀ {a b : Prop}, a ∧ b ↔ b ∧ a
Succeeded for map_sum : ∀ {α : Type u_3} {β : Type u_4} {γ : Type u_5} [inst : AddCommMonoid β] [inst_1 : AddCommMonoid γ] {G : Type u_6}
  [inst_2 : FunLike G β γ] [inst_3 : AddMonoidHomClass G β γ] (g : G) (f : α → β) (s : Finset α),
  g (s.sum fun x => f x) = s.sum fun x => g (f x)
Succeeded for not_congr : ∀ {a b : Prop}, (a ↔ b) → (¬a ↔ ¬b)
Succeeded for lt_irrefl : ∀ {α : Type u} [inst : Preorder α] (a : α), ¬a < a
Failed for Units.ext : ∀ {α : Type u} [inst : Monoid α], Function.Injective Units.val
typeclass instance problem is stuck, it is often due to metavariables
  Monoid ?m.339

----
Succeeded for Set.subset_univ : ∀ {α : Type u} (s : Set α), s ⊆ Set.univ
Failed for dite_cond_eq_true : ∀ {α : Sort u} {c : Prop} {x : Decidable c} {t : c → α} {e : ¬c → α} (h : c = True), dite c t e = t ⋯
don't know how to synthesize placeholder
context:
α : Sort u
c : Prop
x : Decidable c
t : c → α
e : ¬c → α
h : c = True
⊢ c

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for smul_add : ∀ {M : Type u_1} {A : Type u_4} [inst : AddZeroClass A] [inst_1 : DistribSMul M A] (a : M) (b₁ b₂ : A),
  a • (b₁ + b₂) = a • b₁ + a • b₂
Failed for inv_one : ∀ {G : Type u_1} [inst : InvOneClass G], 1⁻¹ = 1
failed to synthesize
  Inv ℕ

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Succeeded for sub_eq_zero : ∀ {G : Type u_3} [inst : AddGroup G] {a b : G}, a - b = 0 ↔ a = b
Succeeded for not_iff_not : ∀ {a b : Prop}, (¬a ↔ ¬b) ↔ (a ↔ b)
Succeeded for le_max_left : ∀ {α : Type u} [inst : LinearOrder α] (a b : α), a ≤ max a b
Succeeded for Continuous.continuousOn : ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β} {s : Set α},
  Continuous f → ContinuousOn f s
Succeeded for MonoidHom.ext : ∀ {M : Type u_4} {N : Type u_5} [inst : MulOneClass M] [inst_1 : MulOneClass N] ⦃f g : M →* N⦄,
  (∀ (x : M), f x = g x) → f = g
Failed for MeasureTheory.Measure.ext : ∀ {α : Type u_1} [inst : MeasurableSpace α] {μ₁ μ₂ : MeasureTheory.Measure α},
  (∀ (s : Set α), MeasurableSet s → ↑↑μ₁ s = ↑↑μ₂ s) → μ₁ = μ₂
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known

----
Failed for Set.mem_singleton : ∀ {α : Type u} (a : α), a ∈ {a}
typeclass instance problem is stuck, it is often due to metavariables
  Singleton α (?m.450 a)

----
Failed for continuous_snd : ∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], Continuous Prod.snd
typeclass instance problem is stuck, it is often due to metavariables
  TopologicalSpace ?m.1264

----
Failed for CategoryTheory.ConcreteCategory.hom_ext : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.ConcreteCategory C] {X Y : C}
  (f g : X ⟶ Y), (∀ (x : (CategoryTheory.forget C).obj X), f x = g x) → f = g
type expected, got
  (CategoryTheory.ConcreteCategory
  C : (FC : outParam (C → C → Type ?u.7)) →
  {CC : outParam (C → Type ?u.10)} →
    [outParam ((X Y : C) → FunLike (FC X Y) (CC X) (CC Y))] → Type (max (max u ?u.7) v))

----
Succeeded for CategoryTheory.Iso.inv_hom_id_assoc : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} (self : X ≅ Y) {Z : C} (h : Y ⟶ Z),
  CategoryTheory.CategoryStruct.comp self.inv (CategoryTheory.CategoryStruct.comp self.hom h) = h
Succeeded for neg_sub : ∀ {α : Type u_1} [inst : SubtractionMonoid α] (a b : α), -(a - b) = b - a
Succeeded for Nat.succ_pos : ∀ (n : ℕ), 0 < n.succ
Succeeded for Mathlib.Data.SetLike.Basic._auxLemma.3 : ∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x ∈ ↑p) = (x ∈ p)
Succeeded for sub_add_cancel : ∀ {G : Type u_3} [inst : AddGroup G] (a b : G), a - b + b = a
Succeeded for Nat.lt_succ_self : ∀ (n : ℕ), n < n.succ
Succeeded for tendsto_const_nhds : ∀ {X : Type u} {α : Type u_1} {x : X} [inst : TopologicalSpace X] {f : Filter α},
  Filter.Tendsto (fun x_1 => x) f (nhds x)
Succeeded for Mathlib.Data.Set.Defs._auxLemma.7 : ∀ {α : Type u} {ι : Sort u_1} {f : ι → α} {x : α}, (x ∈ Set.range f) = ∃ y, f y = x
Succeeded for LE.le.not_lt : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a ≤ b → ¬b < a
Succeeded for sq : ∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 2 = a * a
Succeeded for Nat.le_of_not_lt : ∀ {a b : ℕ}, ¬a < b → b ≤ a
Succeeded for mul_inv_rev : ∀ {G : Type u_1} [inst : DivisionMonoid G] (a b : G), (a * b)⁻¹ = b⁻¹ * a⁻¹
Succeeded for Set.singleton_subset_iff : ∀ {α : Type u} {a : α} {s : Set α}, {a} ⊆ s ↔ a ∈ s
Succeeded for Set.univ_inter : ∀ {α : Type u} (a : Set α), Set.univ ∩ a = a
Succeeded for DFunLike.ext_iff : ∀ {F : Sort u_1} {α : Sort u_2} {β : α → Sort u_3} [i : DFunLike F α β] {f g : F}, f = g ↔ ∀ (x : α), f x = g x
Succeeded for add_le_add_right : ∀ {α : Type u_1} [inst : Add α] [inst_1 : LE α]
  [i : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {b c : α},
  b ≤ c → ∀ (a : α), b + a ≤ c + a
Succeeded for Int.cast_one : ∀ {R : Type u} [inst : AddGroupWithOne R], ↑1 = 1
Succeeded for Or.resolve_right : ∀ {a b : Prop}, a ∨ b → ¬b → a
Succeeded for Set.eq_empty_or_nonempty : ∀ {α : Type u} (s : Set α), s = ∅ ∨ s.Nonempty
Failed for CategoryTheory.Limits.limit.lift_π : ∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] {C : Type u} [inst_1 : CategoryTheory.Category.{v, u} C]
  {F : CategoryTheory.Functor J C} [inst_2 : CategoryTheory.Limits.HasLimit F] (c : CategoryTheory.Limits.Cone F)
  (j : J),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.lift F c) (CategoryTheory.Limits.limit.π F j) =
    c.π.app j
unknown universe level 'v₁'

----
Succeeded for Filter.HasBasis.mem_iff : ∀ {α : Type u_1} {ι : Sort u_4} {l : Filter α} {p : ι → Prop} {s : ι → Set α} {t : Set α},
  l.HasBasis p s → (t ∈ l ↔ ∃ i, p i ∧ s i ⊆ t)
Succeeded for Set.inter_subset_right : ∀ {α : Type u} (s t : Set α), s ∩ t ⊆ t
Succeeded for sup_le : ∀ {α : Type u} [inst : SemilatticeSup α] {a b c : α}, a ≤ c → b ≤ c → a ⊔ b ≤ c
Succeeded for NNReal.eq : ∀ {n m : NNReal}, ↑n = ↑m → n = m
Succeeded for Mathlib.Logic.Basic._auxLemma.10 : ∀ {a b : Prop}, (a ∨ b) = (b ∨ a)
Succeeded for Nat.add_comm : ∀ (n m : ℕ), n + m = m + n
Succeeded for mul_pos : ∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : PosMulStrictMono α],
  0 < a → 0 < b → 0 < a * b
Succeeded for HasSubset.Subset.antisymm : ∀ {α : Type u} [inst : HasSubset α] {a b : α} [inst_1 : IsAntisymm α fun x x_1 => x ⊆ x_1], a ⊆ b → b ⊆ a → a = b
Succeeded for le_or_lt : ∀ {α : Type u} [inst : LinearOrder α] (a b : α), a ≤ b ∨ b < a
Succeeded for dist_comm : ∀ {α : Type u} [inst : PseudoMetricSpace α] (x y : α), dist x y = dist y x
Succeeded for Summable.hasSum : ∀ {α : Type u_1} {β : Type u_2} [inst : AddCommMonoid α] [inst_1 : TopologicalSpace α] {f : β → α},
  Summable f → HasSum f (∑' (b : β), f b)
Failed for Set.iUnion_congr_Prop : ∀ {α : Type u_1} {p q : Prop} {f₁ : p → Set α} {f₂ : q → Set α} (pq : p ↔ q),
  (∀ (x : q), f₁ ⋯ = f₂ x) → Set.iUnion f₁ = Set.iUnion f₂
don't know how to synthesize placeholder
context:
α : Type u_1
p q : Prop
f₁ : p → Set α
f₂ : q → Set α
pq : p ↔ q
x : q
⊢ p

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Failed for pos_iff_ne_zero : ∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] {a : α}, 0 < a ↔ a ≠ 0
invalid binder annotation, type is not a class instance
  CanonicallyOrderedAddCommMonoid α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Failed for CategoryTheory.Limits.colimit.ι_desc : ∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] {C : Type u} [inst_1 : CategoryTheory.Category.{v, u} C]
  {F : CategoryTheory.Functor J C} [inst_2 : CategoryTheory.Limits.HasColimit F] (c : CategoryTheory.Limits.Cocone F)
  (j : J),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) (CategoryTheory.Limits.colimit.desc F c) =
    c.ι.app j
unknown universe level 'v₁'

----
Succeeded for Continuous.prod_mk : ∀ {X : Type u} {Y : Type v} {Z : Type u_1} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]
  [inst_2 : TopologicalSpace Z] {f : Z → X} {g : Z → Y}, Continuous f → Continuous g → Continuous fun x => (f x, g x)
Succeeded for nonempty_fintype : ∀ (α : Type u_4) [inst : Finite α], Nonempty (Fintype α)
Succeeded for max_eq_left : ∀ {α : Type u} [inst : LinearOrder α] {a b : α}, b ≤ a → max a b = a
Succeeded for Set.image_subset : ∀ {α : Type u_1} {β : Type u_2} {a b : Set α} (f : α → β), a ⊆ b → f '' a ⊆ f '' b
Succeeded for Set.image_subset_iff : ∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : Set β} {f : α → β}, f '' s ⊆ t ↔ s ⊆ f ⁻¹' t
Succeeded for ContinuousMap.ext : ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f g : C(α, β)},
  (∀ (a : α), f a = g a) → f = g
Succeeded for tsub_add_cancel_of_le : ∀ {α : Type u_1} [inst : AddCommSemigroup α] [inst_1 : PartialOrder α] [inst_2 : ExistsAddOfLE α]
  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_4 : Sub α] [inst_5 : OrderedSub α]
  {a b : α}, a ≤ b → b - a + a = b
Succeeded for Nat.pos_of_ne_zero : ∀ {n : ℕ}, n ≠ 0 → 0 < n
Succeeded for abs_of_nonneg : ∀ {α : Type u_1} [inst : Lattice α] [inst_1 : AddGroup α] {a : α}
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], 0 ≤ a → |a| = a
Succeeded for sup_comm : ∀ {α : Type u} [inst : SemilatticeSup α] (a b : α), a ⊔ b = b ⊔ a
Succeeded for AddMonoidHom.map_add : ∀ {M : Type u_4} {N : Type u_5} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (f : M →+ N) (a b : M),
  f (a + b) = f a + f b
Succeeded for Function.Injective.injOn : ∀ {α : Type u_1} {β : Type u_2} {f : α → β}, Function.Injective f → ∀ (s : Set α), Set.InjOn f s
Succeeded for eq_top_iff : ∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderTop α] {a : α}, a = ⊤ ↔ ⊤ ≤ a
Succeeded for Continuous.measurable : ∀ {α : Type u_1} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α]
  [inst_2 : OpensMeasurableSpace α] [inst_3 : TopologicalSpace γ] [inst_4 : MeasurableSpace γ] [inst_5 : BorelSpace γ]
  {f : α → γ}, Continuous f → Measurable f
Failed for exists_pair_ne : ∀ (α : Type u_3) [inst : Nontrivial α], ∃ x y, x ≠ y
don't know how to synthesize implicit argument 'α'
  @Exists (?m.25 α) fun x => ∃ y, x ≠ y
context:
α : Type u_3
inst : Nontrivial α
⊢ Sort ?u.13

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @Exists (?m.25 α) fun y => x ≠ y
context:
α : Type u_3
inst : Nontrivial α
x : ?m.25 α
⊢ Sort ?u.13

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @Ne (?m.25 α) x y
context:
α : Type u_3
inst : Nontrivial α
x y : ?m.25 α
⊢ Sort ?u.13

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
failed to infer binder type

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
failed to infer binder type

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for smul_eq_mul : ∀ (α : Type u_10) [inst : Mul α] {a a' : α}, a • a' = a * a'
Failed for norm_zero : ∀ {E : Type u_6} [inst : SeminormedAddGroup E], ‖0‖ = 0
failed to synthesize
  Norm ℕ

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Succeeded for Subtype.ext_iff : ∀ {α : Sort u_1} {p : α → Prop} {a1 a2 : { x // p x }}, a1 = a2 ↔ ↑a1 = ↑a2
Succeeded for Nat.cast_succ : ∀ {R : Type u_1} [inst : AddMonoidWithOne R] (n : ℕ), ↑n.succ = ↑n + 1
Succeeded for isClosed_closure : ∀ {X : Type u} {s : Set X} [inst : TopologicalSpace X], IsClosed (closure s)
Succeeded for Nat.succ_ne_zero : ∀ (n : ℕ), n.succ ≠ 0
Succeeded for lt_of_le_of_ne : ∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → a ≠ b → a < b
Failed for Quiver.Hom.unop_inj : ∀ {C : Type u₁} [inst : Quiver C] {X Y : Cᵒᵖ}, Function.Injective Quiver.Hom.unop
typeclass instance problem is stuck, it is often due to metavariables
  Quiver ?m.99

----
Succeeded for le_max_right : ∀ {α : Type u} [inst : LinearOrder α] (a b : α), b ≤ max a b
Failed for iInf_congr_Prop : ∀ {α : Type u_1} [inst : InfSet α] {p q : Prop} {f₁ : p → α} {f₂ : q → α} (pq : p ↔ q),
  (∀ (x : q), f₁ ⋯ = f₂ x) → iInf f₁ = iInf f₂
don't know how to synthesize placeholder
context:
α : Type u_1
inst : InfSet α
p q : Prop
f₁ : p → α
f₂ : q → α
pq : p ↔ q
x : q
⊢ p

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for div_zero : ∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] (a : G₀), a / 0 = 0
Succeeded for mul_le_mul_of_nonneg_left : ∀ {α : Type u_1} {a b c : α} [inst : Mul α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : PosMulMono α],
  b ≤ c → 0 ≤ a → a * b ≤ a * c
Succeeded for Eq.mpr_prop : ∀ {p q : Prop}, p = q → q → p
Failed for continuous_apply : ∀ {ι : Type u_5} {π : ι → Type u_6} [T : (i : ι) → TopologicalSpace (π i)] (i : ι), Continuous fun p => p i
Function expected at
  p
but this term has type
  ?m.1256 i

Note: Expected a function because this term is being applied to the argument
  i

----
Succeeded for map_neg : ∀ {G : Type u_7} {H : Type u_8} {F : Type u_9} [inst : FunLike F G H] [inst_1 : AddGroup G]
  [inst_2 : SubtractionMonoid H] [inst_3 : AddMonoidHomClass F G H] (f : F) (a : G), f (-a) = -f a
Succeeded for Eq.trans_le : ∀ {α : Type u} {a b c : α} [inst : LE α], a = b → b ≤ c → a ≤ c
Succeeded for Measurable.aemeasurable : ∀ {α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} [inst : MeasurableSpace β] {f : α → β}
  {μ : MeasureTheory.Measure α}, Measurable f → AEMeasurable f μ
Failed for Mathlib.Data.Finset.Basic._auxLemma.28 : ∀ {α : Type u_1} {a b : α}, (b ∈ {a}) = (b = a)
typeclass instance problem is stuck, it is often due to metavariables
  Singleton α ?m.985

----
Succeeded for map_sub : ∀ {G : Type u_7} {H : Type u_8} {F : Type u_9} [inst : FunLike F G H] [inst_1 : AddGroup G]
  [inst_2 : SubtractionMonoid H] [inst_3 : AddMonoidHomClass F G H] (f : F) (a b : G), f (a - b) = f a - f b
Failed for Finset.finite_toSet : ∀ {α : Type u} (s : Finset α), (↑s).Finite
invalid coercion notation, expected type is not known

----
Succeeded for iSup_le : ∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {f : ι → α} {a : α}, (∀ (i : ι), f i ≤ a) → iSup f ≤ a
Succeeded for div_one : ∀ {G : Type u_3} [inst : DivInvOneMonoid G] (a : G), a / 1 = a
Succeeded for Set.range_comp : ∀ {α : Type u_1} {β : Type u_2} {ι : Sort u_4} (g : α → β) (f : ι → α), Set.range (g ∘ f) = g '' Set.range f
Succeeded for zero_pow : ∀ {M₀ : Type u_2} [inst : MonoidWithZero M₀] {n : ℕ}, n ≠ 0 → 0 ^ n = 0
Succeeded for and_congr : ∀ {a c b d : Prop}, (a ↔ c) → (b ↔ d) → (a ∧ b ↔ c ∧ d)
Failed for dite_cond_eq_false : ∀ {α : Sort u} {c : Prop} {x : Decidable c} {t : c → α} {e : ¬c → α} (h : c = False), dite c t e = e ⋯
don't know how to synthesize placeholder
context:
α : Sort u
c : Prop
x : Decidable c
t : c → α
e : ¬c → α
h : c = False
⊢ ¬c

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for RingHom.map_mul : ∀ {α : Type u_2} {β : Type u_3} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a b : α),
  f (a * b) = f a * f b
Succeeded for ne_of_lt : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≠ b
Succeeded for Mathlib.Data.Finset.Basic._auxLemma.143 : ∀ {a : Prop}, (¬¬a) = a
Succeeded for Mathlib.Order.SetNotation._auxLemma.3 : ∀ {α : Type u} {ι : Sort v} {x : α} {s : ι → Set α}, (x ∈ ⋃ i, s i) = ∃ i, x ∈ s i
Succeeded for zero_sub : ∀ {G : Type u_3} [inst : SubNegMonoid G] (a : G), 0 - a = -a
Succeeded for Function.comp_apply : ∀ {β : Sort u_1} {δ : Sort u_2} {α : Sort u_3} {f : β → δ} {g : α → β} {x : α}, (f ∘ g) x = f (g x)
Succeeded for LE.le.eq_or_lt : ∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → a = b ∨ a < b
Succeeded for Set.mem_iUnion : ∀ {α : Type u} {ι : Sort v} {x : α} {s : ι → Set α}, x ∈ ⋃ i, s i ↔ ∃ i, x ∈ s i
Succeeded for add_smul : ∀ {R : Type u_2} {M : Type u_5} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (r s : R) (x : M),
  (r + s) • x = r • x + s • x
Succeeded for mul_nonneg : ∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : PosMulMono α],
  0 ≤ a → 0 ≤ b → 0 ≤ a * b
Succeeded for Set.forall_range_iff : ∀ {α : Type u_1} {ι : Sort u_4} {f : ι → α} {p : α → Prop}, (∀ a ∈ Set.range f, p a) ↔ ∀ (i : ι), p (f i)
Succeeded for Set.Finite.subset : ∀ {α : Type u} {s : Set α}, s.Finite → ∀ {t : Set α}, t ⊆ s → t.Finite
Failed for Mathlib.Data.Finset.Basic._auxLemma.20 : ∀ {α : Type u_1} (a : α), (a ∈ ∅) = False
typeclass instance problem is stuck, it is often due to metavariables
  Membership α (?m.804 a)

----
Succeeded for eq_bot_iff : ∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderBot α] {a : α}, a = ⊥ ↔ a ≤ ⊥
Succeeded for le_iSup : ∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] (f : ι → α) (i : ι), f i ≤ iSup f
Succeeded for Finset.mem_filter : ∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] {s : Finset α} {a : α}, a ∈ Finset.filter p s ↔ a ∈ s ∧ p a
Failed for CategoryTheory.comp_apply : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.ConcreteCategory C] {X Y Z : C}
  (f : X ⟶ Y) (g : Y ⟶ Z) (x : (CategoryTheory.forget C).obj X), (CategoryTheory.CategoryStruct.comp f g) x = g (f x)
type expected, got
  (CategoryTheory.ConcreteCategory
  C : (FC : outParam (C → C → Type ?u.7)) →
  {CC : outParam (C → Type ?u.10)} →
    [outParam ((X Y : C) → FunLike (FC X Y) (CC X) (CC Y))] → Type (max (max u ?u.7) v))

----
Succeeded for pow_add : ∀ {M : Type u} [inst : Monoid M] (a : M) (m n : ℕ), a ^ (m + n) = a ^ m * a ^ n
Succeeded for map_pow : ∀ {G : Type u_7} {H : Type u_8} {F : Type u_9} [inst : FunLike F G H] [inst_1 : Monoid G] [inst_2 : Monoid H]
  [inst_3 : MonoidHomClass F G H] (f : F) (a : G) (n : ℕ), f (a ^ n) = f a ^ n
Succeeded for inf_comm : ∀ {α : Type u} [inst : SemilatticeInf α] (a b : α), a ⊓ b = b ⊓ a
Failed for Finset.sum_singleton : ∀ {α : Type u_3} {β : Type u_4} [inst : AddCommMonoid β] (f : α → β) (a : α), ({a}.sum fun x => f x) = f a
overloaded, errors 
  Invalid field notation: Type of
    {a}
  is not known; cannot resolve field `sum`
  
  invalid {...} notation, expected type is not known

----
Failed for pow_pos : ∀ {α : Type u} [inst : StrictOrderedSemiring α] {a : α}, 0 < a → ∀ (n : ℕ), 0 < a ^ n
invalid binder annotation, type is not a class instance
  StrictOrderedSemiring α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for Equiv.surjective : ∀ {α : Sort u} {β : Sort v} (e : α ≃ β), Function.Surjective ⇑e
Succeeded for Linarith.lt_irrefl : ∀ {α : Type u} [inst : Preorder α] {a : α}, ¬a < a
Succeeded for Quotient.inductionOn' : ∀ {α : Sort u_1} {s₁ : Setoid α} {p : Quotient s₁ → Prop} (q : Quotient s₁), (∀ (a : α), p (Quotient.mk'' a)) → p q
Failed for iSup_congr_Prop : ∀ {α : Type u_1} [inst : SupSet α] {p q : Prop} {f₁ : p → α} {f₂ : q → α} (pq : p ↔ q),
  (∀ (x : q), f₁ ⋯ = f₂ x) → iSup f₁ = iSup f₂
don't know how to synthesize placeholder
context:
α : Type u_1
inst : SupSet α
p q : Prop
f₁ : p → α
f₂ : q → α
pq : p ↔ q
x : q
⊢ p

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Failed for MeasureTheory.Measure.restrict_apply : ∀ {α : Type u_2} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s t : Set α},
  MeasurableSet t → ↑↑(μ.restrict s) t = ↑↑μ (t ∩ s)
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known

----
Succeeded for le_inf : ∀ {α : Type u} [inst : SemilatticeInf α] {a b c : α}, a ≤ b → a ≤ c → a ≤ b ⊓ c
Succeeded for Mathlib.Data.Set.Basic._auxLemma.25 : ∀ {α : Type u} (x : α) (a b : Set α), (x ∈ a ∩ b) = (x ∈ a ∧ x ∈ b)
Succeeded for interior_subset : ∀ {X : Type u} {s : Set X} [inst : TopologicalSpace X], interior s ⊆ s
Succeeded for List.append_assoc : ∀ {α : Type u} (as bs cs : List α), as ++ bs ++ cs = as ++ (bs ++ cs)
Succeeded for continuous_iff_continuousAt : ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X → Y},
  Continuous f ↔ ∀ (x : X), ContinuousAt f x
Succeeded for Classical.byContradiction : ∀ {p : Prop}, (¬p → False) → p
Succeeded for CategoryTheory.types_ext : ∀ {α β : Type u} (f g : α ⟶ β), (∀ (a : α), f a = g a) → f = g
Succeeded for sInf_le : ∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s : Set α} {a : α}, a ∈ s → sInf s ≤ a
Succeeded for Nat.mod_lt : ∀ (x : ℕ) {y : ℕ}, y > 0 → x % y < y
Succeeded for mul_le_mul_left' : ∀ {α : Type u_1} [inst : Mul α] [inst_1 : LE α]
  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {b c : α}, b ≤ c → ∀ (a : α), a * b ≤ a * c
Succeeded for Dvd.dvd.trans : ∀ {α : Type u_1} [inst : Semigroup α] {a b c : α}, a ∣ b → b ∣ c → a ∣ c
Succeeded for Mathlib.Data.Set.Basic._auxLemma.32 : ∀ {α : Type u} {s t : Set α}, (t = s ∩ t) = (t ⊆ s)
Succeeded for max_eq_right : ∀ {α : Type u} [inst : LinearOrder α] {a b : α}, a ≤ b → max a b = b
Succeeded for sub_neg_eq_add : ∀ {α : Type u_1} [inst : SubtractionMonoid α] (a b : α), a - -b = a + b
Succeeded for List.append_nil : ∀ {α : Type u} (as : List α), as ++ [] = as
Succeeded for pow_succ' : ∀ {M : Type u_2} [inst : Monoid M] (a : M) (n : ℕ), a ^ (n + 1) = a * a ^ n
Succeeded for Finset.induction_on : ∀ {α : Type u_4} {p : Finset α → Prop} [inst : DecidableEq α] (s : Finset α),
  p ∅ → (∀ ⦃a : α⦄ {s : Finset α}, a ∉ s → p s → p (insert a s)) → p s
Failed for MeasurableSet.univ : ∀ {α : Type u_1} {m : MeasurableSpace α}, MeasurableSet Set.univ
typeclass instance problem is stuck, it is often due to metavariables
  MeasurableSpace ?m.153

----
Succeeded for SetLike.mem_coe : ∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, x ∈ ↑p ↔ x ∈ p
Succeeded for lt_of_not_ge : ∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a ≥ b → a < b
Succeeded for Continuous.tendsto : ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X → Y},
  Continuous f → ∀ (x : X), Filter.Tendsto f (nhds x) (nhds (f x))
Succeeded for congr_arg₂ : ∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} (f : α → β → γ) {x x' : α} {y y' : β}, x = x' → y = y' → f x y = f x' y'
Failed for Finset.coe_injective : ∀ {α : Type u_4}, Function.Injective Finset.toSet
don't know how to synthesize implicit argument 'β'
  @Function.Injective (Finset ?m.15) (Set ?m.15) Finset.toSet
context:
α : Type u_4
⊢ Type ?u.9

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @Function.Injective (Finset ?m.15) (Set ?m.15) Finset.toSet
context:
α : Type u_4
⊢ Type ?u.9

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @Finset.toSet ?m.15
context:
α : Type u_4
⊢ Type ?u.9

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for mul_inv_cancel : ∀ {G₀ : Type u} [inst : GroupWithZero G₀] {a : G₀}, a ≠ 0 → a * a⁻¹ = 1
Failed for Quiver.Hom.op_inj : ∀ {C : Type u₁} [inst : Quiver C] {X Y : C}, Function.Injective Quiver.Hom.op
typeclass instance problem is stuck, it is often due to metavariables
  Quiver ?m.97

----
Failed for Mathlib.Data.Set.Basic._auxLemma.8 : ∀ {α : Type u} (x : α), (x ∈ ∅) = False
typeclass instance problem is stuck, it is often due to metavariables
  Membership α (?m.804 x)

----
Succeeded for Equiv.ext : ∀ {α : Sort u} {β : Sort v} {f g : α ≃ β}, (∀ (x : α), f x = g x) → f = g
Succeeded for Matrix.ext : ∀ {m : Type u_2} {n : Type u_3} {α : Type v} {M N : Matrix m n α}, (∀ (i : m) (j : n), M i j = N i j) → M = N
Succeeded for forall_swap : ∀ {α : Sort u_1} {β : Sort u_2} {p : α → β → Prop}, (∀ (x : α) (y : β), p x y) ↔ ∀ (y : β) (x : α), p x y
Succeeded for AddMonoidHom.map_zero : ∀ {M : Type u_4} {N : Type u_5} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (f : M →+ N), f 0 = 0
Succeeded for Ne.bot_lt : ∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderBot α] {a : α}, a ≠ ⊥ → ⊥ < a
Succeeded for RingHom.map_zero : ∀ {α : Type u_2} {β : Type u_3} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β), f 0 = 0
Succeeded for dvd_rfl : ∀ {α : Type u_1} [inst : Monoid α] {a : α}, a ∣ a
Succeeded for Finset.sum_const : ∀ {α : Type u_3} {β : Type u_4} {s : Finset α} [inst : AddCommMonoid β] (b : β), (s.sum fun _x => b) = s.card • b
Succeeded for Mathlib.Data.Set.Defs._auxLemma.5 : ∀ {α : Type u} {β : Type v} (f : α → β) (s : Set α) (y : β), (y ∈ f '' s) = ∃ x ∈ s, f x = y
Succeeded for Algebra.smul_def : ∀ {R : Type u} {A : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (r : R) (x : A),
  r • x = (algebraMap R A) r * x
Succeeded for Nat.zero_add : ∀ (n : ℕ), 0 + n = n
Succeeded for Mathlib.Data.Nat.Cast.Order._auxLemma.12 : ∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α]
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_3 : ZeroLEOneClass α]
  [inst_4 : CharZero α] {m n : ℕ}, (↑m ≤ ↑n) = (m ≤ n)
Succeeded for RingHom.map_one : ∀ {α : Type u_2} {β : Type u_3} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β), f 1 = 1
Succeeded for DifferentiableAt.hasFDerivAt : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}
  {x : E}, DifferentiableAt 𝕜 f x → HasFDerivAt f (fderiv 𝕜 f x) x
Succeeded for DFinsupp.ext : ∀ {ι : Type u} {β : ι → Type v} [inst : (i : ι) → Zero (β i)] {f g : Π₀ (i : ι), β i}, (∀ (i : ι), f i = g i) → f = g
Succeeded for add_left_neg : ∀ {G : Type u_1} [inst : AddGroup G] (a : G), -a + a = 0
Succeeded for Mathlib.Algebra.Order.ZeroLEOne._auxLemma.2 : ∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : PartialOrder α] [inst_3 : ZeroLEOneClass α]
  [inst_4 : NeZero 1], (0 < 1) = True
Succeeded for Function.update_same : ∀ {α : Sort u} {β : α → Sort v} [inst : DecidableEq α] (a : α) (v : β a) (f : (a : α) → β a),
  Function.update f a v a = v
Succeeded for List.prod_cons : ∀ {M : Type u_5} [inst : Monoid M] {l : List M} {a : M}, (a :: l).prod = a * l.prod
Failed for Set.iInter_congr_Prop : ∀ {α : Type u_1} {p q : Prop} {f₁ : p → Set α} {f₂ : q → Set α} (pq : p ↔ q),
  (∀ (x : q), f₁ ⋯ = f₂ x) → Set.iInter f₁ = Set.iInter f₂
don't know how to synthesize placeholder
context:
α : Type u_1
p q : Prop
f₁ : p → Set α
f₂ : q → Set α
pq : p ↔ q
x : q
⊢ p

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for mul_le_mul_of_nonneg_right : ∀ {α : Type u_1} {a b c : α} [inst : Mul α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : MulPosMono α],
  b ≤ c → 0 ≤ a → b * a ≤ c * a
Succeeded for Prod.mk.injEq : ∀ {α : Type u} {β : Type v} (fst : α) (snd : β) (fst_1 : α) (snd_1 : β),
  ((fst, snd) = (fst_1, snd_1)) = (fst = fst_1 ∧ snd = snd_1)
Succeeded for Nat.le_succ : ∀ (n : ℕ), n ≤ n.succ
Succeeded for Multiset.map_congr : ∀ {α : Type u_1} {β : Type v} {f g : α → β} {s t : Multiset α},
  s = t → (∀ x ∈ t, f x = g x) → Multiset.map f s = Multiset.map g t
Succeeded for neg_smul : ∀ {R : Type u_2} {M : Type u_5} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (r : R) (x : M),
  -r • x = -(r • x)
Succeeded for nsmul_eq_mul : ∀ {α : Type u_1} [inst : NonAssocSemiring α] (n : ℕ) (a : α), n • a = ↑n * a
Failed for measurable_snd : ∀ {α : Type u_1} {β : Type u_2} {x : MeasurableSpace α} {x_1 : MeasurableSpace β}, Measurable Prod.snd
typeclass instance problem is stuck, it is often due to metavariables
  MeasurableSpace ?m.322

----
Succeeded for neg_eq_zero : ∀ {α : Type u_1} [inst : SubtractionMonoid α] {a : α}, -a = 0 ↔ a = 0
Failed for tsub_eq_zero_of_le : ∀ {α : Type u_1} [inst : CanonicallyOrderedAddCommMonoid α] [inst_1 : Sub α] [inst_2 : OrderedSub α] {a b : α},
  a ≤ b → a - b = 0
invalid binder annotation, type is not a class instance
  CanonicallyOrderedAddCommMonoid α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Failed for Finset.coe_singleton : ∀ {α : Type u_1} (a : α), ↑{a} = {a}
typeclass instance problem is stuck, it is often due to metavariables
  Singleton α (?m.358 a)

----
Succeeded for Finset.coe_image : ∀ {α : Type u_1} {β : Type u_2} [inst : DecidableEq β] {f : α → β} {s : Finset α}, ↑(Finset.image f s) = f '' ↑s
Succeeded for ContinuousMap.continuous : ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (f : C(α, β)), Continuous ⇑f
Succeeded for tsub_zero : ∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : AddCommMonoid α] [inst_2 : Sub α] [inst : OrderedSub α] (a : α),
  a - 0 = a
Succeeded for CategoryTheory.Iso.hom_inv_id_assoc : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} (self : X ≅ Y) {Z : C} (h : X ⟶ Z),
  CategoryTheory.CategoryStruct.comp self.hom (CategoryTheory.CategoryStruct.comp self.inv h) = h
Succeeded for Function.update_noteq : ∀ {α : Sort u} {β : α → Sort v} [inst : DecidableEq α] {a a' : α},
  a ≠ a' → ∀ (v : β a') (f : (a : α) → β a), Function.update f a' v a = f a
Succeeded for HasSum.tsum_eq : ∀ {α : Type u_1} {β : Type u_2} [inst : AddCommMonoid α] [inst_1 : TopologicalSpace α] {f : β → α} {a : α}
  [inst_2 : T2Space α], HasSum f a → ∑' (b : β), f b = a
Succeeded for Option.some.injEq : ∀ {α : Type u} (val val_1 : α), (some val = some val_1) = (val = val_1)
Succeeded for HasDerivAt.deriv : ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {F : Type v} [inst_1 : NormedAddCommGroup F]
  [inst_2 : NormedSpace 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜}, HasDerivAt f f' x → deriv f x = f'
Succeeded for zero_nsmul : ∀ {M : Type u_2} [inst : AddMonoid M] (a : M), 0 • a = 0
Failed for zero_vadd : ∀ (M : Type u_1) {α : Type u_6} [inst : AddMonoid M] [inst_1 : AddAction M α] (b : α), 0 +ᵥ b = b
failed to synthesize
  HVAdd ℕ α ?m.35

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Succeeded for succ_nsmul : ∀ {M : Type u_2} [inst : AddMonoid M] (a : M) (n : ℕ), (n + 1) • a = n • a + a
Failed for List.TFAE.out : ∀ {l : List Prop},
  l.TFAE →
    ∀ (n₁ n₂ : ℕ) {a b : Prop}, autoParam (l.get? n₁ = some a) _auto✝ → autoParam (l.get? n₂ = some b) _auto✝¹ → (a ↔ b)
<input>:1:98: expected end of input
----
Succeeded for two_ne_zero : ∀ {α : Type u_2} [inst : Zero α] [inst_1 : OfNat α 2] [inst_2 : NeZero 2], 2 ≠ 0
Succeeded for Set.inter_univ : ∀ {α : Type u} (a : Set α), a ∩ Set.univ = a
Succeeded for Nat.cast_mul : ∀ {α : Type u_1} [inst : NonAssocSemiring α] (m n : ℕ), ↑(m * n) = ↑m * ↑n
Failed for Set.mem_singleton_iff : ∀ {α : Type u} {a b : α}, a ∈ {b} ↔ a = b
typeclass instance problem is stuck, it is often due to metavariables
  Singleton α ?m.356

----
Succeeded for Mathlib.Data.Prod.Basic._auxLemma.1 : ∀ {α : Type u_1} {β : Type u_2} {p : α × β → Prop}, (∀ (x : α × β), p x) = ∀ (a : α) (b : β), p (a, b)
Succeeded for mul_left_comm : ∀ {G : Type u_3} [inst : CommSemigroup G] (a b c : G), a * (b * c) = b * (a * c)
Succeeded for MeasurableSet.compl : ∀ {α : Type u_1} {s : Set α} {m : MeasurableSpace α}, MeasurableSet s → MeasurableSet sᶜ
Failed for neg_neg_of_pos : ∀ {α : Type u} [inst : OrderedAddCommGroup α] {a : α}, 0 < a → -a < 0
invalid binder annotation, type is not a class instance
  OrderedAddCommGroup α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Failed for Nat.cast_nonneg : ∀ {α : Type u_3} [inst : OrderedSemiring α] (n : ℕ), 0 ≤ ↑n
invalid binder annotation, type is not a class instance
  OrderedSemiring α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for Mathlib.Algebra.CharZero.Defs._auxLemma.2 : ∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] {m n : ℕ}, (↑m = ↑n) = (m = n)
Succeeded for Filter.inter_mem : ∀ {α : Type u} {f : Filter α} {s t : Set α}, s ∈ f → t ∈ f → s ∩ t ∈ f
Succeeded for Filter.tendsto_id : ∀ {α : Type u} {x : Filter α}, Filter.Tendsto id x x
Succeeded for DifferentiableWithinAt.hasFDerivWithinAt : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}
  {x : E} {s : Set E}, DifferentiableWithinAt 𝕜 f s x → HasFDerivWithinAt f (fderivWithin 𝕜 f s x) s x
Failed for continuous_subtype_val : ∀ {X : Type u} [inst : TopologicalSpace X] {p : X → Prop}, Continuous Subtype.val
typeclass instance problem is stuck, it is often due to metavariables
  TopologicalSpace ?m.1260

----
Succeeded for Multiset.induction_on : ∀ {α : Type u_1} {p : Multiset α → Prop} (s : Multiset α), p 0 → (∀ ⦃a : α⦄ {s : Multiset α}, p s → p (a ::ₘ s)) → p s
Succeeded for Fintype.card_fin : ∀ (n : ℕ), Fintype.card (Fin n) = n
Failed for LinearMap.map_smul : ∀ {R : Type u_1} {M : Type u_9} {M₂ : Type u_11} [inst : Semiring R] [inst_1 : AddCommMonoid M]
  [inst_2 : AddCommMonoid M₂] [inst_3 : Module R M] [inst_4 : Module R M₂] (fₗ : M →ₗ[R] M₂) (c : R) (x : M),
  fₗ (c • x) = c • fₗ x
unknown universe level 'u_11'

----
Succeeded for star_star : ∀ {R : Type u} [inst : InvolutiveStar R] (r : R), star (star r) = r
Succeeded for div_self : ∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {a : G₀}, a ≠ 0 → a / a = 1
Succeeded for Set.toFinite : ∀ {α : Type u} (s : Set α) [inst : Finite ↑s], s.Finite
Succeeded for Eq.subset : ∀ {α : Type u_1} {s t : Set α}, s = t → s ⊆ t
Succeeded for comm : ∀ {α : Type u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b ↔ r b a
Succeeded for inv_mul_cancel : ∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {a : G₀}, a ≠ 0 → a⁻¹ * a = 1
Succeeded for Continuous.add : ∀ {M : Type u_3} {X : Type u_5} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace M] [inst_2 : Add M]
  [inst_3 : ContinuousAdd M] {f g : X → M}, Continuous f → Continuous g → Continuous fun x => f x + g x
Succeeded for Real.exp_pos : ∀ (x : ℝ), 0 < x.exp
Succeeded for add_lt_of_neg_of_le : ∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]
  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b c : α},
  a < 0 → b ≤ c → a + b < c
Failed for measurable_fst : ∀ {α : Type u_1} {β : Type u_2} {x : MeasurableSpace α} {x_1 : MeasurableSpace β}, Measurable Prod.fst
typeclass instance problem is stuck, it is often due to metavariables
  MeasurableSpace ?m.320

----
Failed for measurable_id : ∀ {α : Type u_1} {x : MeasurableSpace α}, Measurable id
typeclass instance problem is stuck, it is often due to metavariables
  MeasurableSpace ?m.291

----
Succeeded for Filter.univ_mem : ∀ {α : Type u} {f : Filter α}, Set.univ ∈ f
Succeeded for forall₂_congr : ∀ {α : Sort u_1} {β : α → Sort u_2} {p q : (a : α) → β a → Prop},
  (∀ (a : α) (b : β a), p a b ↔ q a b) → ((∀ (a : α) (b : β a), p a b) ↔ ∀ (a : α) (b : β a), q a b)
Succeeded for lt_trichotomy : ∀ {α : Type u} [inst : LinearOrder α] (a b : α), a < b ∨ a = b ∨ b < a
Succeeded for le_of_not_gt : ∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a > b → a ≤ b
Succeeded for Continuous.mul : ∀ {M : Type u_3} {X : Type u_5} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace M] [inst_2 : Mul M]
  [inst_3 : ContinuousMul M] {f g : X → M}, Continuous f → Continuous g → Continuous fun x => f x * g x
Succeeded for Nat.eq_zero_or_pos : ∀ (n : ℕ), n = 0 ∨ n > 0
Succeeded for min_eq_left : ∀ {α : Type u} [inst : LinearOrder α] {a b : α}, a ≤ b → min a b = a
Succeeded for Finset.sum_insert : ∀ {α : Type u_3} {β : Type u_4} {s : Finset α} {a : α} {f : α → β} [inst : AddCommMonoid β] [inst_1 : DecidableEq α],
  a ∉ s → ((insert a s).sum fun x => f x) = f a + s.sum fun x => f x
Succeeded for lt_trans : ∀ {α : Type u} [inst : Preorder α] {a b c : α}, a < b → b < c → a < c
Succeeded for Nat.le_add_right : ∀ (n k : ℕ), n ≤ n + k
Succeeded for sub_nonneg : ∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]
  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, 0 ≤ a - b ↔ b ≤ a
Succeeded for CategoryTheory.Iso.ext : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} ⦃α β : X ≅ Y⦄, α.hom = β.hom → α = β
Succeeded for List.sum_cons : ∀ {M : Type u_5} [inst : AddMonoid M] {l : List M} {a : M}, (a :: l).sum = a + l.sum
Failed for Function.Injective.comp : ∀ {α : Sort u₁} {β : Sort u₂} {φ : Sort u₃} {g : β → φ} {f : α → β},
  Function.Injective g → Function.Injective f → Function.Injective (g ∘ f)
unexpected token 'φ'; expected '_' or identifier

----
Failed for CategoryTheory.Limits.pullback.condition : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z}
  [inst_1 : CategoryTheory.Limits.HasPullback f g],
  CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst f =
    CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd g
Application type mismatch: In the application
  CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd
the argument
  CategoryTheory.Limits.pullback.snd
has type
  (f : ?m.2809 ⟶ ?m.2811) →
    (g : ?m.2810 ⟶ ?m.2811) →
      [inst : CategoryTheory.Limits.HasPullback f g] → CategoryTheory.Limits.pullback f g ⟶ ?m.2810 : Type ?u.2806
but is expected to have type
  ?m.6647 ⟶ Y : Type v

----
Succeeded for Set.subset_union_left : ∀ {α : Type u} (s t : Set α), s ⊆ s ∪ t
Succeeded for AlgHom.ext : ∀ {R : Type u} {A : Type v} {B : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Semiring B]
  [inst_3 : Algebra R A] [inst_4 : Algebra R B] {φ₁ φ₂ : A →ₐ[R] B}, (∀ (x : A), φ₁ x = φ₂ x) → φ₁ = φ₂
Succeeded for CategoryTheory.IsIso.hom_inv_id : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} (f : X ⟶ Y) [I : CategoryTheory.IsIso f],
  CategoryTheory.CategoryStruct.comp f (CategoryTheory.inv f) = CategoryTheory.CategoryStruct.id X
Failed for MulOpposite.unop_injective : ∀ {α : Type u_1}, Function.Injective MulOpposite.unop
don't know how to synthesize implicit argument 'β'
  @Function.Injective ?m.14ᵐᵒᵖ ?m.14 MulOpposite.unop
context:
α : Type u_1
⊢ Type ?u.9

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @Function.Injective ?m.14ᵐᵒᵖ ?m.14 MulOpposite.unop
context:
α : Type u_1
⊢ Type ?u.9

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @MulOpposite.unop ?m.14
context:
α : Type u_1
⊢ Type ?u.9

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for Filter.Tendsto.eventually : ∀ {α : Type u} {β : Type v} {f : α → β} {l₁ : Filter α} {l₂ : Filter β} {p : β → Prop},
  Filter.Tendsto f l₁ l₂ → (∀ᶠ (y : β) in l₂, p y) → ∀ᶠ (x : α) in l₁, p (f x)
Succeeded for zpow_neg : ∀ {α : Type u_1} [inst : DivisionMonoid α] (a : α) (n : ℤ), a ^ (-n) = (a ^ n)⁻¹
Succeeded for MonoidHom.map_mul : ∀ {M : Type u_4} {N : Type u_5} [inst : MulOneClass M] [inst_1 : MulOneClass N] (f : M →* N) (a b : M),
  f (a * b) = f a * f b
Succeeded for coe_nat_zsmul : ∀ {G : Type u_1} [inst : SubNegMonoid G] (a : G) (n : ℕ), ↑n • a = n • a
Succeeded for min_eq_right : ∀ {α : Type u} [inst : LinearOrder α] {a b : α}, b ≤ a → min a b = b
Succeeded for le_of_not_lt : ∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬b < a → a ≤ b
Succeeded for Nat.mod_eq_of_lt : ∀ {a b : ℕ}, a < b → a % b = a
Succeeded for Function.LeftInverse.injective : ∀ {α : Sort u₁} {β : Sort u₂} {g : β → α} {f : α → β}, Function.LeftInverse g f → Function.Injective f
Succeeded for Submodule.ext : ∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {p q : Submodule R M},
  (∀ (x : M), x ∈ p ↔ x ∈ q) → p = q
Succeeded for Mathlib.Order.BoundedOrder._auxLemma.1 : ∀ {α : Type u} [inst : LE α] [inst_1 : OrderTop α] {a : α}, (a ≤ ⊤) = True
Succeeded for Finset.coe_subset : ∀ {α : Type u_1} {s₁ s₂ : Finset α}, ↑s₁ ⊆ ↑s₂ ↔ s₁ ⊆ s₂
Succeeded for neg_add_cancel_right : ∀ {G : Type u_1} [inst : AddGroup G] (a b : G), a + -b + b = a
Succeeded for Submodule.subset_span : ∀ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {s : Set M},
  s ⊆ ↑(Submodule.span R s)
Succeeded for add_right_neg : ∀ {G : Type u_1} [inst : AddGroup G] (a : G), a + -a = 0
Succeeded for eq_of_forall_ge_iff : ∀ {α : Type u} [inst : PartialOrder α] {a b : α}, (∀ (c : α), a ≤ c ↔ b ≤ c) → a = b
Succeeded for Polynomial.ext : ∀ {R : Type u} [inst : Semiring R] {p q : Polynomial R}, (∀ (n : ℕ), p.coeff n = q.coeff n) → p = q
Succeeded for Set.image_singleton : ∀ {α : Type u_1} {β : Type u_2} {f : α → β} {a : α}, f '' {a} = {f a}
Succeeded for List.map_map : ∀ {β : Type u_1} {γ : Type u_2} {α : Type u_3} (g : β → γ) (f : α → β) (l : List α),
  List.map g (List.map f l) = List.map (g ∘ f) l
Succeeded for Nat.mul_comm : ∀ (n m : ℕ), n * m = m * n
Succeeded for isEmpty_or_nonempty : ∀ (α : Sort u_1), IsEmpty α ∨ Nonempty α
Succeeded for RingHom.injective : ∀ {α : Type u_1} {β : Type u_2} [inst : DivisionRing α] [inst_1 : Semiring β] [inst_2 : Nontrivial β] (f : α →+* β),
  Function.Injective ⇑f
Succeeded for Nat.succ_le_of_lt : ∀ {n m : ℕ}, n < m → n.succ ≤ m
Succeeded for CategoryTheory.IsIso.inv_hom_id : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} (f : X ⟶ Y) [I : CategoryTheory.IsIso f],
  CategoryTheory.CategoryStruct.comp (CategoryTheory.inv f) f = CategoryTheory.CategoryStruct.id Y
Succeeded for smul_smul : ∀ {M : Type u_1} {α : Type u_6} [inst : Monoid M] [inst_1 : MulAction M α] (a₁ a₂ : M) (b : α),
  a₁ • a₂ • b = (a₁ * a₂) • b
Succeeded for Int.cast_zero : ∀ {R : Type u} [inst : AddGroupWithOne R], ↑0 = 0
Failed for TopologicalSpace.Opens.openEmbedding : ∀ {X : TopCat} (U : TopologicalSpace.Opens ↑X), OpenEmbedding ⇑U.inclusion
Function expected at
  OpenEmbedding
but this term has type
  ?m.211

Note: Expected a function because this term is being applied to the argument
  ⇑U.inclusion

----
Succeeded for sub_nonpos_of_le : ∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]
  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, a ≤ b → a - b ≤ 0
Succeeded for Cardinal.lift_id : ∀ (a : Cardinal.{u}), Cardinal.lift.{u, u} a = a
Succeeded for LE.le.lt_of_ne : ∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → a ≠ b → a < b
Succeeded for Mathlib.Algebra.NeZero._auxLemma.3 : ∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : NeZero 1], (0 = 1) = False
Succeeded for mul_right_inv : ∀ {G : Type u_1} [inst : Group G] (a : G), a * a⁻¹ = 1
Failed for Subtype.range_coe : ∀ {α : Type u_1} {s : Set α}, Set.range Subtype.val = s
don't know how to synthesize implicit argument 'ι'
  @Set.range α (Subtype ?m.53) Subtype.val
context:
α : Type u_1
s : Set α
⊢ Type (max 0 u_1)

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'p'
  @Subtype.val α ?m.53
context:
α : Type u_1
s : Set α
⊢ α → Prop

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for Multiset.map_map : ∀ {α : Type u_1} {β : Type v} {γ : Type u_2} (g : β → γ) (f : α → β) (s : Multiset α),
  Multiset.map g (Multiset.map f s) = Multiset.map (g ∘ f) s
Succeeded for lt_or_le : ∀ {α : Type u} [inst : LinearOrder α] (a b : α), a < b ∨ b ≤ a
Succeeded for MeasurableSet.inter : ∀ {α : Type u_1} {m : MeasurableSpace α} {s₁ s₂ : Set α}, MeasurableSet s₁ → MeasurableSet s₂ → MeasurableSet (s₁ ∩ s₂)
Failed for Nat.cast_pos : ∀ {α : Type u_3} [inst : OrderedSemiring α] [inst_1 : Nontrivial α] {n : ℕ}, 0 < ↑n ↔ 0 < n
invalid binder annotation, type is not a class instance
  OrderedSemiring α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Failed for Finset.mem_singleton : ∀ {α : Type u_1} {a b : α}, b ∈ {a} ↔ b = a
typeclass instance problem is stuck, it is often due to metavariables
  Singleton α ?m.356

----
Succeeded for dvd_refl : ∀ {α : Type u_1} [inst : Monoid α] (a : α), a ∣ a
Failed for norm_smul : ∀ {α : Type u_1} {β : Type u_2} [inst : NormedDivisionRing α] [inst_1 : SeminormedAddGroup β]
  [inst_2 : MulActionWithZero α β] [inst_3 : BoundedSMul α β] (r : α) (x : β), ‖r • x‖ = ‖r‖ * ‖x‖
invalid binder annotation, type is not a class instance
  BoundedSMul α β

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for Nat.le_refl : ∀ (n : ℕ), n ≤ n
Succeeded for pow_mul : ∀ {M : Type u} [inst : Monoid M] (a : M) (m n : ℕ), a ^ (m * n) = (a ^ m) ^ n
Succeeded for isOpen_interior : ∀ {X : Type u} {s : Set X} [inst : TopologicalSpace X], IsOpen (interior s)
Succeeded for SetLike.ext : ∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p q : A}, (∀ (x : B), x ∈ p ↔ x ∈ q) → p = q
Succeeded for Measurable.comp_aemeasurable : ∀ {α : Type u_1} {β : Type u_2} {δ : Type u_4} {m : MeasurableSpace α} [inst : MeasurableSpace β]
  {μ : MeasureTheory.Measure α} [inst_1 : MeasurableSpace δ] {f : α → δ} {g : δ → β},
  Measurable g → AEMeasurable f μ → AEMeasurable (g ∘ f) μ
Failed for ENNReal.coe_ne_top : ∀ {r : NNReal}, ↑r ≠ ⊤
failed to synthesize
  Top NNReal

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Succeeded for self_mem_nhdsWithin : ∀ {α : Type u_1} [inst : TopologicalSpace α] {a : α} {s : Set α}, s ∈ nhdsWithin a s
Succeeded for add_left_comm : ∀ {G : Type u_3} [inst : AddCommSemigroup G] (a b c : G), a + (b + c) = b + (a + c)
Succeeded for top_unique : ∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderTop α] {a : α}, ⊤ ≤ a → a = ⊤
Succeeded for zero_lt_two : ∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [inst_2 : ZeroLEOneClass α] [inst_3 : NeZero 1]
  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], 0 < 2
Succeeded for DifferentiableAt.hasDerivAt : ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {F : Type v} [inst_1 : NormedAddCommGroup F]
  [inst_2 : NormedSpace 𝕜 F] {f : 𝕜 → F} {x : 𝕜}, DifferentiableAt 𝕜 f x → HasDerivAt f (deriv f x) x
Succeeded for abs_nonneg : ∀ {α : Type u_1} [inst : Lattice α] [inst_1 : AddGroup α]
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]
  [inst_3 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] (a : α), 0 ≤ |a|
Succeeded for isClosed_eq : ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : T2Space X]
  {f g : Y → X}, Continuous f → Continuous g → IsClosed {y | f y = g y}
Failed for CategoryTheory.Functor.map_zero : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] [inst_3 : CategoryTheory.Limits.HasZeroMorphisms D]
  (F : CategoryTheory.Functor C D) [inst_4 : F.PreservesZeroMorphisms] (X Y : C), F.map 0 = 0
don't know how to synthesize implicit argument 'α'
  @Eq (F.obj (?m.288 F X Y) ⟶ F.obj (?m.289 F X Y)) (F.map 0) 0
context:
C : Type u₁
inst : CategoryTheory.Category.{v₁, u₁} C
D : Type u₂
inst_1 : CategoryTheory.Category.{v₂, u₂} D
inst_2 : CategoryTheory.Limits.HasZeroMorphisms C
inst_3 : CategoryTheory.Limits.HasZeroMorphisms D
F : CategoryTheory.Functor C D
inst_4 : F.PreservesZeroMorphisms
X Y : C
⊢ Type v₂

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument
  @OfNat.ofNat (F.obj (?m.288 F X Y) ⟶ F.obj (?m.289 F X Y)) 0 Zero.toOfNat0
context:
C : Type u₁
inst : CategoryTheory.Category.{v₁, u₁} C
D : Type u₂
inst_1 : CategoryTheory.Category.{v₂, u₂} D
inst_2 : CategoryTheory.Limits.HasZeroMorphisms C
inst_3 : CategoryTheory.Limits.HasZeroMorphisms D
F : CategoryTheory.Functor C D
inst_4 : F.PreservesZeroMorphisms
X Y : C
⊢ OfNat (F.obj (?m.288 F X Y) ⟶ F.obj (?m.289 F X Y)) 0

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'Y'
  @CategoryTheory.Functor.map C inst D inst_1 F (?m.288 F X Y) (?m.289 F X Y) 0
context:
C : Type u₁
inst : CategoryTheory.Category.{v₁, u₁} C
D : Type u₂
inst_1 : CategoryTheory.Category.{v₂, u₂} D
inst_2 : CategoryTheory.Limits.HasZeroMorphisms C
inst_3 : CategoryTheory.Limits.HasZeroMorphisms D
F : CategoryTheory.Functor C D
inst_4 : F.PreservesZeroMorphisms
X Y : C
⊢ C

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'X'
  @CategoryTheory.Functor.map C inst D inst_1 F (?m.288 F X Y) (?m.289 F X Y) 0
context:
C : Type u₁
inst : CategoryTheory.Category.{v₁, u₁} C
D : Type u₂
inst_1 : CategoryTheory.Category.{v₂, u₂} D
inst_2 : CategoryTheory.Limits.HasZeroMorphisms C
inst_3 : CategoryTheory.Limits.HasZeroMorphisms D
F : CategoryTheory.Functor C D
inst_4 : F.PreservesZeroMorphisms
X Y : C
⊢ C

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument
  @OfNat.ofNat (?m.288 F X Y ⟶ ?m.289 F X Y) 0 Zero.toOfNat0
context:
C : Type u₁
inst : CategoryTheory.Category.{v₁, u₁} C
D : Type u₂
inst_1 : CategoryTheory.Category.{v₂, u₂} D
inst_2 : CategoryTheory.Limits.HasZeroMorphisms C
inst_3 : CategoryTheory.Limits.HasZeroMorphisms D
F : CategoryTheory.Functor C D
inst_4 : F.PreservesZeroMorphisms
X Y : C
⊢ OfNat (?m.288 F X Y ⟶ ?m.289 F X Y) 0

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for GaloisConnection.l_sup : ∀ {α : Type u} {β : Type v} {a₁ a₂ : α} [inst : SemilatticeSup α] [inst_1 : SemilatticeSup β] {l : α → β} {u : β → α},
  GaloisConnection l u → l (a₁ ⊔ a₂) = l a₁ ⊔ l a₂
Succeeded for div_eq_inv_mul : ∀ {α : Type u_1} [inst : DivisionCommMonoid α] (a b : α), a / b = b⁻¹ * a
Succeeded for add_tsub_cancel_of_le : ∀ {α : Type u_1} [inst : AddCommSemigroup α] [inst_1 : PartialOrder α] [inst_2 : ExistsAddOfLE α]
  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_4 : Sub α] [inst_5 : OrderedSub α]
  {a b : α}, a ≤ b → a + (b - a) = b
Succeeded for add_sub_cancel' : ∀ {G : Type u_3} [inst : AddCommGroup G] (a b : G), a + b - a = b
Succeeded for lt_iff_lt_of_le_iff_le : ∀ {α : Type u} {β : Type u_3} [inst : LinearOrder α] [inst_1 : LinearOrder β] {a b : α} {c d : β},
  (a ≤ b ↔ c ≤ d) → (b < a ↔ d < c)
Failed for measurable_const : ∀ {α : Type u_1} {β : Type u_2} {x : MeasurableSpace α} {x_1 : MeasurableSpace β} {a : α}, Measurable fun x => a
typeclass instance problem is stuck, it is often due to metavariables
  MeasurableSpace ?m.216

----
Succeeded for add_sub_cancel'_right : ∀ {G : Type u_3} [inst : AddCommGroup G] (a b : G), a + (b - a) = b
Succeeded for NNReal.coe_nonneg : ∀ (r : NNReal), 0 ≤ ↑r
Succeeded for dist_eq_norm : ∀ {E : Type u_6} [inst : SeminormedAddGroup E] (a b : E), dist a b = ‖a - b‖
Succeeded for DFunLike.ext' : ∀ {F : Sort u_1} {α : Sort u_2} {β : α → Sort u_3} [i : DFunLike F α β] {f g : F}, ⇑f = ⇑g → f = g
Succeeded for mul_ne_zero : ∀ {M₀ : Type u_2} [inst : Mul M₀] [inst_1 : Zero M₀] [inst_2 : NoZeroDivisors M₀] {a b : M₀}, a ≠ 0 → b ≠ 0 → a * b ≠ 0
Failed for Finset.coe_univ : ∀ {α : Type u_1} [inst : Fintype α], ↑Finset.univ = Set.univ
type mismatch
  Finset.univ
has type
  Finset ?m.17 : Type ?u.12
but is expected to have type
  Set ?m.781 : Type ?u.12

----
Succeeded for IsClosed.closure_eq : ∀ {X : Type u} {s : Set X} [inst : TopologicalSpace X], IsClosed s → closure s = s
Succeeded for le_iInf : ∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {f : ι → α} {a : α}, (∀ (i : ι), a ≤ f i) → a ≤ iInf f
Failed for ContDiff.contDiffAt : ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}
  {x : E} {n : ℕ∞}, ContDiff 𝕜 n f → ContDiffAt 𝕜 n f x
unknown universe level 'uE'
unknown universe level 'uF'

----
Succeeded for MonoidHom.map_one : ∀ {M : Type u_4} {N : Type u_5} [inst : MulOneClass M] [inst_1 : MulOneClass N] (f : M →* N), f 1 = 1
Succeeded for Or.imp_right : ∀ {b c a : Prop}, (b → c) → a ∨ b → a ∨ c
Succeeded for HomologicalComplex.hom_ext : ∀ {ι : Type u_1} {V : Type u} [inst : CategoryTheory.Category.{v, u} V]
  [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] {c : ComplexShape ι} {C D : HomologicalComplex V c} (f g : C ⟶ D),
  (∀ (i : ι), f.f i = g.f i) → f = g
Succeeded for Nat.card_eq_fintype_card : ∀ {α : Type u_1} [inst : Fintype α], Nat.card α = Fintype.card α
Succeeded for Fintype.card_congr : ∀ {α : Type u_4} {β : Type u_5} [inst : Fintype α] [inst_1 : Fintype β], α ≃ β → Fintype.card α = Fintype.card β
Succeeded for map_natCast : ∀ {R : Type u_3} {S : Type u_4} {F : Type u_5} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S]
  [inst_2 : FunLike F R S] [inst_3 : RingHomClass F R S] (f : F) (n : ℕ), f ↑n = ↑n
Succeeded for Function.Embedding.injective : ∀ {α : Sort u_1} {β : Sort u_2} (f : α ↪ β), Function.Injective ⇑f
Succeeded for Set.subset_union_right : ∀ {α : Type u} (s t : Set α), t ⊆ s ∪ t
Failed for div_pos : ∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {a b : α}, 0 < a → 0 < b → 0 < a / b
invalid binder annotation, type is not a class instance
  LinearOrderedSemifield α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Failed for GaloisConnection.l_iSup : ∀ {α : Type u} {β : Type v} {ι : Sort x} [inst : CompleteLattice α] [inst_1 : CompleteLattice β] {l : α → β}
  {u : β → α}, GaloisConnection l u → ∀ {f : ι → α}, l (iSup f) = ⨆ i, l (f i)
unknown universe level 'x'

----
Succeeded for Nat.le_of_dvd : ∀ {m n : ℕ}, 0 < n → m ∣ n → m ≤ n
Succeeded for Set.image_image : ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (g : β → γ) (f : α → β) (s : Set α),
  g '' (f '' s) = (fun x => g (f x)) '' s
Succeeded for Mathlib.Data.Nat.Cast.Order._auxLemma.13 : ∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α]
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_3 : ZeroLEOneClass α]
  [inst_4 : CharZero α] {m n : ℕ}, (↑m < ↑n) = (m < n)
Succeeded for Finset.le_sup : ∀ {α : Type u_2} {β : Type u_3} [inst : SemilatticeSup α] [inst_1 : OrderBot α] {s : Finset β} {f : β → α} {b : β},
  b ∈ s → f b ≤ s.sup f
Failed for nonpos_iff_eq_zero : ∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] {a : α}, a ≤ 0 ↔ a = 0
invalid binder annotation, type is not a class instance
  CanonicallyOrderedAddCommMonoid α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for Fin.ext : ∀ {n : ℕ} {a b : Fin n}, ↑a = ↑b → a = b
Succeeded for norm_neg : ∀ {E : Type u_6} [inst : SeminormedAddGroup E] (a : E), ‖-a‖ = ‖a‖
Succeeded for Mathlib.Algebra.CharZero.Defs._auxLemma.7 : ∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] (n : ℕ) [inst_2 : n.AtLeastTwo],
  (OfNat.ofNat n = 0) = False
Succeeded for Equiv.bijective : ∀ {α : Sort u} {β : Sort v} (e : α ≃ β), Function.Bijective ⇑e
Failed for Subtype.val_injective : ∀ {α : Sort u_1} {p : α → Prop}, Function.Injective Subtype.val
don't know how to synthesize implicit argument 'β'
  @Function.Injective (Subtype ?m.20) ?m.19 Subtype.val
context:
α : Sort u_1
p : α → Prop
⊢ Sort ?u.13

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @Function.Injective (Subtype ?m.20) ?m.19 Subtype.val
context:
α : Sort u_1
p : α → Prop
⊢ Sort (max 1 ?u.13)

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'p'
  @Subtype.val ?m.19 ?m.20
context:
α : Sort u_1
p : α → Prop
⊢ ?m.19 → Prop

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @Subtype.val ?m.19 ?m.20
context:
α : Sort u_1
p : α → Prop
⊢ Sort ?u.13

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for Set.nonempty_iff_ne_empty : ∀ {α : Type u} {s : Set α}, s.Nonempty ↔ s ≠ ∅
Succeeded for zpow_negSucc : ∀ {G : Type u_1} [inst : DivInvMonoid G] (a : G) (n : ℕ), a ^ Int.negSucc n = (a ^ (n + 1))⁻¹
Succeeded for Mathlib.Data.Subtype._auxLemma.1 : ∀ {α : Sort u_1} {p : α → Prop} {q : { a // p a } → Prop}, (∀ (x : { a // p a }), q x) = ∀ (a : α) (b : p a), q ⟨a, b⟩
Succeeded for add_tsub_cancel_right : ∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : AddCommSemigroup α] [inst_2 : Sub α] [inst_3 : OrderedSub α]
  [inst : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] (a b : α), a + b - b = a
Failed for LinearMap.map_add : ∀ {R : Type u_1} {S : Type u_6} {M : Type u_9} {M₃ : Type u_12} [inst : Semiring R] [inst_1 : Semiring S]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₃] [inst_4 : Module R M] [inst_5 : Module S M₃] {σ : R →+* S}
  (f : M →ₛₗ[σ] M₃) (x y : M), f (x + y) = f x + f y
unknown universe level 'u_12'

----
Succeeded for CategoryTheory.MonoidalCategory.tensorHom_id : ∀ {C : Type u} [𝒞 : CategoryTheory.Category.{v, u} C] [inst : CategoryTheory.MonoidalCategory C] {X₁ X₂ : C}
  (f : X₁ ⟶ X₂) (Y : C),
  CategoryTheory.MonoidalCategory.tensorHom f (CategoryTheory.CategoryStruct.id Y) =
    CategoryTheory.MonoidalCategory.whiskerRight f Y
Succeeded for dist_nonneg : ∀ {α : Type u} [inst : PseudoMetricSpace α] {x y : α}, 0 ≤ dist x y
Succeeded for add_sub_cancel : ∀ {G : Type u_3} [inst : AddCommGroup G] (a b : G), a + (b - a) = b
Succeeded for Nat.cast_le : ∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α]
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_3 : ZeroLEOneClass α]
  [inst_4 : CharZero α] {m n : ℕ}, ↑m ≤ ↑n ↔ m ≤ n
Succeeded for Set.Subset.refl : ∀ {α : Type u} (a : Set α), a ⊆ a
Succeeded for Mathlib.Data.Finset.Basic._auxLemma.64 : ∀ {α : Type u_1} [inst : DecidableEq α] {s : Finset α} {a b : α}, (a ∈ insert b s) = (a = b ∨ a ∈ s)
Succeeded for Set.eq_univ_of_forall : ∀ {α : Type u} {s : Set α}, (∀ (x : α), x ∈ s) → s = Set.univ
Succeeded for IsOpen.preimage : ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X → Y},
  Continuous f → ∀ {t : Set Y}, IsOpen t → IsOpen (f ⁻¹' t)
Succeeded for Nat.lt_of_lt_of_le : ∀ {n m k : ℕ}, n < m → m ≤ k → n < k
Succeeded for zero_div : ∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] (a : G₀), 0 / a = 0
Succeeded for Int.add_comm : ∀ (a b : ℤ), a + b = b + a
Succeeded for Prod.mk.eta : ∀ {α : Type u_1} {β : Type u_2} {p : α × β}, (p.1, p.2) = p
Succeeded for Units.mul_inv : ∀ {α : Type u} [inst : Monoid α] (a : αˣ), ↑a * ↑a⁻¹ = 1
Succeeded for Nat.mod_add_div : ∀ (m k : ℕ), m % k + k * (m / k) = m
Succeeded for MeasurableSet.nullMeasurableSet : ∀ {α : Type u_2} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : Set α},
  MeasurableSet s → MeasureTheory.NullMeasurableSet s μ
Succeeded for Function.Injective.eq_iff' : ∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.Injective f → ∀ {a b : α} {c : β}, f b = c → (f a = c ↔ a = b)
Succeeded for Filter.Eventually.mp : ∀ {α : Type u} {p q : α → Prop} {f : Filter α},
  (∀ᶠ (x : α) in f, p x) → (∀ᶠ (x : α) in f, p x → q x) → ∀ᶠ (x : α) in f, q x
Succeeded for Equiv.symm_symm : ∀ {α : Sort u} {β : Sort v} (e : α ≃ β), e.symm.symm = e
Succeeded for mul_sub : ∀ {α : Type u} [inst : NonUnitalNonAssocRing α] (a b c : α), a * (b - c) = a * b - a * c
Succeeded for pow_two : ∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 2 = a * a
Succeeded for Set.indicator_of_mem : ∀ {α : Type u_1} {M : Type u_4} [inst : Zero M] {s : Set α} {a : α}, a ∈ s → ∀ (f : α → M), s.indicator f a = f a
Succeeded for iInf_le : ∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] (f : ι → α) (i : ι), iInf f ≤ f i
Succeeded for Nat.lt_succ_iff : ∀ {m n : ℕ}, m < n.succ ↔ m ≤ n
Succeeded for Filter.HasBasis.comap : ∀ {α : Type u_1} {β : Type u_2} {ι : Sort u_4} {l : Filter α} {p : ι → Prop} {s : ι → Set α} (f : β → α),
  l.HasBasis p s → (Filter.comap f l).HasBasis p fun i => f ⁻¹' s i
Succeeded for Set.mem_preimage : ∀ {α : Type u} {β : Type v} {f : α → β} {s : Set β} {a : α}, a ∈ f ⁻¹' s ↔ f a ∈ s
Failed for MeasureTheory.measure_ne_top : ∀ {α : Type u_1} {m0 : MeasurableSpace α} (μ : MeasureTheory.Measure α) [inst : MeasureTheory.IsFiniteMeasure μ]
  (s : Set α), ↑↑μ s ≠ ⊤
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known

----
Succeeded for smul_neg : ∀ {M : Type u_1} {A : Type u_4} [inst : Monoid M] [inst_1 : AddGroup A] [inst_2 : DistribMulAction M A] (r : M) (x : A),
  r • -x = -(r • x)
Succeeded for IsOpen.inter : ∀ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsOpen s → IsOpen t → IsOpen (s ∩ t)
Succeeded for Exists.elim : ∀ {α : Sort u} {p : α → Prop} {b : Prop}, (∃ x, p x) → (∀ (a : α), p a → b) → b
Succeeded for Int.cast_add : ∀ {R : Type u} [inst : AddGroupWithOne R] (m n : ℤ), ↑(m + n) = ↑m + ↑n
Succeeded for Function.Injective.ne : ∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.Injective f → ∀ {a₁ a₂ : α}, a₁ ≠ a₂ → f a₁ ≠ f a₂
Succeeded for add_nonneg : ∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, 0 ≤ a → 0 ≤ b → 0 ≤ a + b
Succeeded for and_iff_right : ∀ {a b : Prop}, a → (a ∧ b ↔ b)
Succeeded for Nat.Prime.one_lt : ∀ {p : ℕ}, p.Prime → 1 < p
Succeeded for Set.ext_iff : ∀ {α : Type u} {s t : Set α}, s = t ↔ ∀ (x : α), x ∈ s ↔ x ∈ t
Succeeded for zero_ne_one : ∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : NeZero 1], 0 ≠ 1
Succeeded for Primrec.comp : ∀ {α : Type u_1} {β : Type u_2} {σ : Type u_3} [inst : Primcodable α] [inst_1 : Primcodable β] [inst_2 : Primcodable σ]
  {f : β → σ} {g : α → β}, Primrec f → Primrec g → Primrec fun a => f (g a)
Succeeded for Homeomorph.continuous : ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (h : X ≃ₜ Y), Continuous ⇑h
Failed for MeasureTheory.Measure.map_apply : ∀ {α : Type u_1} {β : Type u_2} {m0 : MeasurableSpace α} [inst : MeasurableSpace β] {μ : MeasureTheory.Measure α}
  {f : α → β}, Measurable f → ∀ {s : Set β}, MeasurableSet s → ↑↑(MeasureTheory.Measure.map f μ) s = ↑↑μ (f ⁻¹' s)
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known

----
Succeeded for le_abs_self : ∀ {α : Type u_1} [inst : Lattice α] [inst_1 : AddGroup α] (a : α), a ≤ |a|
Succeeded for Real.pi_pos : 0 < Real.pi
Succeeded for Set.Finite.coe_toFinset : ∀ {α : Type u} {s : Set α} (hs : s.Finite), ↑hs.toFinset = s
Failed for Quotient.inductionOn₂ : ∀ {α : Sort uA} {β : Sort uB} {s₁ : Setoid α} {s₂ : Setoid β} {motive : Quotient s₁ → Quotient s₂ → Prop}
  (q₁ : Quotient s₁) (q₂ : Quotient s₂), (∀ (a : α) (b : β), motive ⟦a⟧ ⟦b⟧) → motive q₁ q₂
unknown universe level 'uA'
unknown universe level 'uB'

----
Failed for Continuous.subtype_mk : ∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {p : X → Prop} {f : Y → X},
  Continuous f → ∀ (hp : ∀ (x : Y), p (f x)), Continuous fun x => ⟨f x, ⋯⟩
invalid constructor ⟨...⟩, expected type must be an inductive type 
  ?m.1692 hp

----
Succeeded for map_prod : ∀ {α : Type u_3} {β : Type u_4} {γ : Type u_5} [inst : CommMonoid β] [inst_1 : CommMonoid γ] {G : Type u_6}
  [inst_2 : FunLike G β γ] [inst_3 : MonoidHomClass G β γ] (g : G) (f : α → β) (s : Finset α),
  g (s.prod fun x => f x) = s.prod fun x => g (f x)
Succeeded for and_iff_left : ∀ {b a : Prop}, b → (a ∧ b ↔ a)
Succeeded for Algebra.algebraMap_eq_smul_one : ∀ {R : Type u} {A : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (r : R),
  (algebraMap R A) r = r • 1
Succeeded for IsCompact.image : ∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {s : Set X} {f : X → Y},
  IsCompact s → Continuous f → IsCompact (f '' s)
Succeeded for Measurable.prod_mk : ∀ {α : Type u_1} {m : MeasurableSpace α} {β : Type u_6} {γ : Type u_7} {x : MeasurableSpace β} {x_1 : MeasurableSpace γ}
  {f : α → β} {g : α → γ}, Measurable f → Measurable g → Measurable fun a => (f a, g a)
Succeeded for inv_mul_cancel_right : ∀ {G : Type u_1} [inst : Group G] (a b : G), a * b⁻¹ * b = a
Succeeded for Set.image_comp : ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : β → γ) (g : α → β) (a : Set α), f ∘ g '' a = f '' (g '' a)
Succeeded for List.mem_cons_self : ∀ {α : Type u_1} (a : α) (l : List α), a ∈ a :: l
Succeeded for Finset.mem_insert_self : ∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (s : Finset α), a ∈ insert a s
Succeeded for Mathlib.Data.Finset.Basic._auxLemma.6 : ∀ {α : Type u_1} {a : α} {s : Finset α}, (a ∈ ↑s) = (a ∈ s)
Succeeded for subset_refl : ∀ {α : Type u} [inst : HasSubset α] [inst_1 : IsRefl α fun x x_1 => x ⊆ x_1] (a : α), a ⊆ a
Succeeded for Mathlib.Init.Order.Defs._auxLemma.2 : ∀ {α : Type u} [inst : LinearOrder α] {a b : α}, (¬a ≤ b) = (b < a)
Succeeded for Mathlib.Init.Order.Defs._auxLemma.1 : ∀ {α : Type u} [inst : LinearOrder α] {a b : α}, (¬a < b) = (b ≤ a)
Succeeded for Filter.Tendsto.mono_left : ∀ {α : Type u} {β : Type v} {f : α → β} {x y : Filter α} {z : Filter β},
  Filter.Tendsto f x z → y ≤ x → Filter.Tendsto f y z
Succeeded for dvd_mul_right : ∀ {α : Type u_1} [inst : Semigroup α] (a b : α), a ∣ a * b
Succeeded for ContinuousOn.mono : ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β} {s t : Set α},
  ContinuousOn f s → t ⊆ s → ContinuousOn f t
Succeeded for Filter.basis_sets : ∀ {α : Type u_1} (l : Filter α), l.HasBasis (fun s => s ∈ l) id
Failed for LinearMap.map_zero : ∀ {R : Type u_1} {S : Type u_6} {M : Type u_9} {M₃ : Type u_12} [inst : Semiring R] [inst_1 : Semiring S]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₃] [inst_4 : Module R M] [inst_5 : Module S M₃] {σ : R →+* S}
  (f : M →ₛₗ[σ] M₃), f 0 = 0
unknown universe level 'u_12'

----
Succeeded for mul_inv_cancel_left : ∀ {G : Type u_1} [inst : Group G] (a b : G), a * (a⁻¹ * b) = b
Succeeded for Mathlib.Data.Finset.Image._auxLemma.25 : ∀ {α : Type u_1} {β : Type u_2} [inst : DecidableEq β] {f : α → β} {s : Finset α} {b : β},
  (b ∈ Finset.image f s) = ∃ a ∈ s, f a = b
Succeeded for Complex.ofReal_mul : ∀ (r s : ℝ), ↑(r * s) = ↑r * ↑s
Succeeded for add_neg_cancel_left : ∀ {G : Type u_1} [inst : AddGroup G] (a b : G), a + (-a + b) = b
Failed for inv_pos : ∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {a : α}, 0 < a⁻¹ ↔ 0 < a
invalid binder annotation, type is not a class instance
  LinearOrderedSemifield α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for Multiset.map_cons : ∀ {α : Type u_1} {β : Type v} (f : α → β) (a : α) (s : Multiset α), Multiset.map f (a ::ₘ s) = f a ::ₘ Multiset.map f s
Succeeded for Filter.EventuallyEq.trans : ∀ {α : Type u} {β : Type v} {l : Filter α} {f g h : α → β}, l.EventuallyEq f g → l.EventuallyEq g h → l.EventuallyEq f h
Succeeded for ite_self : ∀ {α : Sort u} {c : Prop} {d : Decidable c} (a : α), (if c then a else a) = a
Succeeded for Finset.card_map : ∀ {α : Type u_1} {β : Type u_2} {s : Finset α} (f : α ↪ β), (Finset.map f s).card = s.card
Succeeded for Mathlib.Data.Set.Defs._auxLemma.2 : ∀ {α : Type u} (s : Set α) (x : α), (x ∈ sᶜ) = (x ∉ s)
Succeeded for not_and_or : ∀ {a b : Prop}, ¬(a ∧ b) ↔ ¬a ∨ ¬b
Succeeded for List.reverse_cons : ∀ {α : Type u} (a : α) (as : List α), (a :: as).reverse = as.reverse ++ [a]
Succeeded for iff_true : ∀ (p : Prop), (p ↔ True) = p
Succeeded for Set.indicator_of_not_mem : ∀ {α : Type u_1} {M : Type u_4} [inst : Zero M] {s : Set α} {a : α}, a ∉ s → ∀ (f : α → M), s.indicator f a = 0
Failed for AlgHom.commutes : ∀ {R : Type u} {A : Type v} {B : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Semiring B]
  [inst_3 : Algebra R A] [inst_4 : Algebra R B] (φ : A →ₐ[R] B) (r : R), φ ((algebraMap R A) r) = (algebraMap R B) r
unexpected token 'φ'; expected '_' or identifier

----
Succeeded for HasFDerivAt.differentiableAt : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}
  {f' : E →L[𝕜] F} {x : E}, HasFDerivAt f f' x → DifferentiableAt 𝕜 f x
Succeeded for NeZero.ne : ∀ {R : Type u_1} [inst : Zero R] (n : R) [h : NeZero n], n ≠ 0
Succeeded for nhds_prod_eq : ∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {x : X} {y : Y},
  nhds (x, y) = nhds x ×ˢ nhds y
Succeeded for Set.image_preimage_eq_inter_range : ∀ {α : Type u_1} {β : Type u_2} {f : α → β} {t : Set β}, f '' (f ⁻¹' t) = t ∩ Set.range f
Succeeded for Nat.le_of_lt_succ : ∀ {m n : ℕ}, m < n.succ → m ≤ n
Failed for Subtype.range_coe_subtype : ∀ {α : Type u_1} {p : α → Prop}, Set.range Subtype.val = {x | p x}
don't know how to synthesize implicit argument 'ι'
  @Set.range α (Subtype ?m.61) Subtype.val
context:
α : Type u_1
p : α → Prop
⊢ Type (max 0 u_1)

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'p'
  @Subtype.val α ?m.61
context:
α : Type u_1
p : α → Prop
⊢ α → Prop

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Failed for CategoryTheory.Functor.image_preimage : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  (F : CategoryTheory.Functor C D) [inst_2 : F.Full] {X Y : C} (f : F.obj X ⟶ F.obj Y), F.map (F.preimage f) = f
unknown universe level 'v₁'

----
Succeeded for or_comm : ∀ {a b : Prop}, a ∨ b ↔ b ∨ a
Succeeded for RingHom.map_add : ∀ {α : Type u_2} {β : Type u_3} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a b : α),
  f (a + b) = f a + f b
Failed for isOpen_univ : ∀ {X : Type u} [inst : TopologicalSpace X], IsOpen Set.univ
typeclass instance problem is stuck, it is often due to metavariables
  TopologicalSpace ?m.624

----
Succeeded for Disjoint.symm : ∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : OrderBot α] ⦃a b : α⦄, Disjoint a b → Disjoint b a
Succeeded for sub_pos : ∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]
  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, 0 < a - b ↔ b < a
Succeeded for Filter.map_map : ∀ {α : Type u} {β : Type v} {γ : Type w} {f : Filter α} {m : α → β} {m' : β → γ},
  Filter.map m' (Filter.map m f) = Filter.map (m' ∘ m) f
Succeeded for MeasureTheory.ae_of_all : ∀ {α : Type u_1} [inst : MeasurableSpace α] {p : α → Prop} (μ : MeasureTheory.Measure α),
  (∀ (a : α), p a) → ∀ᵐ (a : α) ∂μ, p a
Succeeded for not_or : ∀ {p q : Prop}, ¬(p ∨ q) ↔ ¬p ∧ ¬q
Succeeded for lt_add_one : ∀ {α : Type u_1} [inst : One α] [inst_1 : AddZeroClass α] [inst_2 : PartialOrder α] [inst_3 : ZeroLEOneClass α]
  [inst_4 : NeZero 1] [inst_5 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : α), a < a + 1
Succeeded for heq_of_eq : ∀ {α : Sort u} {a a' : α}, a = a' → HEq a a'
Succeeded for pow_ne_zero : ∀ {M₀ : Type u_2} [inst : MonoidWithZero M₀] {a : M₀} [inst_1 : NoZeroDivisors M₀] (n : ℕ), a ≠ 0 → a ^ n ≠ 0
Succeeded for closure_minimal : ∀ {X : Type u} {s t : Set X} [inst : TopologicalSpace X], s ⊆ t → IsClosed t → closure s ⊆ t
Succeeded for ContinuousLinearMap.ext : ∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ₁₂ : R₁ →+* R₂} {M₁ : Type u_4}
  [inst_2 : TopologicalSpace M₁] [inst_3 : AddCommMonoid M₁] {M₂ : Type u_6} [inst_4 : TopologicalSpace M₂]
  [inst_5 : AddCommMonoid M₂] [inst_6 : Module R₁ M₁] [inst_7 : Module R₂ M₂] {f g : M₁ →SL[σ₁₂] M₂},
  (∀ (x : M₁), f x = g x) → f = g
Succeeded for neg_add_cancel_left : ∀ {G : Type u_1} [inst : AddGroup G] (a b : G), -a + (a + b) = b
Succeeded for Set.mem_setOf_eq : ∀ {α : Type u} {x : α} {p : α → Prop}, (x ∈ {y | p y}) = p x
Succeeded for Mathlib.Data.Set.Defs._auxLemma.9 : ∀ {α : Type u} {β : Type v} {s : Set α} {t : Set β} {p : α × β}, (p ∈ s ×ˢ t) = (p.1 ∈ s ∧ p.2 ∈ t)
Succeeded for Int.mul_comm : ∀ (a b : ℤ), a * b = b * a
Succeeded for StrictMono.le_iff_le : ∀ {α : Type u} {β : Type v} [inst : LinearOrder α] [inst_1 : Preorder β] {f : α → β},
  StrictMono f → ∀ {a b : α}, f a ≤ f b ↔ a ≤ b
Succeeded for Or.symm : ∀ {a b : Prop}, a ∨ b → b ∨ a
Failed for UniformContinuous.comp : ∀ {α : Type ua} {β : Type ub} {γ : Type uc} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]
  {g : β → γ} {f : α → β}, UniformContinuous g → UniformContinuous f → UniformContinuous (g ∘ f)
unknown universe level 'ua'
unknown universe level 'ub'
unknown universe level 'uc'

----
Failed for Tactic.Elementwise.hom_elementwise : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.ConcreteCategory C] {X Y : C}
  {f g : X ⟶ Y}, f = g → ∀ (x : (CategoryTheory.forget C).obj X), f x = g x
type expected, got
  (CategoryTheory.ConcreteCategory
  C : (FC : outParam (C → C → Type ?u.7)) →
  {CC : outParam (C → Type ?u.10)} →
    [outParam ((X Y : C) → FunLike (FC X Y) (CC X) (CC Y))] → Type (max (max u_1 ?u.7) u_2))

----
Succeeded for Finset.mem_image : ∀ {α : Type u_1} {β : Type u_2} [inst : DecidableEq β] {f : α → β} {s : Finset α} {b : β},
  b ∈ Finset.image f s ↔ ∃ a ∈ s, f a = b
Failed for AlgEquiv.ext : ∀ {R : Type uR} {A₁ : Type uA₁} {A₂ : Type uA₂} [inst : CommSemiring R] [inst_1 : Semiring A₁] [inst_2 : Semiring A₂]
  [inst_3 : Algebra R A₁] [inst_4 : Algebra R A₂] {f g : A₁ ≃ₐ[R] A₂}, (∀ (a : A₁), f a = g a) → f = g
unknown universe level 'uR'
unknown universe level 'uA₁'
unknown universe level 'uA₂'

----
Succeeded for Nat.cast_ne_zero : ∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] {n : ℕ}, ↑n ≠ 0 ↔ n ≠ 0
Succeeded for iff_false : ∀ (p : Prop), (p ↔ False) = ¬p
Succeeded for HomologicalComplex.Hom.comm : ∀ {ι : Type u_1} {V : Type u} [inst : CategoryTheory.Category.{v, u} V]
  [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] {c : ComplexShape ι} {A B : HomologicalComplex V c} (f : A.Hom B)
  (i j : ι), CategoryTheory.CategoryStruct.comp (f.f i) (B.d i j) = CategoryTheory.CategoryStruct.comp (A.d i j) (f.f j)
Succeeded for Int.cast_neg : ∀ {R : Type u} [inst : AddGroupWithOne R] (n : ℤ), ↑(-n) = -↑n
Succeeded for Complex.ext : ∀ {z w : ℂ}, z.re = w.re → z.im = w.im → z = w
Succeeded for GaloisConnection.l_bot : ∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : PartialOrder β] [inst_2 : OrderBot β] [inst_3 : OrderBot α]
  {l : α → β} {u : β → α}, GaloisConnection l u → l ⊥ = ⊥
Succeeded for SetLike.ext' : ∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p q : A}, ↑p = ↑q → p = q
Succeeded for StrictMono.monotone : ∀ {α : Type u} {β : Type v} [inst : PartialOrder α] [inst_1 : Preorder β] {f : α → β}, StrictMono f → Monotone f
Succeeded for closure_mono : ∀ {X : Type u} {s t : Set X} [inst : TopologicalSpace X], s ⊆ t → closure s ⊆ closure t
Succeeded for Submodule.smul_mem : ∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : Module R M} (p : Submodule R M)
  {x : M} (r : R), x ∈ p → r • x ∈ p
Succeeded for Finset.sum_const_zero : ∀ {α : Type u_3} {β : Type u_4} {s : Finset α} [inst : AddCommMonoid β], (s.sum fun _x => 0) = 0
Succeeded for GaloisConnection.monotone_l : ∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α},
  GaloisConnection l u → Monotone l
Succeeded for CharP.cast_eq_zero : ∀ (R : Type u_1) [inst : AddMonoidWithOne R] (p : ℕ) [inst_1 : CharP R p], ↑p = 0
Succeeded for Finset.coe_image₂ : ∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} [inst : DecidableEq γ] (f : α → β → γ) (s : Finset α) (t : Finset β),
  ↑(Finset.image₂ f s t) = Set.image2 f ↑s ↑t
Succeeded for Finset.mem_range : ∀ {n m : ℕ}, m ∈ Finset.range n ↔ m < n
Succeeded for lt_top_iff_ne_top : ∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderTop α] {a : α}, a < ⊤ ↔ a ≠ ⊤
Succeeded for Polynomial.eval_X : ∀ {R : Type u} [inst : Semiring R] {x : R}, Polynomial.eval x Polynomial.X = x
Succeeded for Nat.succ_le_succ : ∀ {n m : ℕ}, n ≤ m → n.succ ≤ m.succ
Succeeded for Mathlib.Data.Set.Defs._auxLemma.3 : ∀ {α : Type u} {s t : Set α} (x : α), (x ∈ s \ t) = (x ∈ s ∧ x ∉ t)
Succeeded for Finset.prod_insert : ∀ {α : Type u_3} {β : Type u_4} {s : Finset α} {a : α} {f : α → β} [inst : CommMonoid β] [inst_1 : DecidableEq α],
  a ∉ s → ((insert a s).prod fun x => f x) = f a * s.prod fun x => f x
Succeeded for Nat.succ_le_iff : ∀ {m n : ℕ}, m.succ ≤ n ↔ m < n
Failed for isCompact_univ : ∀ {X : Type u} [inst : TopologicalSpace X] [h : CompactSpace X], IsCompact Set.univ
typeclass instance problem is stuck, it is often due to metavariables
  TopologicalSpace ?m.636

----
Succeeded for mul_le_mul_right' : ∀ {α : Type u_1} [inst : Mul α] [inst_1 : LE α]
  [i : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {b c : α},
  b ≤ c → ∀ (a : α), b * a ≤ c * a
Succeeded for Finset.card_range : ∀ (n : ℕ), (Finset.range n).card = n
Succeeded for Mathlib.Data.Nat.Cast.Defs._auxLemma.3 : ∀ {R : Type u_1} [inst : AddMonoidWithOne R] (m n : ℕ), ↑m + ↑n = ↑(m + n)
Succeeded for Set.mem_iInter₂ : ∀ {γ : Type u_3} {ι : Sort u_4} {κ : ι → Sort u_7} {x : γ} {s : (i : ι) → κ i → Set γ},
  x ∈ ⋂ i, ⋂ j, s i j ↔ ∀ (i : ι) (j : κ i), x ∈ s i j
Succeeded for Function.Surjective.range_eq : ∀ {α : Type u_1} {ι : Sort u_4} {f : ι → α}, Function.Surjective f → Set.range f = Set.univ
Succeeded for Filter.le_principal_iff : ∀ {α : Type u} {s : Set α} {f : Filter α}, f ≤ Filter.principal s ↔ s ∈ f
Succeeded for ne_of_mem_of_not_mem : ∀ {α : Type u_1} {β : Type u_2} [inst : Membership α β] {s : β} {a b : α}, a ∈ s → b ∉ s → a ≠ b
Succeeded for Set.preimage_mono : ∀ {α : Type u_1} {β : Type u_2} {f : α → β} {s t : Set β}, s ⊆ t → f ⁻¹' s ⊆ f ⁻¹' t
Succeeded for Filter.EventuallyEq.refl : ∀ {α : Type u} {β : Type v} (l : Filter α) (f : α → β), l.EventuallyEq f f
Succeeded for Set.diff_subset : ∀ {α : Type u} (s t : Set α), s \ t ⊆ s
Succeeded for Units.isUnit : ∀ {M : Type u_1} [inst : Monoid M] (u : Mˣ), IsUnit ↑u
Succeeded for List.map_append : ∀ {α : Type u_1} {β : Type u_2} (f : α → β) (l₁ l₂ : List α), List.map f (l₁ ++ l₂) = List.map f l₁ ++ List.map f l₂
Succeeded for dvd_zero : ∀ {α : Type u_1} [inst : SemigroupWithZero α] (a : α), a ∣ 0
Succeeded for List.length_map : ∀ {α : Type u} {β : Type v} (as : List α) (f : α → β), (List.map f as).length = as.length
Succeeded for Finset.card_le_card : ∀ {α : Type u_1} {s t : Finset α}, s ⊆ t → s.card ≤ t.card
Succeeded for SetLike.ext'_iff : ∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p q : A}, p = q ↔ ↑p = ↑q
Succeeded for dist_self : ∀ {α : Type u} [inst : PseudoMetricSpace α] (x : α), dist x x = 0
Succeeded for continuous_pi : ∀ {X : Type u} {ι : Type u_5} {π : ι → Type u_6} [inst : TopologicalSpace X] [T : (i : ι) → TopologicalSpace (π i)]
  {f : X → (i : ι) → π i}, (∀ (i : ι), Continuous fun a => f a i) → Continuous f
Succeeded for inf_of_le_left : ∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ≤ b → a ⊓ b = a
Succeeded for le_bot_iff : ∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderBot α] {a : α}, a ≤ ⊥ ↔ a = ⊥
Succeeded for neg_inj : ∀ {G : Type u_3} [inst : InvolutiveNeg G] {a b : G}, -a = -b ↔ a = b
Succeeded for Nat.sub_add_cancel : ∀ {n m : ℕ}, m ≤ n → n - m + m = n
Succeeded for Set.empty_subset : ∀ {α : Type u} (s : Set α), ∅ ⊆ s
Succeeded for Nat.succ_pred_eq_of_pos : ∀ {n : ℕ}, 0 < n → n.pred.succ = n
Succeeded for Bool.of_not_eq_true : ∀ {b : Bool}, ¬b = true → b = false
Succeeded for nhdsWithin_le_nhds : ∀ {α : Type u_1} [inst : TopologicalSpace α] {a : α} {s : Set α}, nhdsWithin a s ≤ nhds a
Succeeded for HasSum.summable : ∀ {α : Type u_1} {β : Type u_2} [inst : AddCommMonoid α] [inst_1 : TopologicalSpace α] {f : β → α} {a : α},
  HasSum f a → Summable f
Succeeded for Set.image_empty : ∀ {α : Type u_1} {β : Type u_2} (f : α → β), f '' ∅ = ∅
Succeeded for Associated.symm : ∀ {α : Type u_1} [inst : Monoid α] {x y : α}, Associated x y → Associated y x
Succeeded for List.mem_cons : ∀ {α : Type u_1} {a b : α} {l : List α}, a ∈ b :: l ↔ a = b ∨ a ∈ l
Succeeded for Disjoint.le_bot : ∀ {α : Type u_1} [inst : SemilatticeInf α] [inst_1 : OrderBot α] {a b : α}, Disjoint a b → a ⊓ b ≤ ⊥
Succeeded for Mathlib.Algebra.GroupWithZero.Defs._auxLemma.1 : ∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, (a * b = 0) = (a = 0 ∨ b = 0)
Succeeded for HasFDerivAt.fderiv : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}
  {f' : E →L[𝕜] F} {x : E}, HasFDerivAt f f' x → fderiv 𝕜 f x = f'
Succeeded for IsClosed.preimage : ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X → Y},
  Continuous f → ∀ {t : Set Y}, IsClosed t → IsClosed (f ⁻¹' t)
Succeeded for Subtype.coe_eta : ∀ {α : Sort u_1} {p : α → Prop} (a : { a // p a }) (h : p ↑a), ⟨↑a, h⟩ = a
Succeeded for Int.cast_negSucc : ∀ {R : Type u} [inst : AddGroupWithOne R] (n : ℕ), ↑(Int.negSucc n) = -↑(n + 1)
Succeeded for Commute.all : ∀ {S : Type u_2} [inst : CommMagma S] (a b : S), Commute a b
Succeeded for Mathlib.Data.Fintype.Basic._auxLemma.25 : ∀ {α : Type u_1} {s : Set α} [inst : Fintype ↑s] {a : α}, (a ∈ s.toFinset) = (a ∈ s)
Succeeded for Set.range_subset_iff : ∀ {α : Type u_1} {ι : Sort u_4} {f : ι → α} {s : Set α}, Set.range f ⊆ s ↔ ∀ (y : ι), f y ∈ s
Succeeded for mem_of_mem_nhds : ∀ {X : Type u} {x : X} {s : Set X} [inst : TopologicalSpace X], s ∈ nhds x → x ∈ s
Succeeded for Commute.eq : ∀ {S : Type u_2} [inst : Mul S] {a b : S}, Commute a b → a * b = b * a
Succeeded for Continuous.smul : ∀ {M : Type u_1} {X : Type u_2} {Y : Type u_3} [inst : TopologicalSpace M] [inst_1 : TopologicalSpace X]
  [inst_2 : TopologicalSpace Y] [inst_3 : SMul M X] [inst_4 : ContinuousSMul M X] {f : Y → M} {g : Y → X},
  Continuous f → Continuous g → Continuous fun x => f x • g x
Succeeded for CategoryTheory.MonoidalCategory.id_tensorHom : ∀ {C : Type u} [𝒞 : CategoryTheory.Category.{v, u} C] [inst : CategoryTheory.MonoidalCategory C] (X : C) {Y₁ Y₂ : C}
  (f : Y₁ ⟶ Y₂),
  CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X) f =
    CategoryTheory.MonoidalCategory.whiskerLeft X f
Succeeded for inv_ne_zero : ∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {a : G₀}, a ≠ 0 → a⁻¹ ≠ 0
Succeeded for add_neg_self : ∀ {G : Type u_1} [inst : AddGroup G] (a : G), a + -a = 0
Failed for Real.Angle.sign_coe_pi_div_two : (↑(Real.pi / 2)).sign = 1
invalid coercion notation, expected type is not known

----
Succeeded for Nat.succ_sub_succ_eq_sub : ∀ (n m : ℕ), n.succ - m.succ = n - m
Failed for CategoryTheory.eqToHom_trans : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X Y Z : C} (p : X = Y) (q : Y = Z),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom p) (CategoryTheory.eqToHom q) = CategoryTheory.eqToHom ⋯
don't know how to synthesize placeholder for argument 'p'
context:
C : Type u₁
inst : CategoryTheory.Category.{v₁, u₁} C
X Y Z : C
p : X = Y
q : Y = Z
⊢ X = Z

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for Mathlib.Logic.Basic._auxLemma.2 : ∀ {a : Prop}, (a → False) = ¬a
Succeeded for exists_between : ∀ {α : Type u} [inst : LT α] [inst_1 : DenselyOrdered α] {a₁ a₂ : α}, a₁ < a₂ → ∃ a, a₁ < a ∧ a < a₂
Succeeded for inv_pow : ∀ {α : Type u_1} [inst : DivisionMonoid α] (a : α) (n : ℕ), a⁻¹ ^ n = (a ^ n)⁻¹
Succeeded for Ne.lt_or_lt : ∀ {α : Type u} [inst : LinearOrder α] {x y : α}, x ≠ y → x < y ∨ y < x
Succeeded for neg_vsub_eq_vsub_rev : ∀ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (p₁ p₂ : P), -(p₁ -ᵥ p₂) = p₂ -ᵥ p₁
Succeeded for disjoint_iff_inf_le : ∀ {α : Type u_1} [inst : SemilatticeInf α] [inst_1 : OrderBot α] {a b : α}, Disjoint a b ↔ a ⊓ b ≤ ⊥
Succeeded for mul_le_mul' : ∀ {α : Type u_1} [inst : Mul α] [inst_1 : Preorder α]
  [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1]
  [inst_3 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {a b c d : α},
  a ≤ b → c ≤ d → a * c ≤ b * d
Succeeded for smul_mul_assoc : ∀ {α : Type u_6} {β : Type u_7} [inst : Mul β] [inst_1 : SMul α β] [inst_2 : IsScalarTower α β β] (r : α) (x y : β),
  r • x * y = r • (x * y)
Succeeded for Filter.map_mono : ∀ {α : Type u} {β : Type v} {m : α → β}, Monotone (Filter.map m)
Succeeded for DifferentiableWithinAt.hasDerivWithinAt : ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {F : Type v} [inst_1 : NormedAddCommGroup F]
  [inst_2 : NormedSpace 𝕜 F] {f : 𝕜 → F} {x : 𝕜} {s : Set 𝕜},
  DifferentiableWithinAt 𝕜 f s x → HasDerivWithinAt f (derivWithin f s x) s x
Succeeded for Polynomial.degree_eq_natDegree : ∀ {R : Type u} [inst : Semiring R] {p : Polynomial R}, p ≠ 0 → p.degree = ↑p.natDegree
Succeeded for Equiv.image_eq_preimage : ∀ {α : Type u_1} {β : Type u_2} (e : α ≃ β) (s : Set α), ⇑e '' s = ⇑e.symm ⁻¹' s
Succeeded for Nat.Prime.ne_zero : ∀ {n : ℕ}, n.Prime → n ≠ 0
Succeeded for Nat.find_spec : ∀ {p : ℕ → Prop} [inst : DecidablePred p] (H : ∃ n, p n), p (Nat.find H)
Succeeded for Filter.Eventually.exists : ∀ {α : Type u} {p : α → Prop} {f : Filter α} [inst : f.NeBot], (∀ᶠ (x : α) in f, p x) → ∃ x, p x
Failed for CategoryTheory.Functor.map_injective : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  {X Y : C} (F : CategoryTheory.Functor C D) [inst_2 : F.Faithful], Function.Injective F.map
don't know how to synthesize implicit argument 'β'
  @Function.Injective (?m.122 F ⟶ ?m.123 F) (F.obj (?m.122 F) ⟶ F.obj (?m.123 F)) F.map
context:
C : Type u₁
inst : CategoryTheory.Category.{v₁, u₁} C
D : Type u₂
inst_1 : CategoryTheory.Category.{v₂, u₂} D
X Y : C
F : CategoryTheory.Functor C D
inst_2 : F.Faithful
⊢ Type v₂

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @Function.Injective (?m.122 F ⟶ ?m.123 F) (F.obj (?m.122 F) ⟶ F.obj (?m.123 F)) F.map
context:
C : Type u₁
inst : CategoryTheory.Category.{v₁, u₁} C
D : Type u₂
inst_1 : CategoryTheory.Category.{v₂, u₂} D
X Y : C
F : CategoryTheory.Functor C D
inst_2 : F.Faithful
⊢ Type v₁

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'Y'
  @CategoryTheory.Functor.map C inst D inst_1 F (?m.122 F) (?m.123 F)
context:
C : Type u₁
inst : CategoryTheory.Category.{v₁, u₁} C
D : Type u₂
inst_1 : CategoryTheory.Category.{v₂, u₂} D
X Y : C
F : CategoryTheory.Functor C D
inst_2 : F.Faithful
⊢ C

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'X'
  @CategoryTheory.Functor.map C inst D inst_1 F (?m.122 F) (?m.123 F)
context:
C : Type u₁
inst : CategoryTheory.Category.{v₁, u₁} C
D : Type u₂
inst_1 : CategoryTheory.Category.{v₂, u₂} D
X Y : C
F : CategoryTheory.Functor C D
inst_2 : F.Faithful
⊢ C

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for tendsto_nhds_unique : ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : T2Space X] {f : Y → X} {l : Filter Y} {a b : X}
  [inst_2 : l.NeBot], Filter.Tendsto f l (nhds a) → Filter.Tendsto f l (nhds b) → a = b
Succeeded for Set.mem_insert : ∀ {α : Type u} (x : α) (s : Set α), x ∈ insert x s
Failed for Quotient.sound' : ∀ {α : Sort u_1} {s₁ : Setoid α} {a b : α}, Setoid.r a b → Quotient.mk'' a = Quotient.mk'' b
don't know how to synthesize implicit argument 'α'
  @Eq (Quotient ?m.91) (Quotient.mk'' a) (Quotient.mk'' b)
context:
α : Sort u_1
s₁ : Setoid α
a b : α
⊢ Sort u_1

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 's₁'
  @Quotient.mk'' α ?m.91 b
context:
α : Sort u_1
s₁ : Setoid α
a b : α
⊢ Setoid α

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 's₁'
  @Quotient.mk'' α ?m.91 a
context:
α : Sort u_1
s₁ : Setoid α
a b : α
⊢ Setoid α

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for mul_le_mul : ∀ {α : Type u_1} {a b c d : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : PosMulMono α]
  [inst_3 : MulPosMono α], a ≤ b → c ≤ d → 0 ≤ c → 0 ≤ b → a * c ≤ b * d
Succeeded for Set.ball_image_iff : ∀ {α : Type u_1} {β : Type u_2} {f : α → β} {s : Set α} {p : β → Prop}, (∀ y ∈ f '' s, p y) ↔ ∀ ⦃x : α⦄, x ∈ s → p (f x)
Succeeded for Set.disjoint_left : ∀ {α : Type u} {s t : Set α}, Disjoint s t ↔ ∀ ⦃a : α⦄, a ∈ s → a ∉ t
Succeeded for Monotone.dual : ∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},
  Monotone f → Monotone (⇑OrderDual.toDual ∘ f ∘ ⇑OrderDual.ofDual)
Succeeded for Set.eq_univ_iff_forall : ∀ {α : Type u} {s : Set α}, s = Set.univ ↔ ∀ (x : α), x ∈ s
Succeeded for List.mem_cons_of_mem : ∀ {α : Type u_1} (y : α) {a : α} {l : List α}, a ∈ l → a ∈ y :: l
Succeeded for dist_eq_norm_sub : ∀ {E : Type u_6} [inst : SeminormedAddGroup E] (a b : E), dist a b = ‖a - b‖
Succeeded for Equiv.Perm.ext : ∀ {α : Sort u} {σ τ : Equiv.Perm α}, (∀ (x : α), σ x = τ x) → σ = τ
Succeeded for Eq.subst : ∀ {α : Sort u} {motive : α → Prop} {a b : α}, a = b → motive a → motive b
Succeeded for eq_or_lt_of_le : ∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → a = b ∨ a < b
Succeeded for HasDerivWithinAt.derivWithin : ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {F : Type v} [inst_1 : NormedAddCommGroup F]
  [inst_2 : NormedSpace 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜} {s : Set 𝕜},
  HasDerivWithinAt f f' s x → UniqueDiffWithinAt 𝕜 s x → derivWithin f s x = f'
Succeeded for le_antisymm_iff : ∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a = b ↔ a ≤ b ∧ b ≤ a
Failed for Finset.sum_le_sum : ∀ {ι : Type u_1} {N : Type u_5} [inst : OrderedAddCommMonoid N] {f g : ι → N} {s : Finset ι},
  (∀ i ∈ s, f i ≤ g i) → (s.sum fun i => f i) ≤ s.sum fun i => g i
invalid binder annotation, type is not a class instance
  OrderedAddCommMonoid N

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for Primrec.of_eq : ∀ {α : Type u_1} {σ : Type u_3} [inst : Primcodable α] [inst_1 : Primcodable σ] {f g : α → σ},
  Primrec f → (∀ (n : α), f n = g n) → Primrec g
Failed for Mathlib.Data.Set.Basic._auxLemma.49 : ∀ {α : Type u} (a : α), {a}.Nonempty = True
overloaded, errors 
  Invalid field notation: Type of
    {a}
  is not known; cannot resolve field `Nonempty`
  
  invalid {...} notation, expected type is not known

----
Succeeded for Mathlib.Data.Set.Basic._auxLemma.17 : ∀ {α : Type u} (x : α) (a b : Set α), (x ∈ a ∪ b) = (x ∈ a ∨ x ∈ b)
Failed for ContinuousLinearMap.addCommGroup.proof_1 : ∀ {M₂ : Type u_1} [inst : TopologicalSpace M₂] [inst_1 : AddCommGroup M₂] [inst_2 : TopologicalAddGroup M₂],
  ContinuousAdd M₂
invalid binder annotation, type is not a class instance
  TopologicalAddGroup M₂

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Failed for Mathlib.Algebra.Order.Monoid.Canonical.Defs._auxLemma.11 : ∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] {a : α}, (a ≤ 0) = (a = 0)
invalid binder annotation, type is not a class instance
  CanonicallyOrderedAddCommMonoid α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for Filter.comap_comap : ∀ {α : Type u} {β : Type v} {γ : Type w} {f : Filter α} {m : γ → β} {n : β → α},
  Filter.comap m (Filter.comap n f) = Filter.comap (n ∘ m) f
Succeeded for top_le_iff : ∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderTop α] {a : α}, ⊤ ≤ a ↔ a = ⊤
Succeeded for dist_eq_norm_div : ∀ {E : Type u_6} [inst : SeminormedGroup E] (a b : E), dist a b = ‖a / b‖
Succeeded for tsub_le_iff_right : ∀ {α : Type u_1} [inst : LE α] [inst_1 : Add α] [inst_2 : Sub α] [inst_3 : OrderedSub α] {a b c : α},
  a - b ≤ c ↔ a ≤ c + b
Succeeded for Nat.succ_eq_add_one : ∀ (n : ℕ), n.succ = n + 1
Succeeded for List.length_append : ∀ {α : Type u} (as bs : List α), (as ++ bs).length = as.length + bs.length
Succeeded for dist_zero_right : ∀ {E : Type u_6} [inst : SeminormedAddGroup E] (a : E), dist a 0 = ‖a‖
Failed for MeasureTheory.withDensity_apply : ∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} (f : α → ENNReal) {s : Set α},
  MeasurableSet s → ↑↑(μ.withDensity f) s = ∫⁻ (a : α) in s, f a ∂μ
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known

----
Failed for Primrec.snd : ∀ {α : Type u_3} {β : Type u_4} [inst : Primcodable α] [inst_1 : Primcodable β], Primrec Prod.snd
typeclass instance problem is stuck, it is often due to metavariables
  Primcodable ?m.120

----
Succeeded for Cardinal.mk_fintype : ∀ (α : Type u) [h : Fintype α], Cardinal.mk α = ↑(Fintype.card α)
Succeeded for CategoryTheory.Preadditive.comp_neg : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Preadditive C] {P Q R : C} (f : P ⟶ Q)
  (g : Q ⟶ R), CategoryTheory.CategoryStruct.comp f (-g) = -CategoryTheory.CategoryStruct.comp f g
Succeeded for mul_eq_zero : ∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 ↔ a = 0 ∨ b = 0
Succeeded for sub_sub_cancel : ∀ {G : Type u_3} [inst : AddCommGroup G] (a b : G), a - (a - b) = b
Succeeded for div_mul_cancel : ∀ {G : Type u_3} [inst : Group G] (a b : G), a / b * b = a
Succeeded for HasFDerivWithinAt.differentiableWithinAt : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}
  {f' : E →L[𝕜] F} {x : E} {s : Set E}, HasFDerivWithinAt f f' s x → DifferentiableWithinAt 𝕜 f s x
Succeeded for sub_mul : ∀ {α : Type u} [inst : NonUnitalNonAssocRing α] (a b c : α), (a - b) * c = a * c - b * c
Succeeded for WithBot.coe_le_coe : ∀ {α : Type u_1} {a b : α} [inst : LE α], ↑a ≤ ↑b ↔ a ≤ b
Succeeded for Polynomial.eval_C : ∀ {R : Type u} {a : R} [inst : Semiring R] {x : R}, Polynomial.eval x (Polynomial.C a) = a
Succeeded for Set.union_comm : ∀ {α : Type u} (a b : Set α), a ∪ b = b ∪ a
Succeeded for and_congr_right : ∀ {a b c : Prop}, (a → (b ↔ c)) → (a ∧ b ↔ a ∧ c)
Succeeded for neg_pos : ∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a : α}, 0 < -a ↔ a < 0
Succeeded for add_lt_add_left : ∀ {α : Type u_1} [inst : Add α] [inst_1 : LT α]
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {b c : α}, b < c → ∀ (a : α), a + b < a + c
Succeeded for Nat.succ_add : ∀ (n m : ℕ), n.succ + m = (n + m).succ
Succeeded for DifferentiableAt.differentiableWithinAt : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}
  {x : E} {s : Set E}, DifferentiableAt 𝕜 f x → DifferentiableWithinAt 𝕜 f s x
Succeeded for Finset.mem_coe : ∀ {α : Type u_1} {a : α} {s : Finset α}, a ∈ ↑s ↔ a ∈ s
Succeeded for Fin.is_lt : ∀ {n : ℕ} (a : Fin n), ↑a < n
Failed for AddOpposite.unop_injective : ∀ {α : Type u_1}, Function.Injective AddOpposite.unop
don't know how to synthesize implicit argument 'β'
  @Function.Injective ?m.14ᵃᵒᵖ ?m.14 AddOpposite.unop
context:
α : Type u_1
⊢ Type ?u.9

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @Function.Injective ?m.14ᵃᵒᵖ ?m.14 AddOpposite.unop
context:
α : Type u_1
⊢ Type ?u.9

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @AddOpposite.unop ?m.14
context:
α : Type u_1
⊢ Type ?u.9

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for Polynomial.leadingCoeff_eq_zero : ∀ {R : Type u} [inst : Semiring R] {p : Polynomial R}, p.leadingCoeff = 0 ↔ p = 0
Succeeded for heq_eq_eq : ∀ {α : Sort u_1} (a b : α), HEq a b = (a = b)
Failed for le_add_self : ∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] {a b : α}, a ≤ b + a
invalid binder annotation, type is not a class instance
  CanonicallyOrderedAddCommMonoid α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for GaloisConnection.le_u_l : ∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α},
  GaloisConnection l u → ∀ (a : α), a ≤ u (l a)
Succeeded for Nat.Prime.pos : ∀ {p : ℕ}, p.Prime → 0 < p
Succeeded for Set.Ioc_subset_Icc_self : ∀ {α : Type u_1} [inst : Preorder α] {a b : α}, Set.Ioc a b ⊆ Set.Icc a b
Succeeded for Real.rpow_pos_of_pos : ∀ {x : ℝ}, 0 < x → ∀ (y : ℝ), 0 < x ^ y
Succeeded for CategoryTheory.Limits.cokernel.condition : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X Y : C}
  (f : X ⟶ Y) [inst_2 : CategoryTheory.Limits.HasCokernel f],
  CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.cokernel.π f) = 0
Succeeded for sup_of_le_left : ∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, b ≤ a → a ⊔ b = a
Succeeded for mul_pow : ∀ {M : Type u} [inst : CommMonoid M] (a b : M) (n : ℕ), (a * b) ^ n = a ^ n * b ^ n
Succeeded for ne_of_apply_ne : ∀ {α : Sort u_1} {β : Sort u_2} (f : α → β) {x y : α}, f x ≠ f y → x ≠ y
Succeeded for decide_eq_true_eq : ∀ {p : Prop} [inst : Decidable p], (decide p = true) = p
Succeeded for disjoint_iff : ∀ {α : Type u_1} [inst : SemilatticeInf α] [inst_1 : OrderBot α] {a b : α}, Disjoint a b ↔ a ⊓ b = ⊥
Failed for MeasureTheory.lintegral_const : ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} (c : ENNReal),
  ∫⁻ (x : α), c ∂μ = c * ↑↑μ Set.univ
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known

----
Succeeded for Finset.mem_insert_of_mem : ∀ {α : Type u_1} [inst : DecidableEq α] {s : Finset α} {a b : α}, a ∈ s → a ∈ insert b s
Succeeded for Nat.div_zero : ∀ (n : ℕ), n / 0 = 0
Failed for MeasureTheory.Filtration.le : ∀ {Ω : Type u_1} {ι : Type u_3} {m : MeasurableSpace Ω} [inst : Preorder ι] (f : MeasureTheory.Filtration ι m) (i : ι),
  ↑f i ≤ m
invalid coercion notation, expected type is not known

----
Succeeded for Nat.add_assoc : ∀ (n m k : ℕ), n + m + k = n + (m + k)
Succeeded for Mathlib.Data.Subtype._auxLemma.2 : ∀ {α : Sort u_1} {p : α → Prop} {q : { a // p a } → Prop}, (∃ x, q x) = ∃ a, ∃ (b : p a), q ⟨a, b⟩
Failed for Primrec.const : ∀ {α : Type u_1} {σ : Type u_3} [inst : Primcodable α] [inst_1 : Primcodable σ] (x : σ), Primrec fun x_1 => x
typeclass instance problem is stuck, it is often due to metavariables
  Primcodable (?m.82 x)

----
Succeeded for Polynomial.Monic.leadingCoeff : ∀ {R : Type u} [inst : Semiring R] {p : Polynomial R}, p.Monic → p.leadingCoeff = 1
Succeeded for max_le : ∀ {α : Type u} [inst : LinearOrder α] {a b c : α}, a ≤ c → b ≤ c → max a b ≤ c
Succeeded for Nat.le_add_left : ∀ (n m : ℕ), n ≤ m + n
Succeeded for Algebra.commutes : ∀ {R : Type u} {A : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (r : R) (x : A),
  (algebraMap R A) r * x = x * (algebraMap R A) r
Succeeded for Mathlib.Data.Finset.Image._auxLemma.1 : ∀ {α : Type u_1} {β : Type u_2} {f : α ↪ β} {s : Finset α} {b : β}, (b ∈ Finset.map f s) = ∃ a ∈ s, f a = b
Succeeded for List.Perm.symm : ∀ {α : Type u_1} {l₁ l₂ : List α}, l₁.Perm l₂ → l₂.Perm l₁
Succeeded for one_pos : ∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : PartialOrder α] [inst_3 : ZeroLEOneClass α]
  [inst_4 : NeZero 1], 0 < 1
Succeeded for Set.Nonempty.ne_empty : ∀ {α : Type u} {s : Set α}, s.Nonempty → s ≠ ∅
Succeeded for smul_sub : ∀ {M : Type u_1} {A : Type u_4} [inst : Monoid M] [inst_1 : AddGroup A] [inst_2 : DistribMulAction M A] (r : M)
  (x y : A), r • (x - y) = r • x - r • y
Succeeded for inv_eq_one_div : ∀ {G : Type u_3} [inst : DivInvMonoid G] (x : G), x⁻¹ = 1 / x
Succeeded for Finset.prod_const : ∀ {α : Type u_3} {β : Type u_4} {s : Finset α} [inst : CommMonoid β] (b : β), (s.prod fun _x => b) = b ^ s.card
Succeeded for Int.add_one_le_iff : ∀ {a b : ℤ}, a + 1 ≤ b ↔ a < b
Succeeded for if_true : ∀ {α : Sort u_1} {x : Decidable True} (t e : α), (if True then t else e) = t
Succeeded for div_mul_eq_mul_div : ∀ {α : Type u_1} [inst : DivisionCommMonoid α] (a b c : α), a / b * c = a * c / b
Failed for Finset.card_singleton : ∀ {α : Type u_1} (a : α), {a}.card = 1
overloaded, errors 
  Invalid field notation: Type of
    {a}
  is not known; cannot resolve field `card`
  
  invalid {...} notation, expected type is not known

----
Failed for AEMeasurable.ae_eq_mk : ∀ {α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} [inst : MeasurableSpace β] {f : α → β}
  {μ : MeasureTheory.Measure α} (h : AEMeasurable f μ), μ.ae.EventuallyEq f (AEMeasurable.mk f h)
Invalid field `ae`: The environment does not contain `MeasureTheory.Measure.ae`
  μ
has type
  MeasureTheory.Measure α

----
Succeeded for Dvd.intro : ∀ {α : Type u_1} [inst : Semigroup α] {a b : α} (c : α), a * c = b → a ∣ b
Succeeded for List.reverse_reverse : ∀ {α : Type u} (as : List α), as.reverse.reverse = as
Failed for Algebra.subset_adjoin : ∀ {R : Type uR} {A : Type uA} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] {s : Set A},
  s ⊆ ↑(Algebra.adjoin R s)
unknown universe level 'uR'
unknown universe level 'uA'

----
Succeeded for HasStrictDerivAt.hasDerivAt : ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {F : Type v} [inst_1 : NormedAddCommGroup F]
  [inst_2 : NormedSpace 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜}, HasStrictDerivAt f f' x → HasDerivAt f f' x
Succeeded for Filter.Eventually.and : ∀ {α : Type u} {p q : α → Prop} {f : Filter α},
  Filter.Eventually p f → Filter.Eventually q f → ∀ᶠ (x : α) in f, p x ∧ q x
Succeeded for Mathlib.Order.BoundedOrder._auxLemma.9 : ∀ {α : Type u} [inst : LE α] [inst_1 : OrderBot α] {a : α}, (⊥ ≤ a) = True
Succeeded for Mathlib.Data.Prod.Basic._auxLemma.2 : ∀ {α : Type u_1} {β : Type u_2} {p : α × β → Prop}, (∃ x, p x) = ∃ a b, p (a, b)
Succeeded for Finsupp.single_eq_same : ∀ {α : Type u_1} {M : Type u_5} [inst : Zero M] {a : α} {b : M}, (fun₀ | a => b) a = b
Succeeded for Mathlib.Algebra.Group.Units._auxLemma.26 : ∀ {α : Type u} [inst : AddCommMonoid α] [inst_1 : Subsingleton (AddUnits α)] {a b : α}, (a + b = 0) = (a = 0 ∧ b = 0)
Succeeded for isOpen_compl_iff : ∀ {X : Type u} {s : Set X} [inst : TopologicalSpace X], IsOpen sᶜ ↔ IsClosed s
Failed for pow_nonneg : ∀ {α : Type u} [inst : OrderedSemiring α] {a : α}, 0 ≤ a → ∀ (n : ℕ), 0 ≤ a ^ n
invalid binder annotation, type is not a class instance
  OrderedSemiring α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for le_sSup : ∀ {α : Type u_1} [inst : CompleteSemilatticeSup α] {s : Set α} {a : α}, a ∈ s → a ≤ sSup s
Succeeded for Mathlib.Data.Multiset.Basic._auxLemma.5 : ∀ {α : Type u_1} {a : α} {l : List α}, (a ∈ ↑l) = (a ∈ l)
Succeeded for mul_smul_comm : ∀ {α : Type u_6} {β : Type u_7} [inst : Mul β] [inst_1 : SMul α β] [inst_2 : SMulCommClass α β β] (s : α) (x y : β),
  x * s • y = s • (x * y)
Succeeded for Finset.coe_insert : ∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (s : Finset α), ↑(insert a s) = insert a ↑s
Succeeded for IsOpen.measurableSet : ∀ {α : Type u_1} {s : Set α} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : OpensMeasurableSpace α],
  IsOpen s → MeasurableSet s
Succeeded for Multiset.mem_map : ∀ {α : Type u_1} {β : Type v} {f : α → β} {b : β} {s : Multiset α}, b ∈ Multiset.map f s ↔ ∃ a ∈ s, f a = b
Succeeded for Contravariant.AddLECancellable : ∀ {α : Type u_1} [inst : Add α] [inst_1 : LE α]
  [inst_2 : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α}, AddLECancellable a
Succeeded for Set.to_countable : ∀ {α : Type u} (s : Set α) [inst : Countable ↑s], s.Countable
Failed for OpenEmbedding.isOpenMap : ∀ {X : Type u_1} {Y : Type u_2} {f : X → Y} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y],
  OpenEmbedding f → IsOpenMap f
Function expected at
  OpenEmbedding
but this term has type
  ?m.19

Note: Expected a function because this term is being applied to the argument
  f

----
Succeeded for Function.funext_iff : ∀ {α : Sort u_1} {β : α → Sort u} {f₁ f₂ : (x : α) → β x}, f₁ = f₂ ↔ ∀ (a : α), f₁ a = f₂ a
Succeeded for HasDerivAt.differentiableAt : ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {F : Type v} [inst_1 : NormedAddCommGroup F]
  [inst_2 : NormedSpace 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜}, HasDerivAt f f' x → DifferentiableAt 𝕜 f x
Succeeded for Submodule.span_le : ∀ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {s : Set M}
  {p : Submodule R M}, Submodule.span R s ≤ p ↔ s ⊆ ↑p
Succeeded for Nat.le_of_lt : ∀ {n m : ℕ}, n < m → n ≤ m
Succeeded for Part.bind_some : ∀ {α : Type u_1} {β : Type u_2} (a : α) (f : α → Part β), (Part.some a).bind f = f a
Succeeded for Finset.eq_of_veq : ∀ {α : Type u_1} {s t : Finset α}, s.val = t.val → s = t
Failed for Finset.coe_empty : ∀ {α : Type u_1}, ↑∅ = ∅
typeclass instance problem is stuck, it is often due to metavariables
  EmptyCollection ?m.254

----
Succeeded for StrictMono.injective : ∀ {α : Type u} {β : Type v} [inst : LinearOrder α] [inst_1 : Preorder β] {f : α → β},
  StrictMono f → Function.Injective f
Failed for div_nonneg : ∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {a b : α}, 0 ≤ a → 0 ≤ b → 0 ≤ a / b
invalid binder annotation, type is not a class instance
  LinearOrderedSemifield α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for add_right_comm : ∀ {G : Type u_3} [inst : AddCommSemigroup G] (a b c : G), a + b + c = a + c + b
Succeeded for Set.preimage_image_eq : ∀ {α : Type u_1} {β : Type u_2} {f : α → β} (s : Set α), Function.Injective f → f ⁻¹' (f '' s) = s
Succeeded for Antitone.dual_right : ∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β},
  Antitone f → Monotone (⇑OrderDual.toDual ∘ f)
Succeeded for Set.Nonempty.mono : ∀ {α : Type u} {s t : Set α}, s ⊆ t → s.Nonempty → t.Nonempty
Succeeded for Set.OrdConnected.out : ∀ {α : Type u_1} [inst : Preorder α] {s : Set α}, s.OrdConnected → ∀ ⦃x : α⦄, x ∈ s → ∀ ⦃y : α⦄, y ∈ s → Set.Icc x y ⊆ s
Succeeded for Disjoint.mono : ∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : OrderBot α] {a b c d : α},
  a ≤ b → c ≤ d → Disjoint b d → Disjoint a c
Succeeded for Cardinal.mk_congr : ∀ {α β : Type u}, α ≃ β → Cardinal.mk α = Cardinal.mk β
Succeeded for Commute.refl : ∀ {S : Type u_2} [inst : Mul S] (a : S), Commute a a
Succeeded for SetLike.ext_iff : ∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p q : A}, p = q ↔ ∀ (x : B), x ∈ p ↔ x ∈ q
Failed for MeasureTheory.AEStronglyMeasurable.ae_eq_mk : ∀ {α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} [inst : TopologicalSpace β]
  {f : α → β} (hf : MeasureTheory.AEStronglyMeasurable f μ),
  μ.ae.EventuallyEq f (MeasureTheory.AEStronglyMeasurable.mk f hf)
Invalid field `ae`: The environment does not contain `MeasureTheory.Measure.ae`
  μ
has type
  MeasureTheory.Measure α

----
Succeeded for bot_unique : ∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderBot α] {a : α}, a ≤ ⊥ → a = ⊥
Succeeded for ContinuousAt.continuousWithinAt : ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β} {s : Set α}
  {x : α}, ContinuousAt f x → ContinuousWithinAt f s x
Succeeded for MeasureTheory.memℒp_one_iff_integrable : ∀ {α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} [inst : NormedAddCommGroup β]
  {f : α → β}, MeasureTheory.Memℒp f 1 μ ↔ MeasureTheory.Integrable f μ
Succeeded for Ne.isUnit : ∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {a : G₀}, a ≠ 0 → IsUnit a
Succeeded for Commute.symm : ∀ {S : Type u_2} [inst : Mul S] {a b : S}, Commute a b → Commute b a
Failed for SMulCommClass.symm : ∀ (M : Type u_10) (N : Type u_11) (α : Type u_12) [inst : SMul M α] [inst_1 : SMul N α] [inst_2 : SMulCommClass M N α],
  SMulCommClass N M α
unknown universe level 'u_11'
unknown universe level 'u_12'

----
Succeeded for LinearEquiv.ext : ∀ {R : Type u_1} {S : Type u_6} {M : Type u_7} {M₂ : Type u_9} [inst : Semiring R] [inst_1 : Semiring S]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] {module_M : Module R M} {module_S_M₂ : Module S M₂}
  {σ : R →+* S} {σ' : S →+* R} {re₁ : RingHomInvPair σ σ'} {re₂ : RingHomInvPair σ' σ} {e e' : M ≃ₛₗ[σ] M₂},
  (∀ (x : M), e x = e' x) → e = e'
Succeeded for mul_left_inv : ∀ {G : Type u_1} [inst : Group G] (a : G), a⁻¹ * a = 1
Succeeded for Cardinal.nat_lt_aleph0 : ∀ (n : ℕ), ↑n < Cardinal.aleph0
Succeeded for Set.range_nonempty : ∀ {α : Type u_1} {ι : Sort u_4} [h : Nonempty ι] (f : ι → α), (Set.range f).Nonempty
Succeeded for CategoryTheory.Limits.kernel.condition : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X Y : C}
  (f : X ⟶ Y) [inst_2 : CategoryTheory.Limits.HasKernel f],
  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.ι f) f = 0
Succeeded for List.cons.injEq : ∀ {α : Type u} (head : α) (tail : List α) (head_1 : α) (tail_1 : List α),
  (head :: tail = head_1 :: tail_1) = (head = head_1 ∧ tail = tail_1)
Succeeded for zpow_one : ∀ {G : Type w} [inst : DivInvMonoid G] (a : G), a ^ 1 = a
Succeeded for Order.lt_succ : ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : SuccOrder α] [inst_2 : NoMaxOrder α] (a : α), a < Order.succ a
Succeeded for Nat.ne_of_gt : ∀ {a b : ℕ}, b < a → a ≠ b
Succeeded for Polynomial.coeff_map : ∀ {R : Type u} {S : Type v} [inst : Semiring R] {p : Polynomial R} [inst_1 : Semiring S] (f : R →+* S) (n : ℕ),
  (Polynomial.map f p).coeff n = f (p.coeff n)
Succeeded for Mathlib.Algebra.CharZero.Defs._auxLemma.3 : ∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] {n : ℕ}, (↑n = 0) = (n = 0)
Succeeded for Set.mem_range : ∀ {α : Type u} {ι : Sort u_1} {f : ι → α} {x : α}, x ∈ Set.range f ↔ ∃ y, f y = x
Succeeded for ge_of_eq : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a = b → a ≥ b
Succeeded for Filter.ext : ∀ {α : Type u} {f g : Filter α}, (∀ (s : Set α), s ∈ f ↔ s ∈ g) → f = g
Succeeded for Finsupp.mem_support_iff : ∀ {α : Type u_1} {M : Type u_5} [inst : Zero M] {f : α →₀ M} {a : α}, a ∈ f.support ↔ f a ≠ 0
Succeeded for CategoryTheory.Limits.image.fac : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} (f : X ⟶ Y)
  [inst_1 : CategoryTheory.Limits.HasImage f],
  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage f) (CategoryTheory.Limits.image.ι f) = f
Succeeded for Nat.zero_lt_succ : ∀ (n : ℕ), 0 < n.succ
Succeeded for inv_mul_cancel_left : ∀ {G : Type u_1} [inst : Group G] (a b : G), a⁻¹ * (a * b) = b
Succeeded for Real.rpow_zero : ∀ (x : ℝ), x ^ 0 = 1
Succeeded for Mathlib.Algebra.Order.Monoid.Lemmas._auxLemma.15 : ∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LE α]
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]
  [inst_3 : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] (a : α) {b : α}, (a ≤ a + b) = (0 ≤ b)
Succeeded for norm_pos_iff : ∀ {E : Type u_6} [inst : NormedAddGroup E] {a : E}, 0 < ‖a‖ ↔ a ≠ 0
Succeeded for Nat.le_trans : ∀ {n m k : ℕ}, n ≤ m → m ≤ k → n ≤ k
Succeeded for inf_assoc : ∀ {α : Type u} [inst : SemilatticeInf α] (a b c : α), a ⊓ b ⊓ c = a ⊓ (b ⊓ c)
Succeeded for add_lt_add_right : ∀ {α : Type u_1} [inst : Add α] [inst_1 : LT α]
  [i : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {b c : α},
  b < c → ∀ (a : α), b + a < c + a
Succeeded for nhdsWithin_univ : ∀ {α : Type u_1} [inst : TopologicalSpace α] (a : α), nhdsWithin a Set.univ = nhds a
Succeeded for Nat.Prime.ne_one : ∀ {p : ℕ}, p.Prime → p ≠ 1
Failed for continuous_add : ∀ {M : Type u_3} [inst : TopologicalSpace M] [inst_1 : Add M] [inst_2 : ContinuousAdd M], Continuous fun p => p.1 + p.2
Invalid projection: Type of
  p
is not known; cannot resolve projection `1`
Invalid projection: Type of
  p
is not known; cannot resolve projection `2`

----
Succeeded for OrderHom.mono : ∀ {α : Type u_2} {β : Type u_3} [inst : Preorder α] [inst_1 : Preorder β] (f : α →o β), Monotone ⇑f
Succeeded for irrefl : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsIrrefl α r] (a : α), ¬r a a
Succeeded for MeasureTheory.AEStronglyMeasurable.stronglyMeasurable_mk : ∀ {α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} [inst : TopologicalSpace β]
  {f : α → β} (hf : MeasureTheory.AEStronglyMeasurable f μ),
  MeasureTheory.StronglyMeasurable (MeasureTheory.AEStronglyMeasurable.mk f hf)
Succeeded for Nat.lt_of_le_of_lt : ∀ {n m k : ℕ}, n ≤ m → m < k → n < k
Failed for le_self_add : ∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] {a c : α}, a ≤ a + c
invalid binder annotation, type is not a class instance
  CanonicallyOrderedAddCommMonoid α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for Finset.sum_add_distrib : ∀ {α : Type u_3} {β : Type u_4} {s : Finset α} {f g : α → β} [inst : AddCommMonoid β],
  (s.sum fun x => f x + g x) = (s.sum fun x => f x) + s.sum fun x => g x
Succeeded for not_imp_not : ∀ {a b : Prop}, ¬a → ¬b ↔ b → a
Succeeded for GaloisConnection.monotone_u : ∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α},
  GaloisConnection l u → Monotone u
Failed for Subtype.mk.injEq : ∀ {α : Sort u} {p : α → Prop} (val : α) (property : p val) (val_1 : α) (property_1 : p val_1),
  (⟨val, property⟩ = ⟨val_1, property_1⟩) = (val = val_1)
invalid constructor ⟨...⟩, expected type must be an inductive type 
  ?m.29 val property val_1 property_1
invalid constructor ⟨...⟩, expected type must be an inductive type 
  ?m.29 val property val_1 property_1

----
Succeeded for Nonempty.map : ∀ {α : Sort u_4} {β : Sort u_5}, (α → β) → Nonempty α → Nonempty β
Succeeded for neg_nonneg : ∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α}, 0 ≤ -a ↔ a ≤ 0
Succeeded for iff_of_false : ∀ {a b : Prop}, ¬a → ¬b → (a ↔ b)
Succeeded for Ideal.ext : ∀ {α : Type u} [inst : Semiring α] {I J : Ideal α}, (∀ (x : α), x ∈ I ↔ x ∈ J) → I = J
Succeeded for TopologicalSpace.Opens.ext : ∀ {α : Type u_2} [inst : TopologicalSpace α] {U V : TopologicalSpace.Opens α}, ↑U = ↑V → U = V
Succeeded for ENNReal.summable : ∀ {α : Type u_1} {f : α → ENNReal}, Summable f
Succeeded for AEMeasurable.measurable_mk : ∀ {α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} [inst : MeasurableSpace β] {f : α → β}
  {μ : MeasureTheory.Measure α} (h : AEMeasurable f μ), Measurable (AEMeasurable.mk f h)
Succeeded for ENNReal.mul_lt_top : ∀ {a b : ENNReal}, a ≠ ⊤ → b ≠ ⊤ → a * b < ⊤
Succeeded for min_le_left : ∀ {α : Type u} [inst : LinearOrder α] (a b : α), min a b ≤ a
Failed for AddUnits.ext : ∀ {α : Type u} [inst : AddMonoid α], Function.Injective AddUnits.val
typeclass instance problem is stuck, it is often due to metavariables
  AddMonoid ?m.281

----
Succeeded for Nat.gcd_dvd_left : ∀ (m n : ℕ), m.gcd n ∣ m
Succeeded for ENNReal.coe_le_coe : ∀ {r q : NNReal}, ↑r ≤ ↑q ↔ r ≤ q
Succeeded for iSup₂_le : ∀ {α : Type u_1} {ι : Sort u_5} {κ : ι → Sort u_7} [inst : CompleteLattice α] {a : α} {f : (i : ι) → κ i → α},
  (∀ (i : ι) (j : κ i), f i j ≤ a) → ⨆ i, ⨆ j, f i j ≤ a
Succeeded for MeasureTheory.Measure.restrict_univ : ∀ {α : Type u_2} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α}, μ.restrict Set.univ = μ
Succeeded for Finset.mem_Ico : ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : LocallyFiniteOrder α] {a b x : α}, x ∈ Finset.Ico a b ↔ a ≤ x ∧ x < b
Succeeded for CategoryTheory.Preadditive.neg_comp : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Preadditive C] {P Q R : C} (f : P ⟶ Q)
  (g : Q ⟶ R), CategoryTheory.CategoryStruct.comp (-f) g = -CategoryTheory.CategoryStruct.comp f g
Succeeded for Set.union_empty : ∀ {α : Type u} (a : Set α), a ∪ ∅ = a
Succeeded for Polynomial.C_mul_X_pow_eq_monomial : ∀ {R : Type u} {a : R} [inst : Semiring R] {n : ℕ}, Polynomial.C a * Polynomial.X ^ n = (Polynomial.monomial n) a
Succeeded for mul_left_cancel₀ : ∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [inst_2 : IsLeftCancelMulZero M₀] {a b c : M₀},
  a ≠ 0 → a * b = a * c → b = c
Succeeded for List.map_id : ∀ {α : Type u_1} (l : List α), List.map id l = l
Succeeded for IsCompact.isClosed : ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] {s : Set X}, IsCompact s → IsClosed s
Succeeded for sup_eq_right : ∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ⊔ b = b ↔ a ≤ b
Succeeded for Set.mem_image : ∀ {α : Type u} {β : Type v} (f : α → β) (s : Set α) (y : β), y ∈ f '' s ↔ ∃ x ∈ s, f x = y
Succeeded for Set.image_id' : ∀ {α : Type u_1} (s : Set α), (fun x => x) '' s = s
Succeeded for Set.image_id : ∀ {α : Type u_1} (s : Set α), id '' s = s
Succeeded for Set.image_subset_range : ∀ {α : Type u_1} {β : Type u_2} (f : α → β) (s : Set α), f '' s ⊆ Set.range f
Succeeded for not_exists : ∀ {α : Sort u_1} {p : α → Prop}, (¬∃ x, p x) ↔ ∀ (x : α), ¬p x
Succeeded for by_contradiction : ∀ {p : Prop}, (¬p → False) → p
Failed for CategoryTheory.Limits.Cone.w : ∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] {C : Type u₃} [inst_1 : CategoryTheory.Category.{v₃, u₃} C]
  {F : CategoryTheory.Functor J C} (c : CategoryTheory.Limits.Cone F) {j j' : J} (f : j ⟶ j'),
  CategoryTheory.CategoryStruct.comp (c.π.app j) (F.map f) = c.π.app j'
unknown universe level 'v₁'

----
Succeeded for Polynomial.coeff_add : ∀ {R : Type u} [inst : Semiring R] (p q : Polynomial R) (n : ℕ), (p + q).coeff n = p.coeff n + q.coeff n
Succeeded for Ne.lt_top : ∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderTop α] {a : α}, a ≠ ⊤ → a < ⊤
Succeeded for Real.norm_eq_abs : ∀ (r : ℝ), ‖r‖ = |r|
Failed for uniformContinuous_id : ∀ {α : Type ua} [inst : UniformSpace α], UniformContinuous id
typeclass instance problem is stuck, it is often due to metavariables
  UniformSpace ?m.471

----
Succeeded for CategoryTheory.Limits.kernel.lift_ι : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X Y : C}
  (f : X ⟶ Y) [inst_2 : CategoryTheory.Limits.HasKernel f] {W : C} (k : W ⟶ X)
  (h : CategoryTheory.CategoryStruct.comp k f = 0),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.lift f k h) (CategoryTheory.Limits.kernel.ι f) = k
Failed for continuous_mul : ∀ {M : Type u_3} [inst : TopologicalSpace M] [inst_1 : Mul M] [inst_2 : ContinuousMul M], Continuous fun p => p.1 * p.2
Invalid projection: Type of
  p
is not known; cannot resolve projection `1`
Invalid projection: Type of
  p
is not known; cannot resolve projection `2`

----
Succeeded for iInf_le_of_le : ∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {f : ι → α} {a : α} (i : ι), f i ≤ a → iInf f ≤ a
Succeeded for Equiv.symm_apply_eq : ∀ {α : Sort u_1} {β : Sort u_2} (e : α ≃ β) {x : β} {y : α}, e.symm x = y ↔ x = e y
Succeeded for mul_div_cancel : ∀ {G : Type u_3} [inst : CommGroup G] (a b : G), a * (b / a) = b
Succeeded for neg_add_self : ∀ {G : Type u_1} [inst : AddGroup G] (a : G), -a + a = 0
Succeeded for dist_eq_norm_vsub : ∀ (V : Type u_2) {P : Type u_3} [inst : SeminormedAddCommGroup V] [inst_1 : PseudoMetricSpace P]
  [inst_2 : NormedAddTorsor V P] (x y : P), dist x y = ‖x -ᵥ y‖
Succeeded for edist_nndist : ∀ {α : Type u} [inst : PseudoMetricSpace α] (x y : α), edist x y = ↑(nndist x y)
Succeeded for max_comm : ∀ {α : Type u} [inst : LinearOrder α] (a b : α), max a b = max b a
Succeeded for Eq.mpr_not : ∀ {p q : Prop}, p = q → ¬q → ¬p
Failed for Primrec.fst : ∀ {α : Type u_3} {β : Type u_4} [inst : Primcodable α] [inst_1 : Primcodable β], Primrec Prod.fst
typeclass instance problem is stuck, it is often due to metavariables
  Primcodable ?m.118

----
Succeeded for CategoryTheory.Limits.CokernelCofork.condition : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X Y : C}
  {f : X ⟶ Y} (s : CategoryTheory.Limits.CokernelCofork f),
  CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.Cofork.π s) = 0
Succeeded for Prod.ext_iff : ∀ {α : Type u_1} {β : Type u_2} {p q : α × β}, p = q ↔ p.1 = q.1 ∧ p.2 = q.2
Succeeded for add_le_add_iff_right : ∀ {α : Type u_1} [inst : Add α] [inst_1 : LE α]
  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]
  [inst_3 : ContravariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] (a : α) {b c : α},
  b + a ≤ c + a ↔ b ≤ c
Failed for right_distrib : ∀ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : RightDistribClass R] (a b c : R), (a + b) * c = a * c + b * c
unknown universe level 'x'

----
Failed for Quotient.out_eq' : ∀ {α : Sort u_1} {s₁ : Setoid α} (q : Quotient s₁), Quotient.mk'' q.out' = q
Invalid field `out'`: The environment does not contain `Quotient.out'`
  q
has type
  Quotient s₁
Invalid field `out'`: The environment does not contain `Quot.out'`
  q
has type
  Quot ⇑s₁

----
Succeeded for exists_ne : ∀ {α : Type u_1} [inst : Nontrivial α] (x : α), ∃ y, y ≠ x
Succeeded for Filter.mem_map : ∀ {α : Type u} {β : Type v} {f : Filter α} {m : α → β} {t : Set β}, t ∈ Filter.map m f ↔ m ⁻¹' t ∈ f
Succeeded for Mathlib.Data.Finset.Basic._auxLemma.80 : ∀ {α : Type u_1} [inst : DecidableEq α] {s t : Finset α} {a : α}, (a ∈ s ∪ t) = (a ∈ s ∨ a ∈ t)
Succeeded for Polynomial.map_X : ∀ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : Semiring S] (f : R →+* S),
  Polynomial.map f Polynomial.X = Polynomial.X
Succeeded for Primrec₂.comp : ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {σ : Type u_5} [inst : Primcodable α] [inst_1 : Primcodable β]
  [inst_2 : Primcodable γ] [inst_3 : Primcodable σ] {f : β → γ → σ} {g : α → β} {h : α → γ},
  Primrec₂ f → Primrec g → Primrec h → Primrec fun a => f (g a) (h a)
Succeeded for Set.MapsTo.image_subset : ∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : Set β} {f : α → β}, Set.MapsTo f s t → f '' s ⊆ t
Failed for CategoryTheory.Limits.IsLimit.hom_ext : ∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] {C : Type u₃} [inst_1 : CategoryTheory.Category.{v₃, u₃} C]
  {F : CategoryTheory.Functor J C} {t : CategoryTheory.Limits.Cone F},
  CategoryTheory.Limits.IsLimit t →
    ∀ {W : C} {f f' : W ⟶ t.pt},
      (∀ (j : J),
          CategoryTheory.CategoryStruct.comp f (t.π.app j) = CategoryTheory.CategoryStruct.comp f' (t.π.app j)) →
        f = f'
unknown universe level 'v₁'

----
Succeeded for norm_mul_le : ∀ {α : Type u_1} [inst : NonUnitalSeminormedRing α] (a b : α), ‖a * b‖ ≤ ‖a‖ * ‖b‖
Succeeded for iff_of_eq : ∀ {a b : Prop}, a = b → (a ↔ b)
Failed for Units.ne_zero : ∀ {M₀ : Type u_2} [inst : MonoidWithZero M₀] [inst_1 : Nontrivial M₀] (u : M₀ˣ), ↑u ≠ 0
failed to synthesize
  OfNat M₀ˣ 0
numerals are polymorphic in Lean, but the numeral `0` cannot be used in a context where the expected type is
  M₀ˣ
due to the absence of the instance above

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Succeeded for CategoryTheory.Preadditive.sub_comp : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Preadditive C] {P Q R : C}
  (f f' : P ⟶ Q) (g : Q ⟶ R),
  CategoryTheory.CategoryStruct.comp (f - f') g =
    CategoryTheory.CategoryStruct.comp f g - CategoryTheory.CategoryStruct.comp f' g
Succeeded for Filter.EventuallyEq.le : ∀ {α : Type u} {β : Type v} [inst : Preorder β] {l : Filter α} {f g : α → β}, l.EventuallyEq f g → l.EventuallyLE f g
Succeeded for Function.iterate_succ' : ∀ {α : Type u} (f : α → α) (n : ℕ), f^[n.succ] = f ∘ f^[n]
Succeeded for abs_of_pos : ∀ {α : Type u_1} [inst : Lattice α] [inst_1 : AddGroup α] {a : α}
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], 0 < a → |a| = a
Succeeded for Set.subset_preimage_image : ∀ {α : Type u_1} {β : Type u_2} (f : α → β) (s : Set α), s ⊆ f ⁻¹' (f '' s)
Succeeded for vsub_self : ∀ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (p : P), p -ᵥ p = 0
Succeeded for MeasurableEquiv.measurableEmbedding : ∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] (e : α ≃ᵐ β),
  MeasurableEmbedding ⇑e
Failed for UniformContinuous.continuous : ∀ {α : Type ua} {β : Type ub} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},
  UniformContinuous f → Continuous f
unknown universe level 'ua'
unknown universe level 'ub'

----
Succeeded for Multiset.prod_cons : ∀ {α : Type u_2} [inst : CommMonoid α] (a : α) (s : Multiset α), (a ::ₘ s).prod = a * s.prod
Failed for LinearMap.congr_fun : ∀ {R : Type u_1} {S : Type u_6} {M : Type u_9} {M₃ : Type u_12} [inst : Semiring R] [inst_1 : Semiring S]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₃] [inst_4 : Module R M] [inst_5 : Module S M₃] {σ : R →+* S}
  {f g : M →ₛₗ[σ] M₃}, f = g → ∀ (x : M), f x = g x
unknown universe level 'u_12'

----
Succeeded for WithTop.coe_le_coe : ∀ {α : Type u_1} {a b : α} [inst : LE α], ↑a ≤ ↑b ↔ a ≤ b
Succeeded for Finset.coe_union : ∀ {α : Type u_1} [inst : DecidableEq α] (s₁ s₂ : Finset α), ↑(s₁ ∪ s₂) = ↑s₁ ∪ ↑s₂
Succeeded for Finset.mem_image_of_mem : ∀ {α : Type u_1} {β : Type u_2} [inst : DecidableEq β] {s : Finset α} (f : α → β) {a : α},
  a ∈ s → f a ∈ Finset.image f s
Succeeded for Set.Finite.mem_toFinset : ∀ {α : Type u} {s : Set α} {a : α} (hs : s.Finite), a ∈ hs.toFinset ↔ a ∈ s
Succeeded for add_lt_add_iff_right : ∀ {α : Type u_1} [inst : Add α] [inst_1 : LT α]
  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1]
  [inst_3 : ContravariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : α) {b c : α},
  b + a < c + a ↔ b < c
Succeeded for Nat.lt_succ_of_le : ∀ {n m : ℕ}, n ≤ m → n < m.succ
Failed for sq_nonneg : ∀ {α : Type u} [inst : LinearOrderedSemiring α] [inst_1 : ExistsAddOfLE α] (a : α), 0 ≤ a ^ 2
invalid binder annotation, type is not a class instance
  LinearOrderedSemiring α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for sub_smul : ∀ {R : Type u_2} {M : Type u_5} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (r s : R) (y : M),
  (r - s) • y = r • y - s • y
Succeeded for not_le_of_lt : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → ¬b ≤ a
Succeeded for IsClosed.measurableSet : ∀ {α : Type u_1} {s : Set α} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : OpensMeasurableSpace α],
  IsClosed s → MeasurableSet s
Succeeded for Set.union_compl_self : ∀ {α : Type u} (s : Set α), s ∪ sᶜ = Set.univ
Failed for Mathlib.MeasureTheory.MeasurableSpace.Defs._auxLemma.3 : ∀ {α : Type u_1} {m : MeasurableSpace α}, MeasurableSet Set.univ = True
typeclass instance problem is stuck, it is often due to metavariables
  MeasurableSpace ?m.199

----
Failed for MeasureTheory.lintegral_congr_ae : ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f g : α → ENNReal},
  μ.ae.EventuallyEq f g → ∫⁻ (a : α), f a ∂μ = ∫⁻ (a : α), g a ∂μ
Invalid field `ae`: The environment does not contain `MeasureTheory.Measure.ae`
  μ
has type
  MeasureTheory.Measure α

----
Succeeded for add_lt_add_iff_left : ∀ {α : Type u_1} [inst : Add α] [inst_1 : LT α]
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1]
  [inst_3 : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : α) {b c : α}, a + b < a + c ↔ b < c
Succeeded for Nat.le_of_succ_le_succ : ∀ {n m : ℕ}, n.succ ≤ m.succ → n ≤ m
Succeeded for by_contra : ∀ {p : Prop}, (¬p → False) → p
Succeeded for Polynomial.C_1 : ∀ {R : Type u} [inst : Semiring R], Polynomial.C 1 = 1
Succeeded for neg_le_neg_iff : ∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]
  [inst_3 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, -a ≤ -b ↔ b ≤ a
Succeeded for zpow_zero : ∀ {G : Type u_1} [inst : DivInvMonoid G] (a : G), a ^ 0 = 1
Succeeded for negSucc_zsmul : ∀ {G : Type u_2} [inst : SubNegMonoid G] (a : G) (n : ℕ), Int.negSucc n • a = -((n + 1) • a)
Succeeded for Set.Ioo_subset_Icc_self : ∀ {α : Type u_1} [inst : Preorder α] {a b : α}, Set.Ioo a b ⊆ Set.Icc a b
Failed for convex_univ : ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E] [inst_2 : SMul 𝕜 E],
  Convex 𝕜 Set.univ
invalid binder annotation, type is not a class instance
  OrderedSemiring 𝕜

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Failed for Quotient.exact : ∀ {α : Sort u} {s : Setoid α} {a b : α}, ⟦a⟧ = ⟦b⟧ → a ≈ b
don't know how to synthesize implicit argument 'α'
  @Eq (Quotient ?m.73) ⟦a⟧ ⟦b⟧
context:
α : Sort u
s : Setoid α
a b : α
⊢ Sort u

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize placeholder for argument 's'
context:
α : Sort u
s : Setoid α
a b : α
⊢ Setoid α

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize placeholder for argument 's'
context:
α : Sort u
s : Setoid α
a b : α
⊢ Setoid α

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for Finset.filter_true_of_mem : ∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] {s : Finset α}, (∀ x ∈ s, p x) → Finset.filter p s = s
Succeeded for Finset.sum_range_succ : ∀ {β : Type u_4} [inst : AddCommMonoid β] (f : ℕ → β) (n : ℕ),
  ((Finset.range (n + 1)).sum fun x => f x) = ((Finset.range n).sum fun x => f x) + f n
Succeeded for CategoryTheory.Limits.cokernel.π_desc : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X Y : C}
  (f : X ⟶ Y) [inst_2 : CategoryTheory.Limits.HasCokernel f] {W : C} (k : Y ⟶ W)
  (h : CategoryTheory.CategoryStruct.comp f k = 0),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.π f) (CategoryTheory.Limits.cokernel.desc f k h) =
    k
Succeeded for Finset.coe_inj : ∀ {α : Type u_1} {s₁ s₂ : Finset α}, ↑s₁ = ↑s₂ ↔ s₁ = s₂
Succeeded for Units.inv_mul : ∀ {α : Type u} [inst : Monoid α] (a : αˣ), ↑a⁻¹ * ↑a = 1
Failed for MulOpposite.op_injective : ∀ {α : Type u_1}, Function.Injective MulOpposite.op
don't know how to synthesize implicit argument 'β'
  @Function.Injective ?m.14 ?m.14ᵐᵒᵖ MulOpposite.op
context:
α : Type u_1
⊢ Type ?u.9

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @Function.Injective ?m.14 ?m.14ᵐᵒᵖ MulOpposite.op
context:
α : Type u_1
⊢ Type ?u.9

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @MulOpposite.op ?m.14
context:
α : Type u_1
⊢ Type ?u.9

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for mem_interior_iff_mem_nhds : ∀ {X : Type u} {x : X} {s : Set X} [inst : TopologicalSpace X], x ∈ interior s ↔ s ∈ nhds x
Failed for abs_zero : ∀ {α : Type u_1} [inst : Lattice α] [inst_1 : AddGroup α]
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], |0| = 0
failed to synthesize
  AddGroup ℕ

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Succeeded for Disjoint.mono_right : ∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : OrderBot α] {a b c : α}, b ≤ c → Disjoint a c → Disjoint a b
Succeeded for Prod.mk.inj_iff : ∀ {α : Type u_1} {β : Type u_2} {a₁ a₂ : α} {b₁ b₂ : β}, (a₁, b₁) = (a₂, b₂) ↔ a₁ = a₂ ∧ b₁ = b₂
Succeeded for MeasureTheory.Integrable.integrableOn : ∀ {α : Type u_1} {E : Type u_3} [inst : MeasurableSpace α] [inst_1 : NormedAddCommGroup E] {f : α → E} {s : Set α}
  {μ : MeasureTheory.Measure α}, MeasureTheory.Integrable f μ → MeasureTheory.IntegrableOn f s μ
Succeeded for by_cases : ∀ {p q : Prop}, (p → q) → (¬p → q) → q
Failed for Filter.principal_univ : ∀ {α : Type u}, Filter.principal Set.univ = ⊤
don't know how to synthesize implicit argument 'α'
  @Eq (Filter ?m.240) (Filter.principal Set.univ) ⊤
context:
α : Type u
⊢ Type ?u.8

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'self'
  @Top.top (Filter ?m.240) Filter.instTop
context:
α : Type u
⊢ Top (Filter ?m.240)

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @Top.top (Filter ?m.240) Filter.instTop
context:
α : Type u
⊢ Type ?u.8

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @Filter.principal ?m.240 Set.univ
context:
α : Type u
⊢ Type ?u.8

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @Set.univ ?m.240
context:
α : Type u
⊢ Type ?u.8

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for Filter.Eventually.filter_mono : ∀ {α : Type u} {f₁ f₂ : Filter α}, f₁ ≤ f₂ → ∀ {p : α → Prop}, (∀ᶠ (x : α) in f₂, p x) → ∀ᶠ (x : α) in f₁, p x
Succeeded for lt_iff_le_not_le : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b ↔ a ≤ b ∧ ¬b ≤ a
Succeeded for Set.Finite.image : ∀ {α : Type u} {β : Type v} {s : Set α} (f : α → β), s.Finite → (f '' s).Finite
Succeeded for ContinuousLinearMap.continuous : ∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ₁₂ : R₁ →+* R₂} {M₁ : Type u_4}
  [inst_2 : TopologicalSpace M₁] [inst_3 : AddCommMonoid M₁] {M₂ : Type u_6} [inst_4 : TopologicalSpace M₂]
  [inst_5 : AddCommMonoid M₂] [inst_6 : Module R₁ M₁] [inst_7 : Module R₂ M₂] (f : M₁ →SL[σ₁₂] M₂), Continuous ⇑f
Succeeded for Set.compl_subset_compl : ∀ {α : Type u} {s t : Set α}, sᶜ ⊆ tᶜ ↔ t ⊆ s
Succeeded for Quotient.inductionOn₂' : ∀ {α : Sort u_1} {β : Sort u_2} {s₁ : Setoid α} {s₂ : Setoid β} {p : Quotient s₁ → Quotient s₂ → Prop}
  (q₁ : Quotient s₁) (q₂ : Quotient s₂), (∀ (a₁ : α) (a₂ : β), p (Quotient.mk'' a₁) (Quotient.mk'' a₂)) → p q₁ q₂
Succeeded for Equiv.apply_eq_iff_eq_symm_apply : ∀ {α : Sort u} {β : Sort v} {x : α} {y : β} (f : α ≃ β), f x = y ↔ x = f.symm y
Failed for one_nsmul : ∀ {A : Type y} [inst : AddMonoid A] (a : A), 1 • a = a
unknown universe level 'y'

----
Succeeded for ContinuousAt.comp : ∀ {X : Type u_1} {Y : Type u_2} {Z : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]
  [inst_2 : TopologicalSpace Z] {f : X → Y} {x : X} {g : Y → Z},
  ContinuousAt g (f x) → ContinuousAt f x → ContinuousAt (g ∘ f) x
Succeeded for neg_div : ∀ {K : Type u_3} [inst : DivisionMonoid K] [inst_1 : HasDistribNeg K] (a b : K), -b / a = -(b / a)
Succeeded for Monotone.comp : ∀ {α : Type u} {β : Type v} {γ : Type w} [inst : Preorder α] [inst_1 : Preorder β] [inst_2 : Preorder γ] {g : β → γ}
  {f : α → β}, Monotone g → Monotone f → Monotone (g ∘ f)
Failed for Polynomial.aeval_def : ∀ {R : Type u} {A : Type z} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (x : A)
  (p : Polynomial R), (Polynomial.aeval x) p = Polynomial.eval₂ (algebraMap R A) x p
unknown universe level 'z'

----
Failed for LinearMap.ext_ring : ∀ {R : Type u_1} {S : Type u_6} {M₃ : Type u_12} [inst : Semiring R] [inst_1 : Semiring S] [inst_2 : AddCommMonoid M₃]
  [inst_3 : Module S M₃] {σ : R →+* S} {f g : R →ₛₗ[σ] M₃}, f 1 = g 1 → f = g
unknown universe level 'u_12'

----
Succeeded for Filter.comap_principal : ∀ {α : Type u} {β : Type v} {m : α → β} {t : Set β}, Filter.comap m (Filter.principal t) = Filter.principal (m ⁻¹' t)
Succeeded for Set.left_mem_Icc : ∀ {α : Type u_1} [inst : Preorder α] {a b : α}, a ∈ Set.Icc a b ↔ a ≤ b
Failed for MeasureTheory.OuterMeasure.empty' : ∀ {α : Type u_1} (m : MeasureTheory.OuterMeasure α), ↑m ∅ = 0
invalid coercion notation, expected type is not known

----
Succeeded for CategoryTheory.Limits.PullbackCone.condition : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z}
  (t : CategoryTheory.Limits.PullbackCone f g),
  CategoryTheory.CategoryStruct.comp t.fst f = CategoryTheory.CategoryStruct.comp t.snd g
Succeeded for MulEquiv.apply_symm_apply : ∀ {M : Type u_6} {N : Type u_7} [inst : Mul M] [inst_1 : Mul N] (e : M ≃* N) (y : N), e (e.symm y) = y
Succeeded for Nat.cast_pow : ∀ {α : Type u_1} [inst : Semiring α] (m n : ℕ), ↑(m ^ n) = ↑m ^ n
Succeeded for Filter.Tendsto.congr' : ∀ {α : Type u} {β : Type v} {f₁ f₂ : α → β} {l₁ : Filter α} {l₂ : Filter β},
  l₁.EventuallyEq f₁ f₂ → Filter.Tendsto f₁ l₁ l₂ → Filter.Tendsto f₂ l₁ l₂
Failed for PowerSeries.ext : ∀ {R : Type u_1} [inst : Semiring R] {φ ψ : PowerSeries R},
  (∀ (n : ℕ), (PowerSeries.coeff R n) φ = (PowerSeries.coeff R n) ψ) → φ = ψ
unexpected token 'φ'; expected '_' or identifier

----
Succeeded for Int.cast_mul : ∀ {α : Type u_1} [inst : NonAssocRing α] (m n : ℤ), ↑(m * n) = ↑m * ↑n
Failed for CategoryTheory.NatTrans.naturality_assoc : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  {F G : CategoryTheory.Functor C D} (self : F.NatTrans G) ⦃X Y : C⦄ (f : X ⟶ Y) {Z : D} (h : G.obj Y ⟶ Z),
  CategoryTheory.CategoryStruct.comp (F.map f) (CategoryTheory.CategoryStruct.comp (self.app Y) h) =
    CategoryTheory.CategoryStruct.comp (self.app X) (CategoryTheory.CategoryStruct.comp (G.map f) h)
Invalid field `NatTrans`: The environment does not contain `CategoryTheory.Functor.NatTrans`
  F
has type
  CategoryTheory.Functor C D

----
Succeeded for OrderIso.apply_symm_apply : ∀ {α : Type u_2} {β : Type u_3} [inst : LE α] [inst_1 : LE β] (e : α ≃o β) (x : β), e (e.symm x) = x
Succeeded for norm_mul : ∀ {α : Type u_1} [inst : NormedDivisionRing α] (a b : α), ‖a * b‖ = ‖a‖ * ‖b‖
Succeeded for Set.mem_image2_of_mem : ∀ {α : Type u} {β : Type v} {γ : Type w} {f : α → β → γ} {s : Set α} {t : Set β} {a : α} {b : β},
  a ∈ s → b ∈ t → f a b ∈ Set.image2 f s t
Succeeded for inf_of_le_right : ∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, b ≤ a → a ⊓ b = b
Failed for Set.finite_singleton : ∀ {α : Type u} (a : α), {a}.Finite
overloaded, errors 
  Invalid field notation: Type of
    {a}
  is not known; cannot resolve field `Finite`
  
  invalid {...} notation, expected type is not known

----
Succeeded for Polynomial.eval_mul : ∀ {R : Type u} [inst : CommSemiring R] {p q : Polynomial R} {x : R},
  Polynomial.eval x (p * q) = Polynomial.eval x p * Polynomial.eval x q
Succeeded for MeasurableSet.iUnion : ∀ {α : Type u_1} {ι : Sort u_6} {m : MeasurableSpace α} [inst : Countable ι] ⦃f : ι → Set α⦄,
  (∀ (b : ι), MeasurableSet (f b)) → MeasurableSet (⋃ b, f b)
Succeeded for Int.zero_add : ∀ (a : ℤ), 0 + a = a
Succeeded for Mathlib.Data.Finset.Prod._auxLemma.1 : ∀ {α : Type u_1} {β : Type u_2} {s : Finset α} {t : Finset β} {p : α × β}, (p ∈ s ×ˢ t) = (p.1 ∈ s ∧ p.2 ∈ t)
Succeeded for Polynomial.eval_sub : ∀ {R : Type u} [inst : Ring R] (p q : Polynomial R) (x : R),
  Polynomial.eval x (p - q) = Polynomial.eval x p - Polynomial.eval x q
Succeeded for continuousOn_const : ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set α} {c : β},
  ContinuousOn (fun x => c) s
Succeeded for MeasureTheory.StronglyMeasurable.aestronglyMeasurable : ∀ {α : Type u_5} {β : Type u_6} {x : MeasurableSpace α} [inst : TopologicalSpace β] {f : α → β}
  {μ : MeasureTheory.Measure α}, MeasureTheory.StronglyMeasurable f → MeasureTheory.AEStronglyMeasurable f μ
Succeeded for sup_eq_left : ∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ⊔ b = a ↔ b ≤ a
Succeeded for neg_add : ∀ {α : Type u_1} [inst : SubtractionCommMonoid α] (a b : α), -(a + b) = -a + -b
Succeeded for le_add_of_nonneg_right : ∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LE α]
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, 0 ≤ b → a ≤ a + b
Failed for div_le_iff : ∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a b c : α}, 0 < b → (a / b ≤ c ↔ a ≤ c * b)
invalid binder annotation, type is not a class instance
  LinearOrderedSemifield α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for Mathlib.Algebra.Divisibility.Basic._auxLemma.2 : ∀ {α : Type u_1} [inst : Monoid α] (a : α), (a ∣ a) = True
Succeeded for nhdsWithin_mono : ∀ {α : Type u_1} [inst : TopologicalSpace α] (a : α) {s t : Set α}, s ⊆ t → nhdsWithin a s ≤ nhdsWithin a t
Succeeded for iff_of_true : ∀ {a b : Prop}, a → b → (a ↔ b)
Succeeded for Set.mem_iInter : ∀ {α : Type u} {ι : Sort v} {x : α} {s : ι → Set α}, x ∈ ⋂ i, s i ↔ ∀ (i : ι), x ∈ s i
Succeeded for Nat.gcd_dvd_right : ∀ (m n : ℕ), m.gcd n ∣ n
Succeeded for Int.coe_nat_dvd : ∀ {m n : ℕ}, ↑m ∣ ↑n ↔ m ∣ n
Succeeded for SetLike.le_def : ∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {S T : A}, S ≤ T ↔ ∀ ⦃x : B⦄, x ∈ S → x ∈ T
Succeeded for false_iff : ∀ (p : Prop), (False ↔ p) = ¬p
Failed for CategoryTheory.Iso.hom_inv_id_app : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  {F G : CategoryTheory.Functor C D} (α : F ≅ G) (X : C),
  CategoryTheory.CategoryStruct.comp (α.hom.app X) (α.inv.app X) = CategoryTheory.CategoryStruct.id (F.obj X)
unknown universe level 'v₁'

----
Succeeded for eq_of_forall_le_iff : ∀ {α : Type u} [inst : PartialOrder α] {a b : α}, (∀ (c : α), c ≤ a ↔ c ≤ b) → a = b
Succeeded for Set.union_subset : ∀ {α : Type u} {s t r : Set α}, s ⊆ r → t ⊆ r → s ∪ t ⊆ r
Succeeded for Exists.fst : ∀ {b : Prop} {p : b → Prop}, Exists p → b
Succeeded for Polynomial.C_0 : ∀ {R : Type u} [inst : Semiring R], Polynomial.C 0 = 0
Succeeded for sdiff_le : ∀ {α : Type u_2} [inst : GeneralizedCoheytingAlgebra α] {a b : α}, a \ b ≤ a
Succeeded for one_dvd : ∀ {α : Type u_1} [inst : Monoid α] (a : α), 1 ∣ a
Failed for CategoryTheory.Limits.HasLimit.mk : ∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] {C : Type u} [inst_1 : CategoryTheory.Category.{v, u} C]
  {F : CategoryTheory.Functor J C}, CategoryTheory.Limits.LimitCone F → CategoryTheory.Limits.HasLimit F
unknown universe level 'v₁'

----
Succeeded for IsOpen.interior_eq : ∀ {X : Type u} {s : Set X} [inst : TopologicalSpace X], IsOpen s → interior s = s
Failed for Subtype.coe_mk : ∀ {α : Sort u_1} {p : α → Prop} (a : α) (h : p a), ↑⟨a, h⟩ = a
invalid constructor ⟨...⟩, expected type must be an inductive type 
  α

----
Succeeded for IsCompl.symm : ∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : BoundedOrder α] {x y : α}, IsCompl x y → IsCompl y x
Succeeded for StrictMono.lt_iff_lt : ∀ {α : Type u} {β : Type v} [inst : LinearOrder α] [inst_1 : Preorder β] {f : α → β},
  StrictMono f → ∀ {a b : α}, f a < f b ↔ a < b
Succeeded for Set.subset_insert : ∀ {α : Type u} (x : α) (s : Set α), s ⊆ insert x s
Succeeded for TrivSqZeroExt.ext : ∀ {R : Type u} {M : Type v} {x y : TrivSqZeroExt R M}, x.fst = y.fst → x.snd = y.snd → x = y
Succeeded for one_lt_two : ∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [inst_2 : ZeroLEOneClass α] [inst_3 : NeZero 1]
  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1], 1 < 2
Succeeded for Filter.tendsto_comap_iff : ∀ {α : Type u} {β : Type v} {γ : Type w} {f : α → β} {g : β → γ} {a : Filter α} {c : Filter γ},
  Filter.Tendsto f a (Filter.comap g c) ↔ Filter.Tendsto (g ∘ f) a c
Failed for MeasureTheory.Measure.restrict_congr_set : ∀ {α : Type u_2} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s t : Set α},
  μ.ae.EventuallyEq s t → μ.restrict s = μ.restrict t
Invalid field `ae`: The environment does not contain `MeasureTheory.Measure.ae`
  μ
has type
  MeasureTheory.Measure α

----
Succeeded for RelEmbedding.injective : ∀ {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} (f : r ↪r s), Function.Injective ⇑f
Succeeded for Filter.HasBasis.tendsto_iff : ∀ {α : Type u_1} {β : Type u_2} {ι : Sort u_4} {ι' : Sort u_5} {la : Filter α} {pa : ι → Prop} {sa : ι → Set α}
  {lb : Filter β} {pb : ι' → Prop} {sb : ι' → Set β} {f : α → β},
  la.HasBasis pa sa →
    lb.HasBasis pb sb → (Filter.Tendsto f la lb ↔ ∀ (ib : ι'), pb ib → ∃ ia, pa ia ∧ ∀ x ∈ sa ia, f x ∈ sb ib)
Succeeded for Nat.card_congr : ∀ {α : Type u_1} {β : Type u_2}, α ≃ β → Nat.card α = Nat.card β
Succeeded for And.imp : ∀ {a c b d : Prop}, (a → c) → (b → d) → a ∧ b → c ∧ d
Succeeded for add_le_add_iff_left : ∀ {α : Type u_1} [inst : Add α] [inst_1 : LE α]
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]
  [inst_3 : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] (a : α) {b c : α}, a + b ≤ a + c ↔ b ≤ c
Succeeded for HahnSeries.ext : ∀ {Γ : Type u_1} {R : Type u_2} {inst : PartialOrder Γ} {inst_1 : Zero R} (x y : HahnSeries Γ R),
  x.coeff = y.coeff → x = y
Succeeded for two_nsmul : ∀ {M : Type u} [inst : AddMonoid M] (a : M), 2 • a = a + a
Succeeded for Primrec.to_comp : ∀ {α : Type u_1} {σ : Type u_2} [inst : Primcodable α] [inst_1 : Primcodable σ] {f : α → σ}, Primrec f → Computable f
Failed for CategoryTheory.Iso.inv_hom_id_app : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  {F G : CategoryTheory.Functor C D} (α : F ≅ G) (X : C),
  CategoryTheory.CategoryStruct.comp (α.inv.app X) (α.hom.app X) = CategoryTheory.CategoryStruct.id (G.obj X)
unknown universe level 'v₁'

----
Succeeded for AddEquiv.ext : ∀ {M : Type u_6} {N : Type u_7} [inst : Add M] [inst_1 : Add N] {f g : M ≃+ N}, (∀ (x : M), f x = g x) → f = g
Failed for le_div_iff : ∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a b c : α}, 0 < c → (a ≤ b / c ↔ a * c ≤ b)
invalid binder annotation, type is not a class instance
  LinearOrderedSemifield α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for Complex.ofReal_neg : ∀ (r : ℝ), ↑(-r) = -↑r
Succeeded for of_not_not : ∀ {a : Prop}, ¬¬a → a
Succeeded for Function.Injective.ne_iff : ∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.Injective f → ∀ {x y : α}, f x ≠ f y ↔ x ≠ y
Succeeded for OrderIso.symm_apply_apply : ∀ {α : Type u_2} {β : Type u_3} [inst : LE α] [inst_1 : LE β] (e : α ≃o β) (x : α), e.symm (e x) = x
Succeeded for Quot.induction_on : ∀ {α : Sort u_4} {r : α → α → Prop} {β : Quot r → Prop} (q : Quot r), (∀ (a : α), β (Quot.mk r a)) → β q
Succeeded for Set.not_nonempty_iff_eq_empty : ∀ {α : Type u} {s : Set α}, ¬s.Nonempty ↔ s = ∅
Failed for CategoryTheory.Limits.colimit.hom_ext : ∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] {C : Type u} [inst_1 : CategoryTheory.Category.{v, u} C]
  {F : CategoryTheory.Functor J C} [inst_2 : CategoryTheory.Limits.HasColimit F] {X : C}
  {f f' : CategoryTheory.Limits.colimit F ⟶ X},
  (∀ (j : J),
      CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) f =
        CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F j) f') →
    f = f'
unknown universe level 'v₁'

----
Succeeded for add_neg_cancel_right : ∀ {G : Type u_1} [inst : AddGroup G] (a b : G), a + b + -b = a
Succeeded for Set.sUnion_eq_biUnion : ∀ {α : Type u_1} {s : Set (Set α)}, s.sUnion = ⋃ i ∈ s, i
Failed for smul_one_smul : ∀ {α : Type u_6} {M : Type u_10} (N : Type u_11) [inst : Monoid N] [inst_1 : SMul M N] [inst_2 : MulAction N α]
  [inst_3 : SMul M α] [inst_4 : IsScalarTower M N α] (x : M) (y : α), (x • 1) • y = x • y
failed to synthesize
  HSMul M ℕ (?m.3782 N x y)

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Succeeded for CategoryTheory.leOfHom : ∀ {X : Type u} [inst : Preorder X] {x y : X}, (x ⟶ y) → x ≤ y
Failed for CategoryTheory.Limits.IsInitial.hom_ext : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X Y : C},
  CategoryTheory.Limits.IsInitial X → ∀ (f g : X ⟶ Y), f = g
unknown universe level 'v₁'

----
Succeeded for WithBot.coe_lt_coe : ∀ {α : Type u_1} {a b : α} [inst : LT α], ↑a < ↑b ↔ a < b
Succeeded for Mathlib.Algebra.Order.ZeroLEOne._auxLemma.1 : ∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : LE α] [inst_3 : ZeroLEOneClass α], (0 ≤ 1) = True
Failed for Pi.zero_apply : ∀ {I : Type u} {f : I → Type v₁} (i : I) [inst : (i : I) → Zero (f i)], 0 i = 0
Function expected at
  0
but this term has type
  ?m.652

Note: Expected a function because this term is being applied to the argument
  i

----
Succeeded for inf_eq_right : ∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b = b ↔ b ≤ a
Succeeded for Filter.HasBasis.tendsto_right_iff : ∀ {α : Type u_1} {β : Type u_2} {ι' : Sort u_5} {la : Filter α} {lb : Filter β} {pb : ι' → Prop} {sb : ι' → Set β}
  {f : α → β}, lb.HasBasis pb sb → (Filter.Tendsto f la lb ↔ ∀ (i : ι'), pb i → ∀ᶠ (x : α) in la, f x ∈ sb i)
Succeeded for Function.Bijective.injective : ∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.Bijective f → Function.Injective f
Succeeded for Finset.coe_Icc : ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : LocallyFiniteOrder α] (a b : α), ↑(Finset.Icc a b) = Set.Icc a b
Succeeded for MeasureTheory.subset_toMeasurable : ∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α),
  s ⊆ MeasureTheory.toMeasurable μ s
Succeeded for Finset.sum_eq_zero : ∀ {α : Type u_3} {β : Type u_4} [inst : AddCommMonoid β] {f : α → β} {s : Finset α},
  (∀ x ∈ s, f x = 0) → (s.sum fun x => f x) = 0
Succeeded for Mathlib.Data.ENNReal.Basic._auxLemma.19 : ∀ {r q : NNReal}, (↑r ≤ ↑q) = (r ≤ q)
Failed for Ordinal.type_lt : ∀ (o : Ordinal.{u_3}), (Ordinal.type fun x x_1 => x < x_1) = o
typeclass instance problem is stuck, it is often due to metavariables
  IsWellOrder (?m.373 o) fun x x_1 => x < x_1

----
Succeeded for add_right_cancel : ∀ {G : Type u_1} [inst : Add G] [inst_1 : IsRightCancelAdd G] {a b c : G}, a + b = c + b → a = c
Succeeded for HomologicalComplex.d_comp_d : ∀ {ι : Type u_1} {V : Type u} [inst : CategoryTheory.Category.{v, u} V]
  [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] {c : ComplexShape ι} (C : HomologicalComplex V c) (i j k : ι),
  CategoryTheory.CategoryStruct.comp (C.d i j) (C.d j k) = 0
Succeeded for lt_iff_le_and_ne : ∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a < b ↔ a ≤ b ∧ a ≠ b
Succeeded for MeasureTheory.measurableSet_toMeasurable : ∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α),
  MeasurableSet (MeasureTheory.toMeasurable μ s)
Succeeded for surjective_quot_mk : ∀ {α : Sort u_1} (r : α → α → Prop), Function.Surjective (Quot.mk r)
Succeeded for AlternatingMap.ext : ∀ {R : Type u_1} [inst : Semiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_3}
  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {ι : Type u_7} {f f' : M [⋀^ι]→ₗ[R] N},
  (∀ (x : ι → M), f x = f' x) → f = f'
Succeeded for Mathlib.Order.SetNotation._auxLemma.4 : ∀ {α : Type u} {ι : Sort v} {x : α} {s : ι → Set α}, (x ∈ ⋂ i, s i) = ∀ (i : ι), x ∈ s i
Succeeded for Set.empty_union : ∀ {α : Type u} (a : Set α), ∅ ∪ a = a
Succeeded for Complex.ofReal_add : ∀ (r s : ℝ), ↑(r + s) = ↑r + ↑s
Failed for tsub_eq_zero_iff_le : ∀ {α : Type u_1} [inst : CanonicallyOrderedAddCommMonoid α] [inst_1 : Sub α] [inst_2 : OrderedSub α] {a b : α},
  a - b = 0 ↔ a ≤ b
invalid binder annotation, type is not a class instance
  CanonicallyOrderedAddCommMonoid α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for Submodule.zero_mem : ∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : Module R M} (p : Submodule R M),
  0 ∈ p
Succeeded for dist_triangle : ∀ {α : Type u} [inst : PseudoMetricSpace α] (x y z : α), dist x z ≤ dist x y + dist y z
Succeeded for Set.image_neg : ∀ {α : Type u_2} [inst : InvolutiveNeg α] {s : Set α}, Neg.neg '' s = -s
Succeeded for Cardinal.lift_le : ∀ {a b : Cardinal.{v}}, Cardinal.lift.{u, v} a ≤ Cardinal.lift.{u, v} b ↔ a ≤ b
Succeeded for Continuous.comp' : ∀ {X : Type u_1} {Y : Type u_2} {Z : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]
  [inst_2 : TopologicalSpace Z] {f : X → Y} {g : Y → Z}, Continuous g → Continuous f → Continuous fun x => g (f x)
Succeeded for List.Sublist.subset : ∀ {α : Type u_1} {l₁ l₂ : List α}, l₁.Sublist l₂ → l₁ ⊆ l₂
Succeeded for Quotient.ind' : ∀ {α : Sort u_1} {s₁ : Setoid α} {p : Quotient s₁ → Prop}, (∀ (a : α), p (Quotient.mk'' a)) → ∀ (q : Quotient s₁), p q
Failed for MeasurableSet.empty : ∀ {α : Type u_1} [inst : MeasurableSpace α], MeasurableSet ∅
typeclass instance problem is stuck, it is often due to metavariables
  MeasurableSpace ?m.237

----
Failed for continuous_induced_dom : ∀ {α : Type u} {β : Type v} {f : α → β} {t : TopologicalSpace β}, Continuous f
failed to synthesize
  TopologicalSpace α

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Succeeded for map_inv₀ : ∀ {G₀ : Type u_3} {G₀' : Type u_5} {F : Type u_6} [inst : GroupWithZero G₀] [inst_1 : GroupWithZero G₀']
  [inst_2 : FunLike F G₀ G₀'] [inst_3 : MonoidWithZeroHomClass F G₀ G₀'] (f : F) (a : G₀), f a⁻¹ = (f a)⁻¹
Failed for Continuous.prod_map : ∀ {X : Type u} {Y : Type v} {Z : Type u_1} {W : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]
  [inst_2 : TopologicalSpace Z] [inst_3 : TopologicalSpace W] {f : Z → X} {g : W → Y},
  Continuous f → Continuous g → Continuous fun p => (f p.1, g p.2)
Invalid projection: Type of
  p
is not known; cannot resolve projection `1`
Invalid projection: Type of
  p
is not known; cannot resolve projection `2`

----
Succeeded for Ideal.mem_span_singleton : ∀ {α : Type u} [inst : CommSemiring α] {x y : α}, x ∈ Ideal.span {y} ↔ y ∣ x
Succeeded for AddSubgroup.ext : ∀ {G : Type u_1} [inst : AddGroup G] {H K : AddSubgroup G}, (∀ (x : G), x ∈ H ↔ x ∈ K) → H = K
Failed for left_distrib : ∀ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : LeftDistribClass R] (a b c : R), a * (b + c) = a * b + a * c
unknown universe level 'x'

----
Succeeded for add_left_cancel : ∀ {G : Type u_1} [inst : Add G] [inst_1 : IsLeftCancelAdd G] {a b c : G}, a + b = a + c → b = c
Failed for LinearMap.range_eq_top : ∀ {R : Type u_1} {R₂ : Type u_2} {M : Type u_6} {M₂ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R₂]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : Module R M] [inst_5 : Module R₂ M₂] {τ₁₂ : R →+* R₂}
  {F : Type u_11} [inst_6 : FunLike F M M₂] [inst_7 : SemilinearMapClass F τ₁₂ M M₂] [inst_8 : RingHomSurjective τ₁₂]
  {f : F}, LinearMap.range f = ⊤ ↔ Function.Surjective ⇑f
unknown universe level 'u_11'

----
Succeeded for AddSubmonoid.subset_closure : ∀ {M : Type u_1} [inst : AddZeroClass M] {s : Set M}, s ⊆ ↑(AddSubmonoid.closure s)
Succeeded for Set.coe_toFinset : ∀ {α : Type u_1} (s : Set α) [inst : Fintype ↑s], ↑s.toFinset = s
Succeeded for mul_div_cancel' : ∀ {G₀ : Type u_3} [inst : CommGroupWithZero G₀] {b : G₀} (a : G₀), b ≠ 0 → b * (a / b) = a
Succeeded for Set.right_mem_Icc : ∀ {α : Type u_1} [inst : Preorder α] {a b : α}, b ∈ Set.Icc a b ↔ a ≤ b
Succeeded for ENNReal.toReal_nonneg : ∀ {a : ENNReal}, 0 ≤ a.toReal
Succeeded for Rat.cast_coe_int : ∀ {α : Type u_3} [inst : DivisionRing α] (n : ℤ), ↑↑n = ↑n
Succeeded for Mathlib.Data.Finset.Basic._auxLemma.92 : ∀ {a b : Prop}, (a ∧ b) = (b ∧ a)
Succeeded for Finset.coe_Ico : ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : LocallyFiniteOrder α] (a b : α), ↑(Finset.Ico a b) = Set.Ico a b
Failed for MeasureTheory.measure_toMeasurable : ∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} (s : Set α),
  ↑↑μ (MeasureTheory.toMeasurable μ s) = ↑↑μ s
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known

----
Succeeded for Nat.cast_inj : ∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] {m n : ℕ}, ↑m = ↑n ↔ m = n
Succeeded for csInf_le : ∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {a : α}, BddBelow s → a ∈ s → sInf s ≤ a
Failed for SetLike.coe_subset_coe : ∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {S T : A}, ↑S ⊆ ↑T ↔ S ≤ T
failed to synthesize
  HasSubset A

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Succeeded for IsCompact.of_isClosed_subset : ∀ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t
Succeeded for Set.prod_mono : ∀ {α : Type u_1} {β : Type u_2} {s₁ s₂ : Set α} {t₁ t₂ : Set β}, s₁ ⊆ s₂ → t₁ ⊆ t₂ → s₁ ×ˢ t₁ ⊆ s₂ ×ˢ t₂
Succeeded for Subgroup.ext : ∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, (∀ (x : G), x ∈ H ↔ x ∈ K) → H = K
Succeeded for le_csSup : ∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {a : α}, BddAbove s → a ∈ s → a ≤ sSup s
Succeeded for inf_top_eq : ∀ {α : Type u} [inst : SemilatticeInf α] [inst_1 : OrderTop α] (a : α), a ⊓ ⊤ = a
Succeeded for LinearEquiv.apply_symm_apply : ∀ {R : Type u_1} {S : Type u_6} {M : Type u_7} {M₂ : Type u_9} [inst : Semiring R] [inst_1 : Semiring S]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] {module_M : Module R M} {module_S_M₂ : Module S M₂}
  {σ : R →+* S} {σ' : S →+* R} {re₁ : RingHomInvPair σ σ'} {re₂ : RingHomInvPair σ' σ} (e : M ≃ₛₗ[σ] M₂) (c : M₂),
  e (e.symm c) = c
Succeeded for AddMonoidHom.map_neg : ∀ {α : Type u_2} {β : Type u_3} [inst : AddGroup α] [inst_1 : SubtractionMonoid β] (f : α →+ β) (a : α), f (-a) = -f a
Failed for Orientation.oangle_rev : ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]
  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V),
  o.oangle y x = -o.oangle x y
unknown constant 'FiniteDimensional.finrank'
failed to synthesize
  Fact (Module.finrank ℝ V = 2)

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.
failed to synthesize
  Fact (Module.finrank ℝ V = 2)

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Succeeded for Function.bijective_iff_has_inverse : ∀ {α : Sort u} {β : Sort v} {f : α → β},
  Function.Bijective f ↔ ∃ g, Function.LeftInverse g f ∧ Function.RightInverse g f
Succeeded for true_iff : ∀ (p : Prop), (True ↔ p) = p
Succeeded for MeasureTheory.Integrable.aestronglyMeasurable : ∀ {α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} [inst : NormedAddCommGroup β]
  {f : α → β}, MeasureTheory.Integrable f μ → MeasureTheory.AEStronglyMeasurable f μ
Succeeded for mul_invOf_self : ∀ {α : Type u} [inst : Mul α] [inst_1 : One α] (a : α) [inst_2 : Invertible a], a * ⅟a = 1
Succeeded for Finset.induction : ∀ {α : Type u_4} {p : Finset α → Prop} [inst : DecidableEq α],
  p ∅ → (∀ ⦃a : α⦄ {s : Finset α}, a ∉ s → p s → p (insert a s)) → ∀ (s : Finset α), p s
Succeeded for sub_eq_iff_eq_add : ∀ {G : Type u_3} [inst : AddGroup G] {a b c : G}, a - b = c ↔ a = c + b
Succeeded for Multiset.mem_cons_self : ∀ {α : Type u_1} (a : α) (s : Multiset α), a ∈ a ::ₘ s
Succeeded for Filter.eventually_ge_atTop : ∀ {α : Type u_3} [inst : Preorder α] (a : α), ∀ᶠ (x : α) in Filter.atTop, a ≤ x
Succeeded for SimpleGraph.ext : ∀ {V : Type u} (x y : SimpleGraph V), x.Adj = y.Adj → x = y
Succeeded for norm_inv : ∀ {α : Type u_1} [inst : NormedDivisionRing α] (a : α), ‖a⁻¹‖ = ‖a‖⁻¹
Succeeded for GaloisConnection.l_le : ∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α},
  GaloisConnection l u → ∀ {a : α} {b : β}, a ≤ u b → l a ≤ b
Succeeded for Sym2.ind : ∀ {α : Type u_1} {f : Sym2 α → Prop}, (∀ (x y : α), f s(x, y)) → ∀ (i : Sym2 α), f i
Succeeded for star_zero : ∀ (R : Type u) [inst : AddMonoid R] [inst_1 : StarAddMonoid R], star 0 = 0
Succeeded for HasFDerivWithinAt.fderivWithin : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}
  {f' : E →L[𝕜] F} {x : E} {s : Set E},
  HasFDerivWithinAt f f' s x → UniqueDiffWithinAt 𝕜 s x → fderivWithin 𝕜 f s x = f'
Failed for pure_le_nhds : ∀ {X : Type u} [inst : TopologicalSpace X], pure ≤ nhds
typeclass instance problem is stuck, it is often due to metavariables
  TopologicalSpace ?m.955

----
Succeeded for Real.norm_of_nonneg : ∀ {r : ℝ}, 0 ≤ r → ‖r‖ = r
Failed for Submodule.mem_bot : ∀ (R : Type u_1) {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {x : M},
  x ∈ ⊥ ↔ x = 0
typeclass instance problem is stuck, it is often due to metavariables
  Membership M (?m.1165 R)

----
Succeeded for Set.Nonempty.image : ∀ {α : Type u_1} {β : Type u_2} (f : α → β) {s : Set α}, s.Nonempty → (f '' s).Nonempty
Succeeded for CategoryTheory.MonoidalCategory.whiskerLeft_comp : ∀ {C : Type u} [𝒞 : CategoryTheory.Category.{v, u} C] [inst : CategoryTheory.MonoidalCategory C] (W : C) {X Y Z : C}
  (f : X ⟶ Y) (g : Y ⟶ Z),
  CategoryTheory.MonoidalCategory.whiskerLeft W (CategoryTheory.CategoryStruct.comp f g) =
    CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.whiskerLeft W f)
      (CategoryTheory.MonoidalCategory.whiskerLeft W g)
Failed for Fintype.card_ofFinset : ∀ {α : Type u_1} {p : Set α} (s : Finset α) (H : ∀ (x : α), x ∈ s ↔ x ∈ p), Fintype.card ↑p = s.card
failed to synthesize
  Fintype ↑p

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Succeeded for OrderHom.monotone : ∀ {α : Type u_2} {β : Type u_3} [inst : Preorder α] [inst_1 : Preorder β] (f : α →o β), Monotone ⇑f
Succeeded for Nat.succ_mul : ∀ (n m : ℕ), n.succ * m = n * m + m
Succeeded for Order.succ_le_of_lt : ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : SuccOrder α] {a b : α}, a < b → Order.succ a ≤ b
Succeeded for Eq.symm : ∀ {α : Sort u} {a b : α}, a = b → b = a
Failed for CategoryTheory.Limits.limit.hom_ext : ∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] {C : Type u} [inst_1 : CategoryTheory.Category.{v, u} C]
  {F : CategoryTheory.Functor J C} [inst_2 : CategoryTheory.Limits.HasLimit F] {X : C}
  {f f' : X ⟶ CategoryTheory.Limits.limit F},
  (∀ (j : J),
      CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.limit.π F j) =
        CategoryTheory.CategoryStruct.comp f' (CategoryTheory.Limits.limit.π F j)) →
    f = f'
unknown universe level 'v₁'

----
Succeeded for Set.mem_Ioi : ∀ {α : Type u_1} [inst : Preorder α] {a x : α}, x ∈ Set.Ioi a ↔ a < x
Failed for AlgHom.map_mul : ∀ {R : Type u} {A : Type v} {B : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Semiring B]
  [inst_3 : Algebra R A] [inst_4 : Algebra R B] (φ : A →ₐ[R] B) (x y : A), φ (x * y) = φ x * φ y
unexpected token 'φ'; expected '_' or identifier

----
Succeeded for sSup_image : ∀ {α : Type u_1} {β : Type u_2} [inst : CompleteLattice α] {s : Set β} {f : β → α}, sSup (f '' s) = ⨆ a ∈ s, f a
Succeeded for CategoryTheory.Preadditive.comp_sub : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Preadditive C] {P Q R : C} (f : P ⟶ Q)
  (g g' : Q ⟶ R),
  CategoryTheory.CategoryStruct.comp f (g - g') =
    CategoryTheory.CategoryStruct.comp f g - CategoryTheory.CategoryStruct.comp f g'
Succeeded for Nat.cast_lt : ∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α]
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] [inst_3 : ZeroLEOneClass α]
  [inst_4 : CharZero α] {m n : ℕ}, ↑m < ↑n ↔ m < n
Succeeded for Subgroup.inv_mem : ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x : G}, x ∈ H → x⁻¹ ∈ H
Failed for Primrec.id : ∀ {α : Type u_1} [inst : Primcodable α], Primrec id
typeclass instance problem is stuck, it is often due to metavariables
  Primcodable ?m.93

----
Succeeded for MeasureTheory.Measure.restrict_le_self : ∀ {α : Type u_2} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : Set α}, μ.restrict s ≤ μ
Succeeded for Filter.eventually_gt_atTop : ∀ {α : Type u_3} [inst : Preorder α] [inst_1 : NoMaxOrder α] (a : α), ∀ᶠ (x : α) in Filter.atTop, a < x
Succeeded for Option.some_inj : ∀ {α : Type u_1} {a b : α}, some a = some b ↔ a = b
Succeeded for tsub_le_iff_left : ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : AddCommSemigroup α] [inst_2 : Sub α] [inst_3 : OrderedSub α] {a b c : α},
  a - b ≤ c ↔ a ≤ b + c
Succeeded for edist_lt_top : ∀ {α : Type u_3} [inst : PseudoMetricSpace α] (x y : α), edist x y < ⊤
Failed for MeasureTheory.measure_congr : ∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {s t : Set α},
  μ.ae.EventuallyEq s t → ↑↑μ s = ↑↑μ t
Invalid field `ae`: The environment does not contain `MeasureTheory.Measure.ae`
  μ
has type
  MeasureTheory.Measure α
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known

----
Succeeded for add_tsub_cancel_left : ∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : AddCommSemigroup α] [inst_2 : Sub α] [inst_3 : OrderedSub α]
  [inst : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] (a b : α), a + b - a = b
Succeeded for ContinuousAt.tendsto : ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X → Y} {x : X},
  ContinuousAt f x → Filter.Tendsto f (nhds x) (nhds (f x))
Succeeded for CovBy.lt : ∀ {α : Type u_1} [inst : LT α] {a b : α}, a ⋖ b → a < b
Succeeded for Finset.coe_map : ∀ {α : Type u_1} {β : Type u_2} (f : α ↪ β) (s : Finset α), ↑(Finset.map f s) = ⇑f '' ↑s
Succeeded for List.get?_eq_get : ∀ {α : Type u_1} {l : List α} {n : ℕ} (h : n < l.length), l.get? n = some (l.get ⟨n, h⟩)
Failed for Mathlib.Data.Nat.Cast.Order._auxLemma.11 : ∀ {α : Type u_3} [inst : OrderedSemiring α] [inst_1 : Nontrivial α] {n : ℕ} [inst_2 : n.AtLeastTwo],
  (0 < OfNat.ofNat n) = True
invalid binder annotation, type is not a class instance
  OrderedSemiring α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for Filter.Tendsto.mono_right : ∀ {α : Type u} {β : Type v} {f : α → β} {x : Filter α} {y z : Filter β},
  Filter.Tendsto f x y → y ≤ z → Filter.Tendsto f x z
Failed for CategoryTheory.Over.w : ∀ {T : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} T] {X : T} {A B : CategoryTheory.Over X} (f : A ⟶ B),
  CategoryTheory.CategoryStruct.comp f.left B.hom = A.hom
unknown universe level 'v₁'

----
Succeeded for tsum_congr : ∀ {α : Type u_1} {β : Type u_2} [inst : AddCommMonoid α] [inst_1 : TopologicalSpace α] {f g : β → α},
  (∀ (b : β), f b = g b) → ∑' (b : β), f b = ∑' (b : β), g b
Succeeded for Matrix.mul_assoc : ∀ {l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {α : Type v} [inst : NonUnitalSemiring α]
  [inst_1 : Fintype m] [inst_2 : Fintype n] (L : Matrix l m α) (M : Matrix m n α) (N : Matrix n o α),
  L * M * N = L * (M * N)
Succeeded for Nat.Linear.ExprCnstr.eq_true_of_isValid : ∀ (ctx : Nat.Linear.Context) (c : Nat.Linear.ExprCnstr),
  c.toNormPoly.isValid = true → Nat.Linear.ExprCnstr.denote ctx c = True
Succeeded for Eq.substr : ∀ {α : Sort u} {p : α → Prop} {a b : α}, b = a → p a → p b
Succeeded for Filter.eventually_atTop : ∀ {α : Type u_3} [inst : SemilatticeSup α] [inst_1 : Nonempty α] {p : α → Prop},
  (∀ᶠ (x : α) in Filter.atTop, p x) ↔ ∃ a, ∀ b ≥ a, p b
Succeeded for Polynomial.eval₂_C : ∀ {R : Type u} {S : Type v} {a : R} [inst : Semiring R] [inst_1 : Semiring S] (f : R →+* S) (x : S),
  Polynomial.eval₂ f x (Polynomial.C a) = f a
Succeeded for Filter.image_mem_map : ∀ {α : Type u} {β : Type v} {f : Filter α} {m : α → β} {s : Set α}, s ∈ f → m '' s ∈ Filter.map m f
Succeeded for Finset.insert_erase : ∀ {α : Type u_1} [inst : DecidableEq α] {s : Finset α} {a : α}, a ∈ s → insert a (s.erase a) = s
Succeeded for intervalIntegral.integral_of_le : ∀ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {a b : ℝ} {f : ℝ → E}
  {μ : MeasureTheory.Measure ℝ}, a ≤ b → ∫ (x : ℝ) in a..b, f x ∂μ = ∫ (x : ℝ) in Set.Ioc a b, f x ∂μ
Succeeded for if_false : ∀ {α : Sort u_1} {x : Decidable False} (t e : α), (if False then t else e) = e
Failed for MeasureTheory.Measure.sum_apply : ∀ {α : Type u_1} {ι : Type u_5} {m0 : MeasurableSpace α} (f : ι → MeasureTheory.Measure α) {s : Set α},
  MeasurableSet s → ↑↑(MeasureTheory.Measure.sum f) s = ∑' (i : ι), ↑↑(f i) s
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known

----
Succeeded for add_add_add_comm : ∀ {G : Type u_3} [inst : AddCommSemigroup G] (a b c d : G), a + b + (c + d) = a + c + (b + d)
Succeeded for Asymptotics.IsBigOWith.isBigO : ∀ {α : Type u_1} {E : Type u_3} {F : Type u_4} [inst : Norm E] [inst_1 : Norm F] {c : ℝ} {f : α → E} {g : α → F}
  {l : Filter α}, Asymptotics.IsBigOWith c l f g → f =O[l] g
Succeeded for Set.insert_eq : ∀ {α : Type u} (x : α) (s : Set α), insert x s = {x} ∪ s
Succeeded for le_sInf : ∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s : Set α} {a : α}, (∀ b ∈ s, a ≤ b) → a ≤ sInf s
Succeeded for Finsupp.sum_single_index : ∀ {α : Type u_1} {M : Type u_8} {N : Type u_10} [inst : Zero M] [inst_1 : AddCommMonoid N] {a : α} {b : M}
  {h : α → M → N}, h a 0 = 0 → (fun₀ | a => b).sum h = h a b
Succeeded for Real.exp_zero : Real.exp 0 = 1
Failed for MeasureTheory.VectorMeasure.ext : ∀ {α : Type u_1} {m : MeasurableSpace α} {M : Type u_3} [inst : AddCommMonoid M] [inst_1 : TopologicalSpace M]
  {s t : MeasureTheory.VectorMeasure α M}, (∀ (i : Set α), MeasurableSet i → ↑s i = ↑t i) → s = t
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known

----
Failed for Array.data_toArray : ∀ {α : Type u_1} (as : List α), (List.toArray as).data = as
Invalid field `data`: The environment does not contain `Array.data`
  as.toArray
has type
  Array α

----
Succeeded for zsmul_eq_mul : ∀ {α : Type u_3} [inst : Ring α] (a : α) (n : ℤ), n • a = ↑n * a
Failed for MeasureTheory.measure_mono_null : ∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {s₁ s₂ : Set α},
  s₁ ⊆ s₂ → ↑↑μ s₂ = 0 → ↑↑μ s₁ = 0
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known

----
Succeeded for add_left_injective : ∀ {G : Type u_3} [inst : Add G] [inst_1 : IsRightCancelAdd G] (a : G), Function.Injective fun x => x + a
Failed for Set.iInter_exists : ∀ {α : Type u_1} {ι : Sort u_4} {p : ι → Prop} {f : Exists p → Set α}, ⋂ (x : Exists p), f x = ⋂ i, ⋂ (h : p i), f ⋯
don't know how to synthesize placeholder
context:
α : Type u_1
ι : Sort u_4
p : ι → Prop
f : Exists p → Set α
i : ι
h : p i
⊢ Exists p

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Failed for Pi.single_eq_same : ∀ {I : Type u} {f : I → Type v₁} [inst : DecidableEq I] [inst_1 : (i : I) → Zero (f i)] (i : I) (x : f i),
  Pi.single i x i = x
unknown universe level 'v₁'
invalid parametric local instance, parameter with type
  I
does not have forward dependencies, type class resolution cannot use this kind of local instance because it will not be able to infer a value for this parameter.

----
Succeeded for one_add_one_eq_two : ∀ {R : Type u_1} [inst : AddMonoidWithOne R], 1 + 1 = 2
Succeeded for not_le_of_gt : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a > b → ¬a ≤ b
Succeeded for Mathlib.Topology.MetricSpace.PseudoMetric._auxLemma.7 : ∀ {α : Type u} [inst : PseudoMetricSpace α] {x y : α} {ε : ℝ}, (y ∈ Metric.ball x ε) = (dist y x < ε)
Succeeded for Finset.mul_sum : ∀ {ι : Type u_1} {α : Type u_2} [inst : NonUnitalNonAssocSemiring α] (s : Finset ι) (f : ι → α) (a : α),
  (a * s.sum fun i => f i) = s.sum fun i => a * f i
Succeeded for disjoint_compl_right : ∀ {α : Type u_2} [inst : HeytingAlgebra α] {a : α}, Disjoint a aᶜ
Succeeded for Equiv.self_comp_symm : ∀ {α : Sort u} {β : Sort v} (e : α ≃ β), ⇑e ∘ ⇑e.symm = id
Succeeded for mul_inv_self : ∀ {G : Type u_1} [inst : Group G] (a : G), a * a⁻¹ = 1
Succeeded for mul_right_comm : ∀ {G : Type u_3} [inst : CommSemigroup G] (a b c : G), a * b * c = a * c * b
Succeeded for Matrix.det_mul : ∀ {n : Type u_2} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] (M N : Matrix n n R),
  (M * N).det = M.det * N.det
Succeeded for LE.le.le_iff_eq : ∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → (b ≤ a ↔ b = a)
Succeeded for Iff.and : ∀ {a c b d : Prop}, (a ↔ c) → (b ↔ d) → (a ∧ b ↔ c ∧ d)
Failed for CategoryTheory.Discrete.functor_map_id : ∀ {J : Type v₁} {C : Type u₂} [inst : CategoryTheory.Category.{v₂, u₂} C]
  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) C) {j : CategoryTheory.Discrete J} (f : j ⟶ j),
  F.map f = CategoryTheory.CategoryStruct.id (F.obj j)
unknown universe level 'v₁'
unknown universe level 'v₂'

----
Succeeded for Continuous.sub : ∀ {G : Type w} {α : Type u} [inst : TopologicalSpace G] [inst_1 : Sub G] [inst_2 : ContinuousSub G]
  [inst_3 : TopologicalSpace α] {f g : α → G}, Continuous f → Continuous g → Continuous fun x => f x - g x
Succeeded for Nat.pow_succ : ∀ (n m : ℕ), n ^ m.succ = n ^ m * n
Succeeded for min_le_right : ∀ {α : Type u} [inst : LinearOrder α] (a b : α), min a b ≤ b
Succeeded for ZMod.card : ∀ (n : ℕ) [inst : Fintype (ZMod n)], Fintype.card (ZMod n) = n
Succeeded for Finset.subset_univ : ∀ {α : Type u_1} [inst : Fintype α] (s : Finset α), s ⊆ Finset.univ
Succeeded for Set.union_singleton : ∀ {α : Type u} {a : α} {s : Set α}, s ∪ {a} = insert a s
Succeeded for CategoryTheory.Iso.inv_comp_eq : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y Z : C} (α : X ≅ Y) {f : X ⟶ Z} {g : Y ⟶ Z},
  CategoryTheory.CategoryStruct.comp α.inv f = g ↔ f = CategoryTheory.CategoryStruct.comp α.hom g
Succeeded for Set.Icc_self : ∀ {α : Type u_1} [inst : PartialOrder α] (a : α), Set.Icc a a = {a}
Succeeded for Set.piecewise_eq_of_mem : ∀ {α : Type u_1} {δ : α → Sort u_6} (s : Set α) (f g : (i : α) → δ i) [inst : (j : α) → Decidable (j ∈ s)] {i : α},
  i ∈ s → s.piecewise f g i = f i
Failed for bot_eq_zero' : ∀ {α : Type u} [inst : CanonicallyLinearOrderedAddCommMonoid α], ⊥ = 0
invalid binder annotation, type is not a class instance
  CanonicallyLinearOrderedAddCommMonoid α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for ArithmeticFunction.ext : ∀ {R : Type u_1} [inst : Zero R] ⦃f g : ArithmeticFunction R⦄, (∀ (x : ℕ), f x = g x) → f = g
Succeeded for MeasurableSpace.generateFrom_le : ∀ {α : Type u_1} {s : Set (Set α)} {m : MeasurableSpace α},
  (∀ t ∈ s, MeasurableSet t) → MeasurableSpace.generateFrom s ≤ m
Failed for CategoryTheory.Limits.pushout.condition : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z}
  [inst_1 : CategoryTheory.Limits.HasPushout f g],
  CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.pushout.inl =
    CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.pushout.inr
Application type mismatch: In the application
  CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.pushout.inr
the argument
  CategoryTheory.Limits.pushout.inr
has type
  (f : ?m.2679 ⟶ ?m.2680) →
    (g : ?m.2679 ⟶ ?m.2681) →
      [inst : CategoryTheory.Limits.HasPushout f g] → ?m.2681 ⟶ CategoryTheory.Limits.pushout f g : Type ?u.2676
but is expected to have type
  Z ⟶ ?m.6339 : Type v

----
Succeeded for dvd_trans : ∀ {α : Type u_1} [inst : Semigroup α] {a b c : α}, a ∣ b → b ∣ c → a ∣ c
Succeeded for MeasureTheory.Measure.measurable_rnDeriv : ∀ {α : Type u_1} {m : MeasurableSpace α} (μ ν : MeasureTheory.Measure α), Measurable (μ.rnDeriv ν)
Succeeded for GaloisConnection.u_inf : ∀ {α : Type u} {β : Type v} {b₁ b₂ : β} [inst : SemilatticeInf α] [inst_1 : SemilatticeInf β] {l : α → β} {u : β → α},
  GaloisConnection l u → u (b₁ ⊓ b₂) = u b₁ ⊓ u b₂
Failed for CategoryTheory.op_comp : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X Y Z : C} {f : X ⟶ Y} {g : Y ⟶ Z},
  (CategoryTheory.CategoryStruct.comp f g).op = CategoryTheory.CategoryStruct.comp g.op f.op
unknown universe level 'v₁'

----
Succeeded for Set.Ico_subset_Icc_self : ∀ {α : Type u_1} [inst : Preorder α] {a b : α}, Set.Ico a b ⊆ Set.Icc a b
Succeeded for AddEquiv.apply_symm_apply : ∀ {M : Type u_6} {N : Type u_7} [inst : Add M] [inst_1 : Add N] (e : M ≃+ N) (y : N), e (e.symm y) = y
Succeeded for LT.lt.false : ∀ {α : Type u} [inst : Preorder α] {x : α}, x < x → False
Succeeded for mul_div_assoc : ∀ {G : Type u_3} [inst : DivInvMonoid G] (a b c : G), a * b / c = a * (b / c)
Failed for Ideal.one_eq_top : ∀ {R : Type u} [inst : CommSemiring R], 1 = ⊤
failed to synthesize
  Top ℕ

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Failed for CategoryTheory.Limits.IsColimit.hom_ext : ∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] {C : Type u₃} [inst_1 : CategoryTheory.Category.{v₃, u₃} C]
  {F : CategoryTheory.Functor J C} {t : CategoryTheory.Limits.Cocone F},
  CategoryTheory.Limits.IsColimit t →
    ∀ {W : C} {f f' : t.pt ⟶ W},
      (∀ (j : J),
          CategoryTheory.CategoryStruct.comp (t.ι.app j) f = CategoryTheory.CategoryStruct.comp (t.ι.app j) f') →
        f = f'
unknown universe level 'v₁'

----
Succeeded for Set.insert_eq_of_mem : ∀ {α : Type u} {a : α} {s : Set α}, a ∈ s → insert a s = s
Succeeded for Nat.div_one : ∀ (n : ℕ), n / 1 = n
Succeeded for Set.piecewise_eq_of_not_mem : ∀ {α : Type u_1} {δ : α → Sort u_6} (s : Set α) (f g : (i : α) → δ i) [inst : (j : α) → Decidable (j ∈ s)] {i : α},
  i ∉ s → s.piecewise f g i = g i
Failed for mul_self_nonneg : ∀ {α : Type u} [inst : LinearOrderedSemiring α] [inst_1 : ExistsAddOfLE α] (a : α), 0 ≤ a * a
invalid binder annotation, type is not a class instance
  LinearOrderedSemiring α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for Ideal.Quotient.eq_zero_iff_mem : ∀ {R : Type u} [inst : CommRing R] {a : R} {I : Ideal R}, (Ideal.Quotient.mk I) a = 0 ↔ a ∈ I
Succeeded for Polynomial.eval_one : ∀ {R : Type u} [inst : Semiring R] {x : R}, Polynomial.eval x 1 = 1
Failed for CategoryTheory.Limits.HasColimit.mk : ∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] {C : Type u} [inst_1 : CategoryTheory.Category.{v, u} C]
  {F : CategoryTheory.Functor J C}, CategoryTheory.Limits.ColimitCocone F → CategoryTheory.Limits.HasColimit F
unknown universe level 'v₁'

----
Succeeded for Differentiable.differentiableOn : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}
  {s : Set E}, Differentiable 𝕜 f → DifferentiableOn 𝕜 f s
Failed for GaloisConnection.u_iInf : ∀ {α : Type u} {β : Type v} {ι : Sort x} [inst : CompleteLattice α] [inst_1 : CompleteLattice β] {l : α → β}
  {u : β → α}, GaloisConnection l u → ∀ {f : ι → β}, u (iInf f) = ⨅ i, u (f i)
unknown universe level 'x'

----
Succeeded for CategoryTheory.IsIso.inv_hom_id_assoc : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} (f : X ⟶ Y) [I : CategoryTheory.IsIso f] {Z : C}
  (g : Y ⟶ Z), CategoryTheory.CategoryStruct.comp (CategoryTheory.inv f) (CategoryTheory.CategoryStruct.comp f g) = g
Succeeded for Nat.mul_le_mul_left : ∀ {n m : ℕ} (k : ℕ), n ≤ m → k * n ≤ k * m
Succeeded for ENNReal.rpow_one : ∀ (x : ENNReal), x ^ 1 = x
Failed for Asymptotics.IsBigOWith_def : ∀ {α : Type u_17} {E : Type u_18} {F : Type u_19} [inst : Norm E] [inst_1 : Norm F] (c : ℝ) (l : Filter α) (f : α → E)
  (g : α → F), Asymptotics.IsBigOWith c l f g = ∀ᶠ (x : α) in l, ‖f x‖ ≤ c * ‖g x‖
unknown universe level 'u_17'
unknown universe level 'u_18'
unknown universe level 'u_19'

----
Failed for CategoryTheory.congr_app : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  {F G : CategoryTheory.Functor C D} {α β : F.NatTrans G}, α = β → ∀ (X : C), α.app X = β.app X
Invalid field `NatTrans`: The environment does not contain `CategoryTheory.Functor.NatTrans`
  F
has type
  CategoryTheory.Functor C D
Invalid field `NatTrans`: The environment does not contain `CategoryTheory.Functor.NatTrans`
  F
has type
  CategoryTheory.Functor C D

----
Succeeded for le_iSup₂ : ∀ {α : Type u_1} {ι : Sort u_5} {κ : ι → Sort u_7} [inst : CompleteLattice α] {f : (i : ι) → κ i → α} (i : ι) (j : κ i),
  f i j ≤ ⨆ i, ⨆ j, f i j
Succeeded for Finsupp.not_mem_support_iff : ∀ {α : Type u_1} {M : Type u_5} [inst : Zero M] {f : α →₀ M} {a : α}, a ∉ f.support ↔ f a = 0
Succeeded for LT.lt.not_lt : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → ¬b < a
Succeeded for Finset.not_mem_erase : ∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (s : Finset α), a ∉ s.erase a
Succeeded for Nat.one_mul : ∀ (n : ℕ), 1 * n = n
Succeeded for List.concat_eq_append : ∀ {α : Type u} (as : List α) (a : α), as.concat a = as ++ [a]
Succeeded for Fintype.card_congr' : ∀ {α β : Type u_4} [inst : Fintype α] [inst_1 : Fintype β], α = β → Fintype.card α = Fintype.card β
Succeeded for MeasureTheory.ae_restrict_iff' : ∀ {α : Type u_2} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : Set α} {p : α → Prop},
  MeasurableSet s → ((∀ᵐ (x : α) ∂μ.restrict s, p x) ↔ ∀ᵐ (x : α) ∂μ, x ∈ s → p x)
Succeeded for Monotone.map_max : ∀ {α : Type u} {β : Type v} [inst : LinearOrder α] [inst_1 : LinearOrder β] {f : α → β} {a b : α},
  Monotone f → f (max a b) = max (f a) (f b)
Succeeded for RelEmbedding.map_rel_iff : ∀ {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} (f : r ↪r s) {a b : α}, s (f a) (f b) ↔ r a b
Succeeded for isOpen_iff_mem_nhds : ∀ {X : Type u} {s : Set X} [inst : TopologicalSpace X], IsOpen s ↔ ∀ x ∈ s, s ∈ nhds x
Failed for isometry_vadd : ∀ {M : Type u} (X : Type w) [inst : PseudoEMetricSpace X] [inst_1 : VAdd M X] [inst_2 : IsometricVAdd M X] (c : M),
  Isometry fun x => c +ᵥ x
invalid binder annotation, type is not a class instance
  IsometricVAdd M X

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for CategoryTheory.MonoidalCategory.comp_whiskerRight : ∀ {C : Type u} [𝒞 : CategoryTheory.Category.{v, u} C] [inst : CategoryTheory.MonoidalCategory C] {W X Y : C} (f : W ⟶ X)
  (g : X ⟶ Y) (Z : C),
  CategoryTheory.MonoidalCategory.whiskerRight (CategoryTheory.CategoryStruct.comp f g) Z =
    CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.whiskerRight f Z)
      (CategoryTheory.MonoidalCategory.whiskerRight g Z)
Succeeded for NNReal.coe_le_coe : ∀ {r₁ r₂ : NNReal}, ↑r₁ ≤ ↑r₂ ↔ r₁ ≤ r₂
Succeeded for Quotient.ind : ∀ {α : Sort u} {s : Setoid α} {motive : Quotient s → Prop}, (∀ (a : α), motive ⟦a⟧) → ∀ (q : Quotient s), motive q
Succeeded for LipschitzWith.uniformContinuous : ∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {K : NNReal} {f : α → β},
  LipschitzWith K f → UniformContinuous f
Succeeded for Mathlib.Algebra.GroupWithZero.Divisibility._auxLemma.2 : ∀ {α : Type u_1} [inst : SemigroupWithZero α] (a : α), (a ∣ 0) = True
Succeeded for zero_dvd_iff : ∀ {α : Type u_1} [inst : SemigroupWithZero α] {a : α}, 0 ∣ a ↔ a = 0
Succeeded for Int.ofNat_nonneg : ∀ (n : ℕ), 0 ≤ ↑n
Succeeded for Mathlib.Data.Finset.Basic._auxLemma.158 : ∀ {n : ℕ}, (Finset.range n = ∅) = (n = 0)
Succeeded for Filter.Tendsto.add : ∀ {α : Type u_2} {M : Type u_3} [inst : TopologicalSpace M] [inst_1 : Add M] [inst_2 : ContinuousAdd M] {f g : α → M}
  {x : Filter α} {a b : M},
  Filter.Tendsto f x (nhds a) → Filter.Tendsto g x (nhds b) → Filter.Tendsto (fun x => f x + g x) x (nhds (a + b))
Failed for MultilinearMap.ext : ∀ {R : Type uR} {ι : Type uι} {M₁ : ι → Type v₁} {M₂ : Type v₂} [inst : Semiring R]
  [inst_1 : (i : ι) → AddCommMonoid (M₁ i)] [inst_2 : AddCommMonoid M₂] [inst_3 : (i : ι) → Module R (M₁ i)]
  [inst_4 : Module R M₂] {f f' : MultilinearMap R M₁ M₂}, (∀ (x : (i : ι) → M₁ i), f x = f' x) → f = f'
unknown universe level 'uR'
unknown universe level 'uι'
unknown universe level 'v₂'

----
Succeeded for mul_two : ∀ {α : Type u} [inst : NonAssocSemiring α] (n : α), n * 2 = n + n
Succeeded for Polynomial.eval_add : ∀ {R : Type u} [inst : Semiring R] {p q : Polynomial R} {x : R},
  Polynomial.eval x (p + q) = Polynomial.eval x p + Polynomial.eval x q
Succeeded for Int.cast_sub : ∀ {R : Type u} [inst : AddGroupWithOne R] (m n : ℤ), ↑(m - n) = ↑m - ↑n
Succeeded for Finset.eq_empty_or_nonempty : ∀ {α : Type u_1} (s : Finset α), s = ∅ ∨ s.Nonempty
Succeeded for Int.add_zero : ∀ (a : ℤ), a + 0 = a
Succeeded for Finset.Subset.rfl : ∀ {α : Type u_1} {s : Finset α}, s ⊆ s
Failed for Filter.atTop_basis : ∀ {α : Type u_3} [inst : Nonempty α] [inst : SemilatticeSup α], Filter.atTop.HasBasis (fun x => True) Set.Ici
typeclass instance problem is stuck, it is often due to metavariables
  Preorder ?m.285

----
Succeeded for isUnit_of_mul_eq_one : ∀ {M : Type u_1} [inst : CommMonoid M] (a b : M), a * b = 1 → IsUnit a
Succeeded for CategoryTheory.Limits.prod.comp_lift : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {V W X Y : C}
  [inst_1 : CategoryTheory.Limits.HasBinaryProduct X Y] (f : V ⟶ W) (g : W ⟶ X) (h : W ⟶ Y),
  CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.prod.lift g h) =
    CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f h)
Succeeded for Iff.not_left : ∀ {a b : Prop}, (a ↔ ¬b) → (¬a ↔ b)
Succeeded for Function.iterate_succ_apply' : ∀ {α : Type u} (f : α → α) (n : ℕ) (x : α), f^[n.succ] x = f (f^[n] x)
Succeeded for nhds_basis_opens : ∀ {X : Type u} [inst : TopologicalSpace X] (x : X), (nhds x).HasBasis (fun s => x ∈ s ∧ IsOpen s) fun s => s
Succeeded for lt_or_eq_of_le : ∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → a < b ∨ a = b
Succeeded for Set.subset_iUnion : ∀ {β : Type u_2} {ι : Sort u_4} (s : ι → Set β) (i : ι), s i ⊆ ⋃ i, s i
Succeeded for sup_idem : ∀ {α : Type u} [inst : SemilatticeSup α] (a : α), a ⊔ a = a
Failed for Subtype.mk_eq_mk : ∀ {α : Sort u_1} {p : α → Prop} {a : α} {h : p a} {a' : α} {h' : p a'}, ⟨a, h⟩ = ⟨a', h'⟩ ↔ a = a'
invalid constructor ⟨...⟩, expected type must be an inductive type 
  ?m.27
invalid constructor ⟨...⟩, expected type must be an inductive type 
  ?m.27

----
Succeeded for Submonoid.one_mem : ∀ {M : Type u_1} [inst : MulOneClass M] (S : Submonoid M), 1 ∈ S
Succeeded for GaloisInsertion.l_u_eq : ∀ {α : Type u} {β : Type v} {l : α → β} {u : β → α} [inst : Preorder α] [inst_1 : PartialOrder β],
  GaloisInsertion l u → ∀ (b : β), l (u b) = b
Succeeded for Or.imp_left : ∀ {a b c : Prop}, (a → b) → a ∨ c → b ∨ c
Failed for vadd_assoc : ∀ {α : Type u_6} {M : Type u_10} {N : Type u_11} [inst : VAdd M N] [inst_1 : VAdd N α] [inst_2 : VAdd M α]
  [inst_3 : VAddAssocClass M N α] (x : M) (y : N) (z : α), x +ᵥ y +ᵥ z = x +ᵥ (y +ᵥ z)
unknown universe level 'u_11'

----
Succeeded for BoundedContinuousFunction.ext : ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β]
  {f g : BoundedContinuousFunction α β}, (∀ (x : α), f x = g x) → f = g
Succeeded for Fintype.card_coe : ∀ {α : Type u_1} (s : Finset α) [inst : Fintype { x // x ∈ s }], Fintype.card { x // x ∈ s } = s.card
Succeeded for MeasureTheory.AEStronglyMeasurable.aemeasurable : ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {β : Type u_5} [inst : MeasurableSpace β]
  [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace.PseudoMetrizableSpace β] [inst_3 : BorelSpace β] {f : α → β},
  MeasureTheory.AEStronglyMeasurable f μ → AEMeasurable f μ
Succeeded for tsum_zero : ∀ {α : Type u_1} {β : Type u_2} [inst : AddCommMonoid α] [inst_1 : TopologicalSpace α], ∑' (x : β), 0 = 0
Succeeded for IsClosed.inter : ∀ {X : Type u} {s₁ s₂ : Set X} [inst : TopologicalSpace X], IsClosed s₁ → IsClosed s₂ → IsClosed (s₁ ∩ s₂)
Succeeded for Set.inter_self : ∀ {α : Type u} (a : Set α), a ∩ a = a
Succeeded for Nat.succ.injEq : ∀ (u v : ℕ), (u.succ = v.succ) = (u = v)
Succeeded for Mathlib.Algebra.Order.Monoid.Lemmas._auxLemma.17 : ∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LE α]
  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]
  [inst_3 : ContravariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] (a : α) {b : α},
  (a ≤ b + a) = (0 ≤ b)
Failed for ContDiff.comp : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {G : Type uG}
  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace 𝕜 G] {n : ℕ∞} {g : F → G} {f : E → F},
  ContDiff 𝕜 n g → ContDiff 𝕜 n f → ContDiff 𝕜 n (g ∘ f)
unknown universe level 'uE'
unknown universe level 'uF'
unknown universe level 'uG'

----
Succeeded for invOf_mul_self : ∀ {α : Type u} [inst : Mul α] [inst_1 : One α] (a : α) [inst_2 : Invertible a], ⅟a * a = 1
Failed for CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso_inv_comp : ∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] {C : Type u₃} [inst_1 : CategoryTheory.Category.{v₃, u₃} C]
  {F : CategoryTheory.Functor J C} {s t : CategoryTheory.Limits.Cone F} (P : CategoryTheory.Limits.IsLimit s)
  (Q : CategoryTheory.Limits.IsLimit t) (j : J),
  CategoryTheory.CategoryStruct.comp (P.conePointUniqueUpToIso Q).inv (s.π.app j) = t.π.app j
unknown universe level 'v₁'

----
Succeeded for Submonoid.mul_mem : ∀ {M : Type u_1} [inst : MulOneClass M] (S : Submonoid M) {x y : M}, x ∈ S → y ∈ S → x * y ∈ S
Failed for add_nsmul : ∀ {A : Type y} [inst : AddMonoid A] (a : A) (m n : ℕ), (m + n) • a = m • a + n • a
unknown universe level 'y'

----
Succeeded for CategoryTheory.Limits.Fork.condition : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} {f g : X ⟶ Y} (t : CategoryTheory.Limits.Fork f g),
  CategoryTheory.CategoryStruct.comp t.ι f = CategoryTheory.CategoryStruct.comp t.ι g
Succeeded for Nat.gcd_comm : ∀ (m n : ℕ), m.gcd n = n.gcd m
Failed for MvPolynomial.aeval_X : ∀ {R : Type u} {S₁ : Type v} {σ : Type u_1} [inst : CommSemiring R] [inst_1 : CommSemiring S₁] [inst_2 : Algebra R S₁]
  (f : σ → S₁) (s : σ), (MvPolynomial.aeval f) (MvPolynomial.X s) = f s
typeclass instance problem is stuck, it is often due to metavariables
  CommSemiring (?m.3000 f s)

----
Failed for Option.map_id : ∀ {α : Type u_1}, Option.map id = id
don't know how to synthesize implicit argument 'α'
  @Eq (Option ?m.57 → Option ?m.57) (Option.map id) id
context:
α : Type u_1
⊢ Type ?u.7

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @id (Option ?m.57)
context:
α : Type u_1
⊢ Type ?u.7

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'β'
  @Option.map ?m.57 ?m.57 id
context:
α : Type u_1
⊢ Type ?u.7

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @Option.map ?m.57 ?m.57 id
context:
α : Type u_1
⊢ Type ?u.7

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @id ?m.57
context:
α : Type u_1
⊢ Type ?u.7

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for Finset.map_eq_image : ∀ {α : Type u_1} {β : Type u_2} [inst : DecidableEq β] (f : α ↪ β) (s : Finset α), Finset.map f s = Finset.image (⇑f) s
Succeeded for Set.toFinset_card : ∀ {α : Type u_4} (s : Set α) [inst : Fintype ↑s], s.toFinset.card = Fintype.card ↑s
Succeeded for Nat.dvd_antisymm : ∀ {m n : ℕ}, m ∣ n → n ∣ m → m = n
Failed for isometry_smul : ∀ {M : Type u} (X : Type w) [inst : PseudoEMetricSpace X] [inst_1 : SMul M X] [inst_2 : IsometricSMul M X] (c : M),
  Isometry fun x => c • x
invalid binder annotation, type is not a class instance
  IsometricSMul M X

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for Nat.pos_iff_ne_zero : ∀ {n : ℕ}, 0 < n ↔ n ≠ 0
Failed for ConcaveOn.dual : ∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_5} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E]
  [inst_2 : OrderedAddCommMonoid β] [inst_3 : SMul 𝕜 E] [inst_4 : SMul 𝕜 β] {s : Set E} {f : E → β},
  ConcaveOn 𝕜 s f → ConvexOn 𝕜 s (⇑OrderDual.toDual ∘ f)
invalid binder annotation, type is not a class instance
  OrderedSemiring 𝕜

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for apply_ite : ∀ {α : Sort u_1} {β : Sort u_2} (f : α → β) (P : Prop) [inst : Decidable P] (x y : α),
  f (if P then x else y) = if P then f x else f y
Succeeded for bot_sup_eq : ∀ {α : Type u} [inst : SemilatticeSup α] [inst_1 : OrderBot α] (a : α), ⊥ ⊔ a = a
Failed for abs_le : ∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] {a b : α}, |a| ≤ b ↔ -b ≤ a ∧ a ≤ b
invalid binder annotation, type is not a class instance
  LinearOrderedAddCommGroup α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for abs_neg : ∀ {α : Type u_1} [inst : Lattice α] [inst_1 : AddGroup α] (a : α), |(-a)| = |a|
Failed for abs_mul : ∀ {α : Type u_1} [inst : LinearOrderedRing α] (a b : α), |a * b| = |a| * |b|
invalid binder annotation, type is not a class instance
  LinearOrderedRing α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Failed for Submodule.mem_top : ∀ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {x : M}, x ∈ ⊤
typeclass instance problem is stuck, it is often due to metavariables
  Membership M ?m.560

----
Succeeded for Polynomial.Monic.ne_zero : ∀ {R : Type u_2} [inst : Semiring R] [inst_1 : Nontrivial R] {p : Polynomial R}, p.Monic → p ≠ 0
Succeeded for List.Sublist.subperm : ∀ {α : Type u_1} {l₁ l₂ : List α}, l₁.Sublist l₂ → l₁.Subperm l₂
Failed for half_pos : ∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a : α}, 0 < a → 0 < a / 2
invalid binder annotation, type is not a class instance
  LinearOrderedSemifield α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for Int.natAbs_mul : ∀ (a b : ℤ), (a * b).natAbs = a.natAbs * b.natAbs
Succeeded for Set.preimage_comp : ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {f : α → β} {g : β → γ} {s : Set γ}, g ∘ f ⁻¹' s = f ⁻¹' (g ⁻¹' s)
Failed for vsub_vadd : ∀ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (p₁ p₂ : P), p₁ -ᵥ p₂ +ᵥ p₂ = p₁
type expected, got
  (p₁ -ᵥ p₂ : G)

----
Succeeded for of_eq_false : ∀ {p : Prop}, p = False → ¬p
Failed for ENNReal.coe_lt_top : ∀ {r : NNReal}, ↑r < ⊤
failed to synthesize
  Top NNReal

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Succeeded for Nat.Primrec.of_eq : ∀ {f g : ℕ → ℕ}, Nat.Primrec f → (∀ (n : ℕ), f n = g n) → Nat.Primrec g
Succeeded for CategoryTheory.Limits.biprod.hom_ext : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X Y Z : C}
  [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct X Y] (f g : Z ⟶ X ⊞ Y),
  CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.fst =
      CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.biprod.fst →
    CategoryTheory.CategoryStruct.comp f CategoryTheory.Limits.biprod.snd =
        CategoryTheory.CategoryStruct.comp g CategoryTheory.Limits.biprod.snd →
      f = g
Failed for norm_smul_le : ∀ {α : Type u_1} {β : Type u_2} [inst : SeminormedAddGroup α] [inst_1 : SeminormedAddGroup β]
  [inst_2 : SMulZeroClass α β] [inst_3 : BoundedSMul α β] (r : α) (x : β), ‖r • x‖ ≤ ‖r‖ * ‖x‖
invalid binder annotation, type is not a class instance
  BoundedSMul α β

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Failed for Quotient.surjective_Quotient_mk'' : ∀ {α : Sort u_1} {s₁ : Setoid α}, Function.Surjective Quotient.mk''
don't know how to synthesize implicit argument 'β'
  @Function.Surjective ?m.18 (Quotient ?m.19) Quotient.mk''
context:
α : Sort u_1
s₁ : Setoid α
⊢ Sort ?u.12

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @Function.Surjective ?m.18 (Quotient ?m.19) Quotient.mk''
context:
α : Sort u_1
s₁ : Setoid α
⊢ Sort ?u.12

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 's₁'
  @Quotient.mk'' ?m.18 ?m.19
context:
α : Sort u_1
s₁ : Setoid α
⊢ Setoid ?m.18

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @Quotient.mk'' ?m.18 ?m.19
context:
α : Sort u_1
s₁ : Setoid α
⊢ Sort ?u.12

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for mul_inv_cancel_right : ∀ {G : Type u_1} [inst : Group G] (a b : G), a * b * b⁻¹ = a
Failed for Asymptotics.IsLittleO_def : ∀ {α : Type u_17} {E : Type u_18} {F : Type u_19} [inst : Norm E] [inst_1 : Norm F] (l : Filter α) (f : α → E)
  (g : α → F), f =o[l] g = ∀ ⦃c : ℝ⦄, 0 < c → Asymptotics.IsBigOWith c l f g
unknown universe level 'u_17'
unknown universe level 'u_18'
unknown universe level 'u_19'

----
Failed for tsub_self : ∀ {α : Type u_1} [inst : CanonicallyOrderedAddCommMonoid α] [inst_1 : Sub α] [inst_2 : OrderedSub α] (a : α), a - a = 0
invalid binder annotation, type is not a class instance
  CanonicallyOrderedAddCommMonoid α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for RingHom.congr_fun : ∀ {α : Type u_2} {β : Type u_3} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} {f g : α →+* β},
  f = g → ∀ (x_2 : α), f x_2 = g x_2
Succeeded for And.imp_right : ∀ {a b c : Prop}, (a → b) → c ∧ a → c ∧ b
Failed for CategoryTheory.Limits.IsTerminal.hom_ext : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X Y : C},
  CategoryTheory.Limits.IsTerminal X → ∀ (f g : Y ⟶ X), f = g
unknown universe level 'v₁'

----
Succeeded for Multiset.mem_toFinset : ∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {s : Multiset α}, a ∈ s.toFinset ↔ a ∈ s
Succeeded for MeasureTheory.StronglyMeasurable.measurable : ∀ {α : Type u_1} {β : Type u_2} {f : α → β} {x : MeasurableSpace α} [inst : TopologicalSpace β]
  [inst_1 : TopologicalSpace.PseudoMetrizableSpace β] [inst_2 : MeasurableSpace β] [inst_3 : BorelSpace β],
  MeasureTheory.StronglyMeasurable f → Measurable f
Succeeded for Filter.HasBasis.map : ∀ {α : Type u_1} {β : Type u_2} {ι : Sort u_4} {l : Filter α} {p : ι → Prop} {s : ι → Set α} (f : α → β),
  l.HasBasis p s → (Filter.map f l).HasBasis p fun i => f '' s i
Succeeded for Finset.sum_apply : ∀ {α : Type u_1} {β : α → Type u_2} {γ : Type u_3} [inst : (a : α) → AddCommMonoid (β a)] (a : α) (s : Finset γ)
  (g : γ → (a : α) → β a), s.sum (fun c => g c) a = s.sum fun c => g c a
Succeeded for Filter.Tendsto.prod_mk_nhds : ∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {γ : Type u_5} {x : X} {y : Y}
  {f : Filter γ} {mx : γ → X} {my : γ → Y},
  Filter.Tendsto mx f (nhds x) → Filter.Tendsto my f (nhds y) → Filter.Tendsto (fun c => (mx c, my c)) f (nhds (x, y))
Succeeded for disjoint_comm : ∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : OrderBot α] {a b : α}, Disjoint a b ↔ Disjoint b a
Succeeded for Real.rpow_one : ∀ (x : ℝ), x ^ 1 = x
Succeeded for Finset.mem_powerset : ∀ {α : Type u_1} {s t : Finset α}, s ∈ t.powerset ↔ s ⊆ t
Succeeded for Matrix.cons_val_succ : ∀ {α : Type u} {m : ℕ} (x : α) (u : Fin m → α) (i : Fin m), Matrix.vecCons x u i.succ = u i
Succeeded for Finsupp.single_apply : ∀ {α : Type u_1} {M : Type u_5} [inst : Zero M] {a a' : α} {b : M} [inst_1 : Decidable (a = a')],
  (fun₀ | a => b) a' = if a = a' then b else 0
Succeeded for Finset.sum_map : ∀ {α : Type u_3} {β : Type u_4} {γ : Type u_5} [inst : AddCommMonoid β] (s : Finset α) (e : α ↪ γ) (f : γ → β),
  ((Finset.map e s).sum fun x => f x) = s.sum fun x => f (e x)
Succeeded for ne_top_of_le_ne_top : ∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderTop α] {a b : α}, b ≠ ⊤ → a ≤ b → a ≠ ⊤
Succeeded for List.reverse_append : ∀ {α : Type u} (as bs : List α), (as ++ bs).reverse = bs.reverse ++ as.reverse
Failed for QuotientAddGroup.leftRel_apply : ∀ {α : Type u_1} [inst : AddGroup α] {s : AddSubgroup α} {x y : α}, Setoid.r x y ↔ -x + y ∈ s
failed to synthesize
  Setoid α

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Succeeded for Mathlib.Algebra.Group.Basic._auxLemma.20 : ∀ {α : Type u_1} [inst : SubtractionMonoid α] {a : α}, (-a = 0) = (a = 0)
Succeeded for MulEquiv.ext : ∀ {M : Type u_6} {N : Type u_7} [inst : Mul M] [inst_1 : Mul N] {f g : M ≃* N}, (∀ (x : M), f x = g x) → f = g
Succeeded for Order.succ_le_iff : ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : SuccOrder α] {a b : α} [inst_2 : NoMaxOrder α], Order.succ a ≤ b ↔ a < b
Succeeded for isUnit_one : ∀ {M : Type u_1} [inst : Monoid M], IsUnit 1
Succeeded for dvd_mul_left : ∀ {α : Type u_1} [inst : CommSemigroup α] (a b : α), a ∣ b * a
Succeeded for sup_assoc : ∀ {α : Type u} [inst : SemilatticeSup α] (a b c : α), a ⊔ b ⊔ c = a ⊔ (b ⊔ c)
Succeeded for isOpen_iUnion : ∀ {X : Type u} {ι : Sort w} [inst : TopologicalSpace X] {f : ι → Set X}, (∀ (i : ι), IsOpen (f i)) → IsOpen (⋃ i, f i)
Succeeded for IsUnit.mk0 : ∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] (x : G₀), x ≠ 0 → IsUnit x
Succeeded for Set.univ_subset_iff : ∀ {α : Type u} {s : Set α}, Set.univ ⊆ s ↔ s = Set.univ
Failed for Mathlib.Data.Multiset.Basic._auxLemma.7 : ∀ {α : Type u_1} (a : α), (a ∈ 0) = False
failed to synthesize
  Membership α ℕ

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Succeeded for Ordinal.zero_le : ∀ (o : Ordinal.{u_3}), 0 ≤ o
Succeeded for CategoryTheory.Limits.coprod.desc_comp : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {V W X Y : C}
  [inst_1 : CategoryTheory.Limits.HasBinaryCoproduct X Y] (f : V ⟶ W) (g : X ⟶ V) (h : Y ⟶ V),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coprod.desc g h) f =
    CategoryTheory.Limits.coprod.desc (CategoryTheory.CategoryStruct.comp g f) (CategoryTheory.CategoryStruct.comp h f)
Succeeded for RingHom.map_pow : ∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] (f : R →+* S) (a : R) (n : ℕ),
  f (a ^ n) = f a ^ n
Failed for MeasureTheory.ae_eq_refl : ∀ {α : Type u_1} {δ : Type u_4} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} (f : α → δ),
  μ.ae.EventuallyEq f f
Invalid field `ae`: The environment does not contain `MeasureTheory.Measure.ae`
  μ
has type
  MeasureTheory.Measure α

----
Succeeded for le_iInf₂ : ∀ {α : Type u_1} {ι : Sort u_5} {κ : ι → Sort u_7} [inst : CompleteLattice α] {a : α} {f : (i : ι) → κ i → α},
  (∀ (i : ι) (j : κ i), a ≤ f i j) → a ≤ ⨅ i, ⨅ j, f i j
Failed for PNat.pos : ∀ (n : ℕ+), 0 < ↑n
failed to synthesize
  OfNat ℕ+ 0
numerals are polymorphic in Lean, but the numeral `0` cannot be used in a context where the expected type is
  ℕ+
due to the absence of the instance above

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Succeeded for mem_nhds_iff : ∀ {X : Type u} {x : X} {s : Set X} [inst : TopologicalSpace X], s ∈ nhds x ↔ ∃ t ⊆ s, IsOpen t ∧ x ∈ t
Succeeded for MonoidHom.map_pow : ∀ {M : Type u_4} {N : Type u_5} [inst : Monoid M] [inst_1 : Monoid N] (f : M →* N) (a : M) (n : ℕ), f (a ^ n) = f a ^ n
Succeeded for Set.inter_assoc : ∀ {α : Type u} (a b c : Set α), a ∩ b ∩ c = a ∩ (b ∩ c)
Failed for MeasureTheory.measure_empty : ∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α}, ↑↑μ ∅ = 0
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known

----
Succeeded for EquivLike.injective : ∀ {E : Sort u_1} {α : Sort u_3} {β : Sort u_4} [iE : EquivLike E α β] (e : E), Function.Injective ⇑e
Succeeded for Filter.comap_inf : ∀ {α : Type u} {β : Type v} {g₁ g₂ : Filter β} {m : α → β},
  Filter.comap m (g₁ ⊓ g₂) = Filter.comap m g₁ ⊓ Filter.comap m g₂
Succeeded for CharP.cast_eq_zero_iff : ∀ (R : Type u) [inst : AddMonoidWithOne R] (p : ℕ) [inst_1 : CharP R p] (x : ℕ), ↑x = 0 ↔ p ∣ x
Succeeded for add_right_injective : ∀ {G : Type u_3} [inst : Add G] [inst_1 : IsLeftCancelAdd G] (a : G), Function.Injective fun x => a + x
Succeeded for sub_le_iff_le_add : ∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]
  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b c : α},
  a - c ≤ b ↔ a ≤ b + c
Succeeded for Measurable.add : ∀ {M : Type u_2} {α : Type u_3} [inst : MeasurableSpace M] [inst_1 : Add M] {m : MeasurableSpace α} {f g : α → M}
  [inst_2 : MeasurableAdd₂ M], Measurable f → Measurable g → Measurable fun a => f a + g a
Succeeded for Filter.EventuallyEq.fun_comp : ∀ {α : Type u} {β : Type v} {γ : Type w} {f g : α → β} {l : Filter α},
  l.EventuallyEq f g → ∀ (h : β → γ), l.EventuallyEq (h ∘ f) (h ∘ g)
Succeeded for bot_lt_iff_ne_bot : ∀ {α : Type u} [inst : PartialOrder α] [inst_1 : OrderBot α] {a : α}, ⊥ < a ↔ a ≠ ⊥
Succeeded for Set.Nonempty.to_subtype : ∀ {α : Type u} {s : Set α}, s.Nonempty → Nonempty ↑s
Failed for CategoryTheory.Subobject.eq_of_comp_arrow_eq : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X Y : C} {P : CategoryTheory.Subobject Y}
  {f g : X ⟶ CategoryTheory.Subobject.underlying.obj P},
  CategoryTheory.CategoryStruct.comp f P.arrow = CategoryTheory.CategoryStruct.comp g P.arrow → f = g
unknown universe level 'v₁'

----
Succeeded for Nat.not_lt_zero : ∀ (n : ℕ), ¬n < 0
Succeeded for Set.range_iff_surjective : ∀ {α : Type u_1} {ι : Sort u_4} {f : ι → α}, Set.range f = Set.univ ↔ Function.Surjective f
Succeeded for Mathlib.Data.Nat.Cast.Basic._auxLemma.2 : ∀ {α : Type u_1} [inst : Semiring α] (m n : ℕ), ↑m ^ n = ↑(m ^ n)
Succeeded for Multiset.sum_cons : ∀ {α : Type u_2} [inst : AddCommMonoid α] (a : α) (s : Multiset α), (a ::ₘ s).sum = a + s.sum
Succeeded for Int.natAbs_neg : ∀ (a : ℤ), (-a).natAbs = a.natAbs
Failed for ContDiffAt.comp : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {G : Type uG}
  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace 𝕜 G] {f : E → F} {g : F → G} {n : ℕ∞} (x : E),
  ContDiffAt 𝕜 n g (f x) → ContDiffAt 𝕜 n f x → ContDiffAt 𝕜 n (g ∘ f) x
unknown universe level 'uE'
unknown universe level 'uF'
unknown universe level 'uG'

----
Succeeded for Set.Countable.image : ∀ {α : Type u} {β : Type v} {s : Set α}, s.Countable → ∀ (f : α → β), (f '' s).Countable
Succeeded for UpperSet.ext : ∀ {α : Type u_1} [inst : LE α] {s t : UpperSet α}, ↑s = ↑t → s = t
Succeeded for Cardinal.lift_natCast : ∀ (n : ℕ), Cardinal.lift.{u, v} ↑n = ↑n
Succeeded for map_div₀ : ∀ {G₀ : Type u_3} {G₀' : Type u_5} {F : Type u_6} [inst : GroupWithZero G₀] [inst_1 : GroupWithZero G₀']
  [inst_2 : FunLike F G₀ G₀'] [inst_3 : MonoidWithZeroHomClass F G₀ G₀'] (f : F) (a b : G₀), f (a / b) = f a / f b
Succeeded for Ideal.mul_mem_left : ∀ {α : Type u} [inst : Semiring α] (I : Ideal α) (a : α) {b : α}, b ∈ I → a * b ∈ I
Succeeded for Prime.irreducible : ∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] {p : α}, Prime p → Irreducible p
Succeeded for Nat.sub_le : ∀ (n m : ℕ), n - m ≤ n
Succeeded for Ideal.eq_top_iff_one : ∀ {α : Type u} [inst : Semiring α] (I : Ideal α), I = ⊤ ↔ 1 ∈ I
Succeeded for Set.image_add_left : ∀ {α : Type u_2} [inst : AddGroup α] {t : Set α} {a : α}, (fun x => a + x) '' t = (fun x => -a + x) ⁻¹' t
Succeeded for MulEquiv.map_mul : ∀ {M : Type u_6} {N : Type u_7} [inst : Mul M] [inst_1 : Mul N] (f : M ≃* N) (x y : M), f (x * y) = f x * f y
Succeeded for neg_ne_zero : ∀ {α : Type u_1} [inst : SubtractionMonoid α] {a : α}, -a ≠ 0 ↔ a ≠ 0
Succeeded for LE.le.lt_iff_ne : ∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → (a < b ↔ a ≠ b)
Succeeded for not_imp_comm : ∀ {a b : Prop}, ¬a → b ↔ ¬b → a
Succeeded for GaloisConnection.l_u_le : ∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α},
  GaloisConnection l u → ∀ (a : β), l (u a) ≤ a
Succeeded for sub_add : ∀ {α : Type u_1} [inst : SubtractionCommMonoid α] (a b c : α), a - b + c = a - (b - c)
Succeeded for Set.subset_inter : ∀ {α : Type u} {s t r : Set α}, r ⊆ s → r ⊆ t → r ⊆ s ∩ t
Succeeded for Finset.mem_erase : ∀ {α : Type u_1} [inst : DecidableEq α] {a b : α} {s : Finset α}, a ∈ s.erase b ↔ a ≠ b ∧ a ∈ s
Failed for MeasureTheory.Measure.prod_prod : ∀ {α : Type u_1} {β : Type u_3} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {μ : MeasureTheory.Measure α}
  {ν : MeasureTheory.Measure β} [inst_2 : MeasureTheory.SFinite ν] (s : Set α) (t : Set β),
  ↑↑(μ.prod ν) (s ×ˢ t) = ↑↑μ s * ↑↑ν t
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known

----
Succeeded for Finset.Subset.refl : ∀ {α : Type u_1} (s : Finset α), s ⊆ s
Succeeded for CategoryTheory.Groupoid.inv_eq_inv : ∀ {C : Type u} [inst : CategoryTheory.Groupoid C] {X Y : C} (f : X ⟶ Y),
  CategoryTheory.Groupoid.inv f = CategoryTheory.inv f
Succeeded for Matrix.diagonal_apply_eq : ∀ {n : Type u_3} {α : Type v} [inst : DecidableEq n] [inst_1 : Zero α] (d : n → α) (i : n), Matrix.diagonal d i i = d i
Succeeded for inf_eq_left : ∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b = a ↔ a ≤ b
Succeeded for sub_neg_of_lt : ∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]
  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, a < b → a - b < 0
Succeeded for LinearMap.ker_eq_bot : ∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_6} {M₂ : Type u_8} [inst : Ring R] [inst_1 : Ring R₂]
  [inst_2 : AddCommGroup M] [inst_3 : AddCommGroup M₂] [inst_4 : Module R M] [inst_5 : Module R₂ M₂] {τ₁₂ : R →+* R₂}
  {f : M →ₛₗ[τ₁₂] M₂}, LinearMap.ker f = ⊥ ↔ Function.Injective ⇑f
Failed for inducing_subtype_val : ∀ {Y : Type v} [inst : TopologicalSpace Y] {t : Set Y}, Inducing Subtype.val
Function expected at
  Inducing
but this term has type
  ?m.12

Note: Expected a function because this term is being applied to the argument
  Subtype.val

----
Succeeded for Multiset.card_map : ∀ {α : Type u_1} {β : Type v} (f : α → β) (s : Multiset α), Multiset.card (Multiset.map f s) = Multiset.card s
Succeeded for smul_inv_smul₀ : ∀ {α : Type u} {β : Type v} [inst : GroupWithZero α] [inst_1 : MulAction α β] {c : α},
  c ≠ 0 → ∀ (x : β), c • c⁻¹ • x = x
Succeeded for Function.Surjective.exists : ∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.Surjective f → ∀ {p : β → Prop}, (∃ y, p y) ↔ ∃ x, p (f x)
Succeeded for le_of_add_le_add_left : ∀ {α : Type u_1} [inst : Add α] [inst_1 : LE α]
  [inst_2 : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b c : α}, a + b ≤ a + c → b ≤ c
Succeeded for AlgHom.congr_fun : ∀ {R : Type u} {A : Type v} {B : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Semiring B]
  [inst_3 : Algebra R A] [inst_4 : Algebra R B] {φ₁ φ₂ : A →ₐ[R] B}, φ₁ = φ₂ → ∀ (x : A), φ₁ x = φ₂ x
Succeeded for Set.mapsTo_image : ∀ {α : Type u} {β : Type v} (f : α → β) (s : Set α), Set.MapsTo f s (f '' s)
Failed for real_inner_comm : ∀ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F), ⟪y, x⟫_ℝ = ⟪x, y⟫_ℝ
<input>:1:96: expected token
----
Succeeded for isOpen_Ioo : ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderClosedTopology α] {a b : α},
  IsOpen (Set.Ioo a b)
Succeeded for Disjoint.mono_left : ∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : OrderBot α] {a b c : α}, a ≤ b → Disjoint b c → Disjoint a c
Succeeded for add_lt_add_of_lt_of_le : ∀ {α : Type u_1} [inst : Add α] [inst_1 : Preorder α]
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]
  [inst_3 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b c d : α},
  a < b → c ≤ d → a + c < b + d
Succeeded for Mathlib.Order.MinMax._auxLemma.2 : ∀ {α : Type u} [inst : LinearOrder α] {a b c : α}, (a ≤ max b c) = (a ≤ b ∨ a ≤ c)
Succeeded for Nat.succ_lt_succ : ∀ {n m : ℕ}, n < m → n.succ < m.succ
Succeeded for HasDerivAt.hasDerivWithinAt : ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {F : Type v} [inst_1 : NormedAddCommGroup F]
  [inst_2 : NormedSpace 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜} {s : Set 𝕜}, HasDerivAt f f' x → HasDerivWithinAt f f' s x
Succeeded for Finset.singleton_subset_iff : ∀ {α : Type u_1} {s : Finset α} {a : α}, {a} ⊆ s ↔ a ∈ s
Succeeded for Real.rpow_nonneg : ∀ {x : ℝ}, 0 ≤ x → ∀ (y : ℝ), 0 ≤ x ^ y
Succeeded for Polynomial.map_mul : ∀ {R : Type u} {S : Type v} [inst : Semiring R] {p q : Polynomial R} [inst_1 : Semiring S] (f : R →+* S),
  Polynomial.map f (p * q) = Polynomial.map f p * Polynomial.map f q
Succeeded for NormedSpace.expSeries_radius_eq_top : ∀ (𝕂 : Type u_1) (𝔸 : Type u_2) [inst : RCLike 𝕂] [inst_1 : NormedRing 𝔸] [inst_2 : NormedAlgebra 𝕂 𝔸],
  (NormedSpace.expSeries 𝕂 𝔸).radius = ⊤
Succeeded for Set.Finite.union : ∀ {α : Type u} {s t : Set α}, s.Finite → t.Finite → (s ∪ t).Finite
Failed for MeasureTheory.integral_congr_ae : ∀ {α : Type u_1} {G : Type u_5} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}
  {μ : MeasureTheory.Measure α} {f g : α → G}, μ.ae.EventuallyEq f g → ∫ (a : α), f a ∂μ = ∫ (a : α), g a ∂μ
Invalid field `ae`: The environment does not contain `MeasureTheory.Measure.ae`
  μ
has type
  MeasureTheory.Measure α

----
Succeeded for add_sub_assoc : ∀ {G : Type u_3} [inst : SubNegMonoid G] (a b c : G), a + b - c = a + (b - c)
Succeeded for measurable_pi_iff : ∀ {α : Type u_1} {δ : Type u_4} {π : δ → Type u_6} [inst : MeasurableSpace α] [inst_1 : (a : δ) → MeasurableSpace (π a)]
  {g : α → (a : δ) → π a}, Measurable g ↔ ∀ (a : δ), Measurable fun x => g x a
Failed for MeasureTheory.integral_const : ∀ {α : Type u_1} {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [hE : CompleteSpace E]
  {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} (c : E), ∫ (x : α), c ∂μ = (↑↑μ Set.univ).toReal • c
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known

----
Succeeded for Mathlib.GroupTheory.Perm.Support._auxLemma.15 : ∀ {α : Type u_1} [inst : DecidableEq α] [inst_1 : Fintype α] {f : Equiv.Perm α} {x : α}, (x ∈ f.support) = (f x ≠ x)
Failed for Sum.inl.injEq : ∀ {α : Type u} {β : Type v} (val val_1 : α), (Sum.inl val = Sum.inl val_1) = (val = val_1)
don't know how to synthesize implicit argument 'α'
  @Eq (α ⊕ ?m.59 val val_1) (Sum.inl val) (Sum.inl val_1)
context:
α : Type u
β : Type v
val val_1 : α
⊢ Type (max u ?u.13)

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'β'
  @Sum.inl α (?m.59 val val_1) val_1
context:
α : Type u
β : Type v
val val_1 : α
⊢ Type ?u.13

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'β'
  @Sum.inl α (?m.59 val val_1) val
context:
α : Type u
β : Type v
val val_1 : α
⊢ Type ?u.13

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for le_inf_iff : ∀ {α : Type u} [inst : SemilatticeInf α] {a b c : α}, a ≤ b ⊓ c ↔ a ≤ b ∧ a ≤ c
Succeeded for Mathlib.Data.Nat.Cast.Basic._auxLemma.1 : ∀ {α : Type u_1} [inst : NonAssocSemiring α] (m n : ℕ), ↑m * ↑n = ↑(m * n)
Failed for nsmul_zero : ∀ {A : Type y} [inst : AddMonoid A] (n : ℕ), n • 0 = 0
unknown universe level 'y'

----
Succeeded for Finset.sup_le : ∀ {α : Type u_2} {β : Type u_3} [inst : SemilatticeSup α] [inst_1 : OrderBot α] {s : Finset β} {f : β → α} {a : α},
  (∀ b ∈ s, f b ≤ a) → s.sup f ≤ a
Failed for CategoryTheory.Limits.limMap_π : ∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] {C : Type u} [inst_1 : CategoryTheory.Category.{v, u} C]
  {F G : CategoryTheory.Functor J C} [inst_2 : CategoryTheory.Limits.HasLimit F]
  [inst_3 : CategoryTheory.Limits.HasLimit G] (α : F ⟶ G) (j : J),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limMap α) (CategoryTheory.Limits.limit.π G j) =
    CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j) (α.app j)
unknown universe level 'v₁'

----
Succeeded for Equiv.eq_symm_apply : ∀ {α : Sort u_1} {β : Sort u_2} (e : α ≃ β) {x : β} {y : α}, y = e.symm x ↔ e y = x
Succeeded for zpow_add : ∀ {G : Type w} [inst : Group G] (a : G) (m n : ℤ), a ^ (m + n) = a ^ m * a ^ n
Succeeded for Nat.Coprime.symm : ∀ {n m : ℕ}, n.Coprime m → m.Coprime n
Succeeded for Set.preimage_univ : ∀ {α : Type u_1} {β : Type u_2} {f : α → β}, f ⁻¹' Set.univ = Set.univ
Succeeded for Function.Bijective.surjective : ∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.Bijective f → Function.Surjective f
Succeeded for Subtype.coe_le_coe : ∀ {α : Type u} [inst : LE α] {p : α → Prop} {x y : Subtype p}, ↑x ≤ ↑y ↔ x ≤ y
Succeeded for Polynomial.coeff_monomial : ∀ {R : Type u} {a : R} {m n : ℕ} [inst : Semiring R], ((Polynomial.monomial n) a).coeff m = if n = m then a else 0
Succeeded for Finset.disjoint_left : ∀ {α : Type u_1} {s t : Finset α}, Disjoint s t ↔ ∀ ⦃a : α⦄, a ∈ s → a ∉ t
Succeeded for norm_add_le : ∀ {E : Type u_6} [inst : SeminormedAddGroup E] (a b : E), ‖a + b‖ ≤ ‖a‖ + ‖b‖
Succeeded for minpoly.monic : ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B},
  IsIntegral A x → (minpoly A x).Monic
Succeeded for Set.mem_toFinset : ∀ {α : Type u_1} {s : Set α} [inst : Fintype ↑s] {a : α}, a ∈ s.toFinset ↔ a ∈ s
Succeeded for inv_smul_smul : ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : MulAction α β] (c : α) (x : β), c⁻¹ • c • x = x
Succeeded for Nat.zero_div : ∀ (b : ℕ), 0 / b = 0
Succeeded for inv_smul_smul₀ : ∀ {α : Type u} {β : Type v} [inst : GroupWithZero α] [inst_1 : MulAction α β] {c : α},
  c ≠ 0 → ∀ (x : β), c⁻¹ • c • x = x
Succeeded for eq_of_dist_eq_zero : ∀ {γ : Type w} [inst : MetricSpace γ] {x y : γ}, dist x y = 0 → x = y
Succeeded for Submonoid.LocalizationMap.map_units : ∀ {M : Type u_1} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_2} [inst_1 : CommMonoid N]
  (f : S.LocalizationMap N) (y : ↥S), IsUnit (f.toMap ↑y)
Failed for DirectedOn.directed_val : ∀ {α : Type u} {r : α → α → Prop} {s : Set α}, DirectedOn r s → Directed r Subtype.val
don't know how to synthesize implicit argument 'ι'
  @Directed α (Subtype ?m.45) r Subtype.val
context:
α : Type u
r : α → α → Prop
s : Set α
⊢ Type (max 0 u)

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'p'
  @Subtype.val α ?m.45
context:
α : Type u
r : α → α → Prop
s : Set α
⊢ α → Prop

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for Int.ofNat_lt : ∀ {n m : ℕ}, ↑n < ↑m ↔ n < m
Succeeded for Int.neg_neg : ∀ (a : ℤ), - -a = a
Succeeded for subsingleton_or_nontrivial : ∀ (α : Type u_3), Subsingleton α ∨ Nontrivial α
Succeeded for Finset.cons_eq_insert : ∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (s : Finset α) (h : a ∉ s), Finset.cons a s h = insert a s
Succeeded for GaloisConnection.u_top : ∀ {α : Type u} {β : Type v} [inst : PartialOrder α] [inst_1 : Preorder β] [inst_2 : OrderTop α] [inst_3 : OrderTop β]
  {l : α → β} {u : β → α}, GaloisConnection l u → u ⊤ = ⊤
Succeeded for two_ne_zero' : ∀ (α : Type u_2) [inst : Zero α] [inst_1 : OfNat α 2] [inst_2 : NeZero 2], 2 ≠ 0
Succeeded for Not.intro : ∀ {a : Prop}, (a → False) → ¬a
Succeeded for Matrix.det_transpose : ∀ {n : Type u_2} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] (M : Matrix n n R),
  M.transpose.det = M.det
Failed for Finset.not_mem_empty : ∀ {α : Type u_1} (a : α), a ∉ ∅
typeclass instance problem is stuck, it is often due to metavariables
  Membership α (?m.370 a)

----
Succeeded for Equiv.exists_congr_left : ∀ {α : Sort u_1} {β : Sort u_2} (f : α ≃ β) {p : α → Prop}, (∃ a, p a) ↔ ∃ b, p (f.symm b)
Succeeded for Set.diff_eq : ∀ {α : Type u} (s t : Set α), s \ t = s ∩ tᶜ
Succeeded for Subgroup.subset_closure : ∀ {G : Type u_1} [inst : Group G] {k : Set G}, k ⊆ ↑(Subgroup.closure k)
Succeeded for Matrix.cons_val_fin_one : ∀ {α : Type u} (x : α) (u : Fin 0 → α) (i : Fin 1), Matrix.vecCons x u i = x
Succeeded for Mathlib.Data.FunLike.Embedding._auxLemma.1 : ∀ {F : Sort u_1} {α : Sort u_2} {β : Sort u_3} [inst : FunLike F α β] [i : EmbeddingLike F α β] (f : F) {x y : α},
  (f x = f y) = (x = y)
Succeeded for MulEquiv.symm_apply_apply : ∀ {M : Type u_6} {N : Type u_7} [inst : Mul M] [inst_1 : Mul N] (e : M ≃* N) (x : M), e.symm (e x) = x
Succeeded for measurableSet_Ioi : ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : OpensMeasurableSpace α]
  [inst_3 : LinearOrder α] [inst : OrderClosedTopology α] {a : α}, MeasurableSet (Set.Ioi a)
Succeeded for add_right_inj : ∀ {G : Type u_3} [inst : Add G] [inst_1 : IsLeftCancelAdd G] (a : G) {b c : G}, a + b = a + c ↔ b = c
Failed for Set.biUnion_eq_iUnion : ∀ {α : Type u_1} {β : Type u_2} (s : Set α) (t : (x : α) → x ∈ s → Set β), ⋃ x, ⋃ (h : x ∈ s), t x h = ⋃ x, t ↑x ⋯
don't know how to synthesize placeholder
context:
α : Type u_1
β : Type u_2
s : Set α
t : (x : α) → x ∈ s → Set β
x : α
⊢ x ∈ s

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for ENNReal.toReal_ofReal : ∀ {r : ℝ}, 0 ≤ r → (ENNReal.ofReal r).toReal = r
Succeeded for CategoryTheory.Limits.IsZero.eq_of_src : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C},
  CategoryTheory.Limits.IsZero X → ∀ (f g : X ⟶ Y), f = g
Succeeded for Polynomial.eval_pow : ∀ {R : Type u} [inst : CommSemiring R] {p : Polynomial R} {x : R} (n : ℕ),
  Polynomial.eval x (p ^ n) = Polynomial.eval x p ^ n
Failed for Quotient.eq'' : ∀ {α : Sort u_1} {s₁ : Setoid α} {a b : α}, Quotient.mk'' a = Quotient.mk'' b ↔ Setoid.r a b
don't know how to synthesize implicit argument 'α'
  @Eq (Quotient ?m.55) (Quotient.mk'' a) (Quotient.mk'' b)
context:
α : Sort u_1
s₁ : Setoid α
a b : α
⊢ Sort u_1

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 's₁'
  @Quotient.mk'' α ?m.55 b
context:
α : Sort u_1
s₁ : Setoid α
a b : α
⊢ Setoid α

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 's₁'
  @Quotient.mk'' α ?m.55 a
context:
α : Sort u_1
s₁ : Setoid α
a b : α
⊢ Setoid α

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Failed for inv_nonneg : ∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {a : α}, 0 ≤ a⁻¹ ↔ 0 ≤ a
invalid binder annotation, type is not a class instance
  LinearOrderedSemifield α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for Continuous.continuousWithinAt : ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β} {s : Set α}
  {x : α}, Continuous f → ContinuousWithinAt f s x
Succeeded for CategoryTheory.Limits.KernelFork.condition : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X Y : C}
  {f : X ⟶ Y} (s : CategoryTheory.Limits.KernelFork f),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.ι s) f = 0
Succeeded for Nat.le_div_iff_mul_le : ∀ {k x y : ℕ}, 0 < k → (x ≤ y / k ↔ x * k ≤ y)
Succeeded for inv_mul_self : ∀ {G : Type u_1} [inst : Group G] (a : G), a⁻¹ * a = 1
Succeeded for LinearEquiv.injective : ∀ {R : Type u_1} {S : Type u_6} {M : Type u_7} {M₂ : Type u_9} [inst : Semiring R] [inst_1 : Semiring S]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] {module_M : Module R M} {module_S_M₂ : Module S M₂}
  {σ : R →+* S} {σ' : S →+* R} {re₁ : RingHomInvPair σ σ'} {re₂ : RingHomInvPair σ' σ} (e : M ≃ₛₗ[σ] M₂),
  Function.Injective ⇑e
Failed for nnnorm_zero : ∀ {E : Type u_6} [inst : SeminormedAddGroup E], ‖0‖₊ = 0
failed to synthesize
  NNNorm ℕ

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Failed for measurable_pi_apply : ∀ {δ : Type u_4} {π : δ → Type u_6} [inst : (a : δ) → MeasurableSpace (π a)] (a : δ), Measurable fun f => f a
Function expected at
  f
but this term has type
  ?m.314 a

Note: Expected a function because this term is being applied to the argument
  a

----
Succeeded for Real.Angle.induction_on : ∀ {p : Real.Angle → Prop} (θ : Real.Angle), (∀ (x : ℝ), p ↑x) → p θ
Succeeded for sup_of_le_right : ∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, a ≤ b → a ⊔ b = b
Succeeded for Continuous.const_smul : ∀ {M : Type u_1} {α : Type u_2} {β : Type u_3} [inst : TopologicalSpace α] [inst_1 : SMul M α]
  [inst_2 : ContinuousConstSMul M α] [inst_3 : TopologicalSpace β] {g : β → α},
  Continuous g → ∀ (c : M), Continuous fun x => c • g x
Succeeded for Nat.mod_zero : ∀ (a : ℕ), a % 0 = a
Succeeded for sup_le_sup : ∀ {α : Type u} [inst : SemilatticeSup α] {a b c d : α}, a ≤ b → c ≤ d → a ⊔ c ≤ b ⊔ d
Succeeded for max_lt : ∀ {α : Type u} [inst : LinearOrder α] {a b c : α}, a < c → b < c → max a b < c
Succeeded for ENNReal.coe_toNNReal : ∀ {a : ENNReal}, a ≠ ⊤ → ↑a.toNNReal = a
Succeeded for sSup_le : ∀ {α : Type u_1} [inst : CompleteSemilatticeSup α] {s : Set α} {a : α}, (∀ b ∈ s, b ≤ a) → sSup s ≤ a
Succeeded for AddSubmonoid.add_mem : ∀ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M) {x y : M}, x ∈ S → y ∈ S → x + y ∈ S
Succeeded for smul_inv_smul : ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : MulAction α β] (c : α) (x : β), c • c⁻¹ • x = x
Succeeded for neg_one_mul : ∀ {α : Type u} [inst : MulOneClass α] [inst_1 : HasDistribNeg α] (a : α), -1 * a = -a
Succeeded for Filter.HasBasis.mem_of_mem : ∀ {α : Type u_1} {ι : Sort u_4} {l : Filter α} {p : ι → Prop} {s : ι → Set α} {i : ι}, l.HasBasis p s → p i → s i ∈ l
Succeeded for List.Perm.refl : ∀ {α : Type u_1} (l : List α), l.Perm l
Failed for forall_prop_domain_congr : ∀ {p₁ p₂ : Prop} {q₁ : p₁ → Prop} {q₂ : p₂ → Prop} (h₁ : p₁ = p₂),
  (∀ (a : p₂), q₁ ⋯ = q₂ a) → (∀ (a : p₁), q₁ a) = ∀ (a : p₂), q₂ a
don't know how to synthesize placeholder
context:
p₁ p₂ : Prop
q₁ : p₁ → Prop
q₂ : p₂ → Prop
h₁ : p₁ = p₂
a : p₂
⊢ p₁

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for max_le_max : ∀ {α : Type u} [inst : LinearOrder α] {a b c d : α}, a ≤ c → b ≤ d → max a b ≤ max c d
Succeeded for Subtype.coe_prop : ∀ {α : Type u_1} {S : Set α} (a : { a // a ∈ S }), ↑a ∈ S
Succeeded for MvPolynomial.eval₂_C : ∀ {R : Type u} {S₁ : Type v} {σ : Type u_1} [inst : CommSemiring R] [inst_1 : CommSemiring S₁] (f : R →+* S₁)
  (g : σ → S₁) (a : R), MvPolynomial.eval₂ f g (MvPolynomial.C a) = f a
Succeeded for or_iff_right : ∀ {a b : Prop}, ¬a → (a ∨ b ↔ b)
Failed for QuaternionAlgebra.ext : ∀ {R : Type u_1} {a b : R} (x y : QuaternionAlgebra R a b),
  x.re = y.re → x.imI = y.imI → x.imJ = y.imJ → x.imK = y.imK → x = y
type expected, got
  (QuaternionAlgebra R a b : R → Type u_1)

----
Succeeded for abs_pos : ∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : LinearOrder α]
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α}, 0 < |a| ↔ a ≠ 0
Succeeded for Finset.subset_union_left : ∀ {α : Type u_1} [inst : DecidableEq α] (s₁ s₂ : Finset α), s₁ ⊆ s₁ ∪ s₂
Succeeded for map_inv : ∀ {G : Type u_7} {H : Type u_8} {F : Type u_9} [inst : FunLike F G H] [inst_1 : Group G] [inst_2 : DivisionMonoid H]
  [inst_3 : MonoidHomClass F G H] (f : F) (a : G), f a⁻¹ = (f a)⁻¹
Succeeded for CategoryTheory.Iso.comp_inv_eq : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y Z : C} (α : X ≅ Y) {f : Z ⟶ Y} {g : Z ⟶ X},
  CategoryTheory.CategoryStruct.comp f α.inv = g ↔ f = CategoryTheory.CategoryStruct.comp g α.hom
Succeeded for vsub_add_vsub_cancel : ∀ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (p₁ p₂ p₃ : P), p₁ -ᵥ p₂ + (p₂ -ᵥ p₃) = p₁ -ᵥ p₃
Succeeded for Order.le_succ : ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : SuccOrder α] (a : α), a ≤ Order.succ a
Succeeded for Finset.sum_cons : ∀ {α : Type u_3} {β : Type u_4} {s : Finset α} {a : α} {f : α → β} [inst : AddCommMonoid β] (h : a ∉ s),
  ((Finset.cons a s h).sum fun x => f x) = f a + s.sum fun x => f x
Succeeded for RingEquiv.ext : ∀ {R : Type u_4} {S : Type u_5} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] {f g : R ≃+* S},
  (∀ (x : R), f x = g x) → f = g
Failed for CategoryTheory.isIso_of_reflects_iso : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  {A B : C} (f : A ⟶ B) (F : CategoryTheory.Functor C D) [inst_2 : CategoryTheory.IsIso (F.map f)]
  [inst_3 : F.ReflectsIsomorphisms], CategoryTheory.IsIso f
unknown universe level 'v₁'

----
Succeeded for mul_ite : ∀ {α : Type u_1} [inst : Mul α] (P : Prop) [inst_1 : Decidable P] (a b c : α),
  (a * if P then b else c) = if P then a * b else a * c
Succeeded for LT.lt.trans_eq : ∀ {α : Type u} {a b c : α} [inst : LT α], a < b → b = c → a < c
Succeeded for mul_left_cancel : ∀ {G : Type u_1} [inst : Mul G] [inst_1 : IsLeftCancelMul G] {a b c : G}, a * b = a * c → b = c
Succeeded for sub_eq_neg_add : ∀ {α : Type u_1} [inst : SubtractionCommMonoid α] (a b : α), a - b = -b + a
Succeeded for Mathlib.Logic.Basic._auxLemma.40 : ∀ (p : True → Prop), (∀ (x : True), p x) = p True.intro
Succeeded for not_lt_of_le : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a ≤ b → ¬b < a
Succeeded for not_lt_of_ge : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a ≥ b → ¬a < b
Succeeded for Polynomial.natDegree_C : ∀ {R : Type u} [inst : Semiring R] (a : R), (Polynomial.C a).natDegree = 0
Succeeded for mul_lt_mul_of_pos_right : ∀ {α : Type u_1} {a b c : α} [inst : Mul α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : MulPosStrictMono α],
  b < c → 0 < a → b * a < c * a
Failed for Pi.add_apply : ∀ {I : Type u} {f : I → Type v₁} (x y : (i : I) → f i) (i : I) [inst : (i : I) → Add (f i)], (x + y) i = x i + y i
unknown universe level 'v₁'
invalid parametric local instance, parameter with type
  I
does not have forward dependencies, type class resolution cannot use this kind of local instance because it will not be able to infer a value for this parameter.

----
Succeeded for Filter.tendsto_map'_iff : ∀ {α : Type u} {β : Type v} {γ : Type w} {f : β → γ} {g : α → β} {x : Filter α} {y : Filter γ},
  Filter.Tendsto f (Filter.map g x) y ↔ Filter.Tendsto (f ∘ g) x y
Succeeded for Finset.sum_subset : ∀ {α : Type u_3} {β : Type u_4} {s₁ s₂ : Finset α} {f : α → β} [inst : AddCommMonoid β],
  s₁ ⊆ s₂ → (∀ x ∈ s₂, x ∉ s₁ → f x = 0) → (s₁.sum fun x => f x) = s₂.sum fun x => f x
Succeeded for and_congr_right' : ∀ {b c a : Prop}, (b ↔ c) → (a ∧ b ↔ a ∧ c)
Succeeded for Filter.principal_singleton : ∀ {α : Type u} (a : α), Filter.principal {a} = pure a
Succeeded for Nat.zero_mod : ∀ (b : ℕ), 0 % b = 0
Succeeded for Nat.zero_mul : ∀ (n : ℕ), 0 * n = 0
Succeeded for Finset.sum_ite_eq' : ∀ {α : Type u_3} {β : Type u_4} [inst : AddCommMonoid β] [inst_1 : DecidableEq α] (s : Finset α) (a : α) (b : α → β),
  (s.sum fun x => if x = a then b x else 0) = if a ∈ s then b a else 0
Succeeded for Nat.Prime.two_le : ∀ {p : ℕ}, p.Prime → 2 ≤ p
Succeeded for isCompl_compl : ∀ {α : Type u} {x : α} [inst : BooleanAlgebra α], IsCompl x xᶜ
Succeeded for Mathlib.Data.Finsupp.Defs._auxLemma.1 : ∀ {α : Type u_1} {M : Type u_5} [inst : Zero M] {f : α →₀ M} {a : α}, (a ∈ f.support) = (f a ≠ 0)
Succeeded for Finset.nonempty_iff_ne_empty : ∀ {α : Type u_1} {s : Finset α}, s.Nonempty ↔ s ≠ ∅
Succeeded for Nat.add_sub_cancel : ∀ (n m : ℕ), n + m - m = n
Succeeded for CategoryTheory.Discrete.ext : ∀ {α : Type u₁} (x y : CategoryTheory.Discrete α), x.as = y.as → x = y
Failed for Sbtw.wbtw : ∀ {R : Type u_1} {V : Type u_2} {P : Type u_4} [inst : OrderedRing R] [inst_1 : AddCommGroup V] [inst_2 : Module R V]
  [inst_3 : AddTorsor V P] {x y z : P}, Sbtw R x y z → Wbtw R x y z
invalid binder annotation, type is not a class instance
  OrderedRing R

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for Polynomial.degree_eq_bot : ∀ {R : Type u} [inst : Semiring R] {p : Polynomial R}, p.degree = ⊥ ↔ p = 0
Failed for Finset.sum_nonneg : ∀ {ι : Type u_1} {N : Type u_5} [inst : OrderedAddCommMonoid N] {f : ι → N} {s : Finset ι},
  (∀ i ∈ s, 0 ≤ f i) → 0 ≤ s.sum fun i => f i
invalid binder annotation, type is not a class instance
  OrderedAddCommMonoid N

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for CategoryTheory.Limits.Cofork.condition : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} {f g : X ⟶ Y} (t : CategoryTheory.Limits.Cofork f g),
  CategoryTheory.CategoryStruct.comp f t.π = CategoryTheory.CategoryStruct.comp g t.π
Succeeded for CategoryTheory.Limits.biproduct.hom_ext' : ∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category.{v, u} C]
  [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {f : J → C} [inst_2 : CategoryTheory.Limits.HasBiproduct f]
  {Z : C} (g h : ⨁ f ⟶ Z),
  (∀ (j : J),
      CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι f j) g =
        CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι f j) h) →
    g = h
Succeeded for AddEquiv.map_add : ∀ {M : Type u_6} {N : Type u_7} [inst : Add M] [inst_1 : Add N] (f : M ≃+ N) (x y : M), f (x + y) = f x + f y
Succeeded for neg_lt_neg_iff : ∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1]
  [inst_3 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, -a < -b ↔ b < a
Failed for Finset.mem_singleton_self : ∀ {α : Type u_1} (a : α), a ∈ {a}
typeclass instance problem is stuck, it is often due to metavariables
  Singleton α (?m.450 a)

----
Succeeded for Set.mem_setOf : ∀ {α : Type u} {a : α} {p : α → Prop}, a ∈ {x | p x} ↔ p a
Succeeded for MeasureTheory.MeasurePreserving.comp : ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β]
  [inst_2 : MeasurableSpace γ] {μa : MeasureTheory.Measure α} {μb : MeasureTheory.Measure β}
  {μc : MeasureTheory.Measure γ} {g : β → γ} {f : α → β},
  MeasureTheory.MeasurePreserving g μb μc →
    MeasureTheory.MeasurePreserving f μa μb → MeasureTheory.MeasurePreserving (g ∘ f) μa μc
Succeeded for zero_le_two : ∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : Preorder α] [inst_2 : ZeroLEOneClass α]
  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], 0 ≤ 2
Succeeded for inv_div : ∀ {α : Type u_1} [inst : DivisionMonoid α] (a b : α), (a / b)⁻¹ = b / a
Failed for CategoryTheory.MonoidalCategory.whiskerRight_id : ∀ {C : Type u} [𝒞 : CategoryTheory.Category.{v, u} C] [inst : CategoryTheory.MonoidalCategory C] {X Y : C} (f : X ⟶ Y),
  CategoryTheory.MonoidalCategory.whiskerRight f (𝟙_ C) =
    CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.rightUnitor X).hom
      (CategoryTheory.CategoryStruct.comp f (CategoryTheory.MonoidalCategory.rightUnitor Y).inv)
<input>:1:170: expected token
----
Succeeded for List.pairwise_cons : ∀ {α : Type u_1} {R : α → α → Prop} {a : α} {l : List α},
  List.Pairwise R (a :: l) ↔ (∀ a' ∈ l, R a a') ∧ List.Pairwise R l
Succeeded for Filter.principal_mono : ∀ {α : Type u} {s t : Set α}, Filter.principal s ≤ Filter.principal t ↔ s ⊆ t
Succeeded for le_himp_iff : ∀ {α : Type u_2} [inst : GeneralizedHeytingAlgebra α] {a b c : α}, a ≤ b ⇨ c ↔ a ⊓ b ≤ c
Succeeded for le_iSup_of_le : ∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {f : ι → α} {a : α} (i : ι), a ≤ f i → a ≤ iSup f
Succeeded for le_add_of_nonneg_left : ∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LE α]
  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, 0 ≤ b → a ≤ b + a
Succeeded for Cardinal.lift_id' : ∀ (a : Cardinal.{max u v}), Cardinal.lift.{u, max u v} a = a
Succeeded for Finset.mem_Icc : ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : LocallyFiniteOrder α] {a b x : α}, x ∈ Finset.Icc a b ↔ a ≤ x ∧ x ≤ b
Succeeded for sub_lt_iff_lt_add : ∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]
  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b c : α},
  a - c < b ↔ a < b + c
Succeeded for inf_idem : ∀ {α : Type u} [inst : SemilatticeInf α] (a : α), a ⊓ a = a
Succeeded for Finset.prod_const_one : ∀ {α : Type u_3} {β : Type u_4} {s : Finset α} [inst : CommMonoid β], (s.prod fun _x => 1) = 1
Succeeded for HasSum.map : ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : AddCommMonoid α] [inst_1 : TopologicalSpace α] {f : β → α}
  {a : α} [inst_2 : AddCommMonoid γ] [inst_3 : TopologicalSpace γ],
  HasSum f a →
    ∀ {G : Type u_5} [inst_4 : FunLike G α γ] [inst : AddMonoidHomClass G α γ] (g : G),
      Continuous ⇑g → HasSum (⇑g ∘ f) (g a)
Succeeded for sub_add_sub_cancel : ∀ {G : Type u_3} [inst : AddGroup G] (a b c : G), a - b + (b - c) = a - c
Failed for Tropical.untrop_injective : ∀ {R : Type u}, Function.Injective Tropical.untrop
don't know how to synthesize implicit argument 'β'
  @Function.Injective (Tropical ?m.14) ?m.14 Tropical.untrop
context:
R : Type u
⊢ Type ?u.9

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @Function.Injective (Tropical ?m.14) ?m.14 Tropical.untrop
context:
R : Type u
⊢ Type ?u.9

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'R'
  @Tropical.untrop ?m.14
context:
R : Type u
⊢ Type ?u.9

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for minpoly.aeval : ∀ (A : Type u_1) {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B),
  (Polynomial.aeval x) (minpoly A x) = 0
Succeeded for Nat.dvd_gcd : ∀ {k m n : ℕ}, k ∣ m → k ∣ n → k ∣ m.gcd n
Succeeded for Multiset.mem_cons_of_mem : ∀ {α : Type u_1} {a b : α} {s : Multiset α}, a ∈ s → a ∈ b ::ₘ s
Succeeded for LowerSet.ext : ∀ {α : Type u_1} [inst : LE α] {s t : LowerSet α}, ↑s = ↑t → s = t
Succeeded for smul_le_smul_of_nonneg_left : ∀ {α : Type u_1} {β : Type u_2} {a : α} {b₁ b₂ : β} [inst : SMul α β] [inst_1 : Preorder α] [inst_2 : Preorder β]
  [inst_3 : Zero α] [inst_4 : PosSMulMono α β], b₁ ≤ b₂ → 0 ≤ a → a • b₁ ≤ a • b₂
Failed for Inducing.continuous : ∀ {X : Type u_1} {Y : Type u_2} {f : X → Y} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y],
  Inducing f → Continuous f
Function expected at
  Inducing
but this term has type
  ?m.19

Note: Expected a function because this term is being applied to the argument
  f

----
Succeeded for codisjoint_iff : ∀ {α : Type u_1} [inst : SemilatticeSup α] [inst_1 : OrderTop α] {a b : α}, Codisjoint a b ↔ a ⊔ b = ⊤
Succeeded for continuous_def : ∀ {X : Type u_1} {Y : Type u_2} {x : TopologicalSpace X} {x_1 : TopologicalSpace Y} {f : X → Y},
  Continuous f ↔ ∀ (s : Set Y), IsOpen s → IsOpen (f ⁻¹' s)
Failed for continuous_id' : ∀ {X : Type u_1} [inst : TopologicalSpace X], Continuous fun x => x
typeclass instance problem is stuck, it is often due to metavariables
  TopologicalSpace ?m.1233

----
Succeeded for and_assoc : ∀ {a b c : Prop}, (a ∧ b) ∧ c ↔ a ∧ b ∧ c
Failed for Pi.single_eq_of_ne : ∀ {I : Type u} {f : I → Type v₁} [inst : DecidableEq I] [inst_1 : (i : I) → Zero (f i)] {i i' : I},
  i' ≠ i → ∀ (x : f i), Pi.single i x i' = 0
unknown universe level 'v₁'
invalid parametric local instance, parameter with type
  I
does not have forward dependencies, type class resolution cannot use this kind of local instance because it will not be able to infer a value for this parameter.

----
Failed for inner_conj_symm : ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : RCLike 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]
  (x y : E), (starRingEnd 𝕜) ⟪y, x⟫_𝕜 = ⟪x, y⟫_𝕜
<input>:1:149: expected token
----
Failed for IsCyclotomicExtension.zeta_spec : ∀ (n : ℕ+) (A : Type w) (B : Type z) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]
  [inst_3 : IsCyclotomicExtension {n} A B], IsPrimitiveRoot (IsCyclotomicExtension.zeta n A B) ↑n
overloaded, errors 
  failed to synthesize
    Singleton ℕ+ (Set ℕ)
  
  Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.
  
  invalid {...} notation, expected type is not of the form (C ...)
    Set ℕ
failed to synthesize
  IsCyclotomicExtension {↑n} A B

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Failed for Orientation.oangle_eq_angle_of_sign_eq_one : ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]
  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V},
  (o.oangle x y).sign = 1 → o.oangle x y = ↑(InnerProductGeometry.angle x y)
unknown constant 'FiniteDimensional.finrank'
failed to synthesize
  Fact (Module.finrank ℝ V = 2)

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.
failed to synthesize
  Fact (Module.finrank ℝ V = 2)

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Succeeded for Zsqrtd.ext : ∀ {d : ℤ} (x y : ℤ√d), x.re = y.re → x.im = y.im → x = y
Failed for CategoryTheory.Subobject.factorThru_arrow : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X Y : C} (P : CategoryTheory.Subobject Y) (f : X ⟶ Y)
  (h : P.Factors f), CategoryTheory.CategoryStruct.comp (P.factorThru f h) P.arrow = f
unknown universe level 'v₁'

----
Succeeded for ne_comm : ∀ {α : Sort u_1} {a b : α}, a ≠ b ↔ b ≠ a
Succeeded for lt_add_of_pos_right : ∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LT α]
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : α) {b : α}, 0 < b → a < a + b
Succeeded for MvPolynomial.eval₂_X : ∀ {R : Type u} {S₁ : Type v} {σ : Type u_1} [inst : CommSemiring R] [inst_1 : CommSemiring S₁] (f : R →+* S₁)
  (g : σ → S₁) (n : σ), MvPolynomial.eval₂ f g (MvPolynomial.X n) = g n
Failed for monotone_id : ∀ {α : Type u} [inst : Preorder α], Monotone id
typeclass instance problem is stuck, it is often due to metavariables
  Preorder ?m.507

----
Succeeded for ENNReal.ofReal_one : ENNReal.ofReal 1 = 1
Succeeded for Nat.le_antisymm : ∀ {n m : ℕ}, n ≤ m → m ≤ n → n = m
Succeeded for Substring.Valid.validFor : ∀ {s : Substring}, s.Valid → ∃ l m r, Substring.ValidFor l m r s
Succeeded for CategoryTheory.Limits.biprod.hom_ext' : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X Y Z : C}
  [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct X Y] (f g : X ⊞ Y ⟶ Z),
  CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl f =
      CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl g →
    CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr f =
        CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr g →
      f = g
Succeeded for Int.mul_zero : ∀ (a : ℤ), a * 0 = 0
Succeeded for Set.eq_empty_iff_forall_not_mem : ∀ {α : Type u} {s : Set α}, s = ∅ ↔ ∀ (x : α), x ∉ s
Succeeded for AEMeasurable.prod_mk : ∀ {α : Type u_2} {β : Type u_3} {γ : Type u_4} {m0 : MeasurableSpace α} [inst : MeasurableSpace β]
  [inst_1 : MeasurableSpace γ] {μ : MeasureTheory.Measure α} {f : α → β} {g : α → γ},
  AEMeasurable f μ → AEMeasurable g μ → AEMeasurable (fun x => (f x, g x)) μ
Failed for Nat.exists_eq_succ_of_ne_zero : ∀ {n : ℕ}, n ≠ 0 → ∃ k, n = k.succ
Invalid field notation: Type of
  k
is not known; cannot resolve field `succ`

----
Succeeded for mul_right_cancel : ∀ {G : Type u_1} [inst : Mul G] [inst_1 : IsRightCancelMul G] {a b c : G}, a * b = c * b → a = c
Succeeded for Set.inter_eq_self_of_subset_left : ∀ {α : Type u} {s t : Set α}, s ⊆ t → s ∩ t = s
Failed for Sum.inr.injEq : ∀ {α : Type u} {β : Type v} (val val_1 : β), (Sum.inr val = Sum.inr val_1) = (val = val_1)
don't know how to synthesize implicit argument 'α'
  @Eq (?m.59 val val_1 ⊕ β) (Sum.inr val) (Sum.inr val_1)
context:
α : Type u
β : Type v
val val_1 : β
⊢ Type (max v ?u.14)

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @Sum.inr (?m.59 val val_1) β val_1
context:
α : Type u
β : Type v
val val_1 : β
⊢ Type ?u.14

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @Sum.inr (?m.59 val val_1) β val
context:
α : Type u
β : Type v
val val_1 : β
⊢ Type ?u.14

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for asymm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsAsymm α r] {a b : α}, r a b → ¬r b a
Succeeded for Polynomial.mem_support_iff : ∀ {R : Type u} {n : ℕ} [inst : Semiring R] {p : Polynomial R}, n ∈ p.support ↔ p.coeff n ≠ 0
Succeeded for Finset.mem_union : ∀ {α : Type u_1} [inst : DecidableEq α] {s t : Finset α} {a : α}, a ∈ s ∪ t ↔ a ∈ s ∨ a ∈ t
Succeeded for Polynomial.coeff_eq_zero_of_natDegree_lt : ∀ {R : Type u} [inst : Semiring R] {p : Polynomial R} {n : ℕ}, p.natDegree < n → p.coeff n = 0
Succeeded for Mathlib.Data.Set.Finite._auxLemma.3 : ∀ {α : Type u} {s : Set α} {a : α} (hs : s.Finite), (a ∈ hs.toFinset) = (a ∈ s)
Succeeded for AddSubmonoid.LocalizationMap.map_addUnits : ∀ {M : Type u_1} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [inst_1 : AddCommMonoid N]
  (f : S.LocalizationMap N) (y : ↥S), IsAddUnit (f.toMap ↑y)
Succeeded for continuousOn_iff_continuous_restrict : ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β} {s : Set α},
  ContinuousOn f s ↔ Continuous (s.restrict f)
Succeeded for ENNReal.ofReal_zero : ENNReal.ofReal 0 = 0
Succeeded for Real.log_one : Real.log 1 = 0
Succeeded for Filter.Germ.inductionOn : ∀ {α : Type u_1} {β : Type u_2} {l : Filter α} (f : l.Germ β) {p : l.Germ β → Prop}, (∀ (f : α → β), p ↑f) → p f
Succeeded for Metric.nhds_basis_ball : ∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, (nhds x).HasBasis (fun x => 0 < x) (Metric.ball x)
Succeeded for Finset.card_pos : ∀ {α : Type u_1} {s : Finset α}, 0 < s.card ↔ s.Nonempty
Failed for MeasureTheory.OuterMeasure.ext : ∀ {α : Type u_1} {μ₁ μ₂ : MeasureTheory.OuterMeasure α}, (∀ (s : Set α), ↑μ₁ s = ↑μ₂ s) → μ₁ = μ₂
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known

----
Succeeded for Function.Injective.mem_set_image : ∀ {α : Type u_1} {β : Type u_2} {f : α → β}, Function.Injective f → ∀ {s : Set α} {a : α}, f a ∈ f '' s ↔ a ∈ s
Failed for CategoryTheory.id_apply : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.ConcreteCategory C] {X : C}
  (x : (CategoryTheory.forget C).obj X), (CategoryTheory.CategoryStruct.id X) x = x
type expected, got
  (CategoryTheory.ConcreteCategory
  C : (FC : outParam (C → C → Type ?u.7)) →
  {CC : outParam (C → Type ?u.10)} →
    [outParam ((X Y : C) → FunLike (FC X Y) (CC X) (CC Y))] → Type (max (max u ?u.7) v))

----
Failed for continuous_norm : ∀ {E : Type u_6} [inst : SeminormedAddGroup E], Continuous fun a => ‖a‖
typeclass instance problem is stuck, it is often due to metavariables
  TopologicalSpace ?m.1118

----
Succeeded for forall₂_swap : ∀ {ι₁ : Sort u_3} {ι₂ : Sort u_4} {κ₁ : ι₁ → Sort u_5} {κ₂ : ι₂ → Sort u_6}
  {p : (i₁ : ι₁) → κ₁ i₁ → (i₂ : ι₂) → κ₂ i₂ → Prop},
  (∀ (i₁ : ι₁) (j₁ : κ₁ i₁) (i₂ : ι₂) (j₂ : κ₂ i₂), p i₁ j₁ i₂ j₂) ↔
    ∀ (i₂ : ι₂) (j₂ : κ₂ i₂) (i₁ : ι₁) (j₁ : κ₁ i₁), p i₁ j₁ i₂ j₂
Failed for Set.countable_range : ∀ {β : Type v} {ι : Sort x} [inst : Countable ι] (f : ι → β), (Set.range f).Countable
unknown universe level 'x'

----
Succeeded for mul_right_inj' : ∀ {M₀ : Type u_1} [inst : CancelMonoidWithZero M₀] {a b c : M₀}, a ≠ 0 → (a * b = a * c ↔ b = c)
Succeeded for AddSubgroup.neg_mem : ∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G) {x : G}, x ∈ H → -x ∈ H
Succeeded for Polynomial.eval_map : ∀ {R : Type u} {S : Type v} [inst : Semiring R] {p : Polynomial R} [inst_1 : Semiring S] (f : R →+* S) (x : S),
  Polynomial.eval x (Polynomial.map f p) = Polynomial.eval₂ f x p
Succeeded for Finset.map_map : ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α ↪ β) (g : β ↪ γ) (s : Finset α),
  Finset.map g (Finset.map f s) = Finset.map (f.trans g) s
Succeeded for mem_nhdsWithin_of_mem_nhds : ∀ {α : Type u_1} [inst : TopologicalSpace α] {s t : Set α} {a : α}, s ∈ nhds a → s ∈ nhdsWithin a t
Failed for CategoryTheory.Functor.mono_of_mono_map : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  (F : CategoryTheory.Functor C D) [inst_2 : F.ReflectsMonomorphisms] {X Y : C} {f : X ⟶ Y},
  CategoryTheory.Mono (F.map f) → CategoryTheory.Mono f
unknown universe level 'v₁'

----
Failed for Set.compl_univ : ∀ {α : Type u}, Set.univᶜ = ∅
don't know how to synthesize implicit argument 'α'
  @Eq (Set ?m.191) Set.univᶜ ∅
context:
α : Type u
⊢ Type ?u.9

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'self'
  @EmptyCollection.emptyCollection (Set ?m.191) Set.instEmptyCollection
context:
α : Type u
⊢ EmptyCollection (Set ?m.191)

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @EmptyCollection.emptyCollection (Set ?m.191) Set.instEmptyCollection
context:
α : Type u
⊢ Type ?u.9

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @compl (Set ?m.191) Set.instHasCompl Set.univ
context:
α : Type u
⊢ Type ?u.9

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @Set.univ ?m.191
context:
α : Type u
⊢ Type ?u.9

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for sdiff_le_iff : ∀ {α : Type u_2} [inst : GeneralizedCoheytingAlgebra α] {a b c : α}, a \ b ≤ c ↔ a ≤ b ⊔ c
Succeeded for MeasureTheory.Integrable.neg : ∀ {α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} [inst : NormedAddCommGroup β]
  {f : α → β}, MeasureTheory.Integrable f μ → MeasureTheory.Integrable (-f) μ
Succeeded for IsUnit.map : ∀ {F : Type u_1} {M : Type u_4} {N : Type u_5} [inst : FunLike F M N] [inst_1 : Monoid M] [inst_2 : Monoid N]
  [inst_3 : MonoidHomClass F M N] (f : F) {x : M}, IsUnit x → IsUnit (f x)
Succeeded for CategoryTheory.Limits.biproduct.hom_ext : ∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category.{v, u} C]
  [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {f : J → C} [inst_2 : CategoryTheory.Limits.HasBiproduct f]
  {Z : C} (g h : Z ⟶ ⨁ f),
  (∀ (j : J),
      CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.biproduct.π f j) =
        CategoryTheory.CategoryStruct.comp h (CategoryTheory.Limits.biproduct.π f j)) →
    g = h
Succeeded for tendsto_pi_nhds : ∀ {Y : Type v} {ι : Type u_5} {π : ι → Type u_6} [T : (i : ι) → TopologicalSpace (π i)] {f : Y → (i : ι) → π i}
  {g : (i : ι) → π i} {u : Filter Y},
  Filter.Tendsto f u (nhds g) ↔ ∀ (x : ι), Filter.Tendsto (fun i => f i x) u (nhds (g x))
Succeeded for Primrec.to₂ : ∀ {α : Type u_1} {β : Type u_2} {σ : Type u_5} [inst : Primcodable α] [inst_1 : Primcodable β] [inst_2 : Primcodable σ]
  {f : α × β → σ}, Primrec f → Primrec₂ fun a b => f (a, b)
Succeeded for NoZeroSMulDivisors.algebraMap_injective : ∀ (R : Type u_1) (A : Type u_2) [inst : CommRing R] [inst_1 : Ring A] [inst_2 : Nontrivial A] [inst_3 : Algebra R A]
  [inst_4 : NoZeroSMulDivisors R A], Function.Injective ⇑(algebraMap R A)
Succeeded for Mathlib.Algebra.Order.Monoid.Lemmas._auxLemma.23 : ∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LT α]
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1]
  [inst_3 : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : α) {b : α}, (a < a + b) = (0 < b)
Succeeded for CategoryTheory.IsIso.hom_inv_id_assoc : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} (f : X ⟶ Y) [I : CategoryTheory.IsIso f] {Z : C}
  (g : X ⟶ Z), CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv f) g) = g
Failed for inner_neg_right : ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : RCLike 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]
  (x y : E), ⟪x, -y⟫_𝕜 = -⟪x, y⟫_𝕜
<input>:1:134: expected token
----
Failed for CategoryTheory.MonoidalCategory.id_whiskerLeft : ∀ {C : Type u} [𝒞 : CategoryTheory.Category.{v, u} C] [inst : CategoryTheory.MonoidalCategory C] {X Y : C} (f : X ⟶ Y),
  CategoryTheory.MonoidalCategory.whiskerLeft (𝟙_ C) f =
    CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.leftUnitor X).hom
      (CategoryTheory.CategoryStruct.comp f (CategoryTheory.MonoidalCategory.leftUnitor Y).inv)
<input>:1:167: expected token
----
Succeeded for IsConnected.isPreconnected : ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsConnected s → IsPreconnected s
Succeeded for Set.setOf_forall : ∀ {β : Type u_2} {ι : Sort u_4} (p : ι → β → Prop), {x | ∀ (i : ι), p i x} = ⋂ i, {x | p i x}
Succeeded for Nat.factorial_pos : ∀ (n : ℕ), 0 < n.factorial
Succeeded for le_sub_iff_add_le : ∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]
  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b c : α},
  a ≤ c - b ↔ a + b ≤ c
Succeeded for Unitization.ext : ∀ {R : Type u_1} {A : Type u_2} {x y : Unitization R A}, x.fst = y.fst → x.snd = y.snd → x = y
Succeeded for add_pos : ∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b : α}, 0 < a → 0 < b → 0 < a + b
Failed for div_le_div_of_le : ∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a b c : α}, 0 ≤ c → a ≤ b → a / c ≤ b / c
invalid binder annotation, type is not a class instance
  LinearOrderedSemifield α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for Complex.abs_ofReal : ∀ (r : ℝ), Complex.abs ↑r = |r|
Succeeded for Nat.mul_one : ∀ (n : ℕ), n * 1 = n
Succeeded for AddUnits.add_neg : ∀ {α : Type u} [inst : AddMonoid α] (a : AddUnits α), ↑a + ↑(-a) = 0
Succeeded for AddEquiv.symm_apply_apply : ∀ {M : Type u_6} {N : Type u_7} [inst : Add M] [inst_1 : Add N] (e : M ≃+ N) (x : M), e.symm (e x) = x
Succeeded for neg_eq_iff_eq_neg : ∀ {G : Type u_3} [inst : InvolutiveNeg G] {a b : G}, -a = b ↔ a = -b
Succeeded for Infinite.of_injective : ∀ {α : Sort u_4} {β : Sort u_5} [inst : Infinite β] (f : β → α), Function.Injective f → Infinite α
Succeeded for Unique.eq_default : ∀ {α : Sort u_1} [inst : Unique α] (a : α), a = default
Succeeded for mul_mul_mul_comm : ∀ {G : Type u_3} [inst : CommSemigroup G] (a b c d : G), a * b * (c * d) = a * c * (b * d)
Succeeded for le_of_not_le : ∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a ≤ b → b ≤ a
Succeeded for Isometry.of_dist_eq : ∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},
  (∀ (x y : α), dist (f x) (f y) = dist x y) → Isometry f
Succeeded for IsClosed.closure_subset_iff : ∀ {X : Type u} {s t : Set X} [inst : TopologicalSpace X], IsClosed t → (closure s ⊆ t ↔ s ⊆ t)
Succeeded for Complex.exp_zero : Complex.exp 0 = 1
Succeeded for Nat.ModEq.symm : ∀ {n a b : ℕ}, n.ModEq a b → n.ModEq b a
Failed for Asymptotics.IsBigO_def : ∀ {α : Type u_17} {E : Type u_18} {F : Type u_19} [inst : Norm E] [inst_1 : Norm F] (l : Filter α) (f : α → E)
  (g : α → F), f =O[l] g = ∃ c, Asymptotics.IsBigOWith c l f g
unknown universe level 'u_17'
unknown universe level 'u_18'
unknown universe level 'u_19'

----
Succeeded for norm_ne_zero_iff : ∀ {E : Type u_6} [inst : NormedAddGroup E] {a : E}, ‖a‖ ≠ 0 ↔ a ≠ 0
Succeeded for sub_le_iff_le_add' : ∀ {α : Type u} [inst : AddCommGroup α] [inst_1 : LE α]
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b c : α}, a - b ≤ c ↔ a ≤ b + c
Failed for Nat.prime_of_mem_factors : ∀ {n p : ℕ}, p ∈ n.factors → p.Prime
Invalid field `factors`: The environment does not contain `Nat.factors`
  n
has type
  ℕ

----
Failed for ENNReal.one_ne_top : 1 ≠ ⊤
failed to synthesize
  Top ℕ

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Failed for MeasureTheory.Filtration.mono : ∀ {Ω : Type u_1} {ι : Type u_3} {m : MeasurableSpace Ω} [inst : Preorder ι] {i j : ι}
  (f : MeasureTheory.Filtration ι m), i ≤ j → ↑f i ≤ ↑f j
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known

----
Succeeded for MeasureTheory.AEEqFun.aestronglyMeasurable : ∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} [inst_1 : TopologicalSpace β]
  (f : α →ₘ[μ] β), MeasureTheory.AEStronglyMeasurable (↑f) μ
Succeeded for Nat.minFac_prime : ∀ {n : ℕ}, n ≠ 1 → n.minFac.Prime
Succeeded for Ordinal.pos_iff_ne_zero : ∀ {o : Ordinal.{u_3}}, 0 < o ↔ o ≠ 0
Failed for Exists.snd : ∀ {b : Prop} {p : b → Prop} (h : Exists p), p ⋯
don't know how to synthesize placeholder
context:
b : Prop
p : b → Prop
h : Exists p
⊢ b

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Failed for isClosed_univ : ∀ {X : Type u} [inst : TopologicalSpace X], IsClosed Set.univ
typeclass instance problem is stuck, it is often due to metavariables
  TopologicalSpace ?m.624

----
Failed for Orientation.oangle_neg_orientation_eq_neg : ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]
  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V),
  (-o).oangle x y = -o.oangle x y
unknown constant 'FiniteDimensional.finrank'
failed to synthesize
  Fact (Module.finrank ℝ V = 2)

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.
failed to synthesize
  Fact (Module.finrank ℝ V = 2)

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Succeeded for interior_maximal : ∀ {X : Type u} {s t : Set X} [inst : TopologicalSpace X], t ⊆ s → IsOpen t → t ⊆ interior s
Succeeded for Finset.coe_Ioo : ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : LocallyFiniteOrder α] (a b : α), ↑(Finset.Ioo a b) = Set.Ioo a b
Succeeded for Nat.lt_of_succ_lt_succ : ∀ {n m : ℕ}, n.succ < m.succ → n < m
Succeeded for Set.biUnion_of_singleton : ∀ {α : Type u_1} (s : Set α), ⋃ x ∈ s, {x} = s
Succeeded for Nat.prime_two : Nat.Prime 2
Succeeded for Polynomial.monic_X_sub_C : ∀ {R : Type u} [inst : Ring R] (x : R), (Polynomial.X - Polynomial.C x).Monic
Failed for Finset.univ_unique : ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Unique α], Finset.univ = {default}
typeclass instance problem is stuck, it is often due to metavariables
  Inhabited ?m.12668

----
Succeeded for Computable.comp : ∀ {α : Type u_1} {β : Type u_2} {σ : Type u_4} [inst : Primcodable α] [inst_1 : Primcodable β] [inst_2 : Primcodable σ]
  {f : β → σ} {g : α → β}, Computable f → Computable g → Computable fun a => f (g a)
Failed for Matrix.mul_one : ∀ {m : Type u_2} {n : Type u_3} {α : Type v} [inst : NonAssocSemiring α] [inst_1 : Fintype n] [inst_2 : DecidableEq n]
  (M : Matrix m n α), M * 1 = M
failed to synthesize
  HMul (Matrix m n α) ℕ (Matrix m n α)

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Failed for exists_rat_btwn : ∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α] {x y : α}, x < y → ∃ q, x < ↑q ∧ ↑q < y
invalid binder annotation, type is not a class instance
  LinearOrderedField α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for Disjoint.eq_bot : ∀ {α : Type u_1} [inst : SemilatticeInf α] [inst_1 : OrderBot α] {a b : α}, Disjoint a b → a ⊓ b = ⊥
Succeeded for sInf_image : ∀ {α : Type u_1} {β : Type u_2} [inst : CompleteLattice α] {s : Set β} {f : β → α}, sInf (f '' s) = ⨅ a ∈ s, f a
Succeeded for Mathlib.Data.Finset.Basic._auxLemma.118 : ∀ {a b c : Prop}, (a ∧ b ∨ a ∧ c) = (a ∧ (b ∨ c))
Failed for Finset.coe_mul : ∀ {α : Type u_2} [inst : DecidableEq α] [inst_1 : Mul α] (s t : Finset α), ↑(s * t) = ↑s * ↑t
failed to synthesize
  HMul (Finset α) (Finset α) (?m.74 s t)

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.
failed to synthesize
  HMul (Finset α) (Finset α) ?m.4756

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Succeeded for Real.rpow_def_of_pos : ∀ {x : ℝ}, 0 < x → ∀ (y : ℝ), x ^ y = (x.log * y).exp
Succeeded for PowerSeries.coeff_mk : ∀ {R : Type u_1} [inst : Semiring R] (n : ℕ) (f : ℕ → R), (PowerSeries.coeff R n) (PowerSeries.mk f) = f n
Succeeded for sup_bot_eq : ∀ {α : Type u} [inst : SemilatticeSup α] [inst_1 : OrderBot α] (a : α), a ⊔ ⊥ = a
Succeeded for Finset.filter_subset : ∀ {α : Type u_1} (p : α → Prop) [inst : DecidablePred p] (s : Finset α), Finset.filter p s ⊆ s
Succeeded for Filter.Tendsto.mul : ∀ {α : Type u_2} {M : Type u_3} [inst : TopologicalSpace M] [inst_1 : Mul M] [inst_2 : ContinuousMul M] {f g : α → M}
  {x : Filter α} {a b : M},
  Filter.Tendsto f x (nhds a) → Filter.Tendsto g x (nhds b) → Filter.Tendsto (fun x => f x * g x) x (nhds (a * b))
Succeeded for HomologicalComplex.dTo_comp_dFrom : ∀ {ι : Type u_1} {V : Type u} [inst : CategoryTheory.Category.{v, u} V]
  [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] {c : ComplexShape ι} (C : HomologicalComplex V c) (j : ι),
  CategoryTheory.CategoryStruct.comp (C.dTo j) (C.dFrom j) = 0
Succeeded for Set.iUnion_eq_univ_iff : ∀ {α : Type u_1} {ι : Sort u_4} {f : ι → Set α}, ⋃ i, f i = Set.univ ↔ ∀ (x : α), ∃ i, x ∈ f i
Succeeded for iff_true_intro : ∀ {a : Prop}, a → (a ↔ True)
Failed for Polynomial.aeval_X : ∀ {R : Type u} {A : Type z} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (x : A),
  (Polynomial.aeval x) Polynomial.X = x
typeclass instance problem is stuck, it is often due to metavariables
  Semiring (?m.2384 x)

----
Succeeded for Int.ofNat_le : ∀ {m n : ℕ}, ↑m ≤ ↑n ↔ m ≤ n
Succeeded for sub_ne_zero : ∀ {G : Type u_3} [inst : AddGroup G] {a b : G}, a - b ≠ 0 ↔ a ≠ b
Succeeded for Set.image_eq_range : ∀ {α : Type u_1} {β : Type u_2} (f : α → β) (s : Set α), f '' s = Set.range fun x => f ↑x
Succeeded for List.length_reverse : ∀ {α : Type u} (as : List α), as.reverse.length = as.length
Succeeded for MeasureTheory.lintegral_mono : ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} ⦃f g : α → ENNReal⦄,
  f ≤ g → ∫⁻ (a : α), f a ∂μ ≤ ∫⁻ (a : α), g a ∂μ
Succeeded for MeasureTheory.Measure.map_map : ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {m0 : MeasurableSpace α} [inst : MeasurableSpace β]
  [inst_1 : MeasurableSpace γ] {μ : MeasureTheory.Measure α} {g : β → γ} {f : α → β},
  Measurable g →
    Measurable f → MeasureTheory.Measure.map g (MeasureTheory.Measure.map f μ) = MeasureTheory.Measure.map (g ∘ f) μ
Succeeded for Nat.lt_or_gt_of_ne : ∀ {a b : ℕ}, a ≠ b → a < b ∨ a > b
Failed for contDiff_const : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {n : ℕ∞} {c : F},
  ContDiff 𝕜 n fun x => c
typeclass instance problem is stuck, it is often due to metavariables
  NormedSpace 𝕜 ?m.783

----
Succeeded for abs_of_nonpos : ∀ {α : Type u_1} [inst : Lattice α] [inst_1 : AddGroup α] {a : α}
  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1], a ≤ 0 → |a| = -a
Succeeded for neg_injective : ∀ {G : Type u_3} [inst : InvolutiveNeg G], Function.Injective Neg.neg
Succeeded for Set.insert_subset_iff : ∀ {α : Type u} {a : α} {s t : Set α}, insert a s ⊆ t ↔ a ∈ t ∧ s ⊆ t
Succeeded for measurableSet_Ioc : ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : OpensMeasurableSpace α]
  [inst_3 : LinearOrder α] [inst : OrderClosedTopology α] {a b : α}, MeasurableSet (Set.Ioc a b)
Failed for neg_nonpos_of_nonneg : ∀ {α : Type u} [inst : OrderedAddCommGroup α] {a : α}, 0 ≤ a → -a ≤ 0
invalid binder annotation, type is not a class instance
  OrderedAddCommGroup α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for isClosed_iInter : ∀ {X : Type u} {ι : Sort w} [inst : TopologicalSpace X] {f : ι → Set X},
  (∀ (i : ι), IsClosed (f i)) → IsClosed (⋂ i, f i)
Succeeded for ContinuousMap.coe_mul : ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : Mul β]
  [inst_3 : ContinuousMul β] (f g : C(α, β)), ⇑(f * g) = ⇑f * ⇑g
Succeeded for Set.finite_range : ∀ {α : Type u} {ι : Sort w} (f : ι → α) [inst : Finite ι], (Set.range f).Finite
Succeeded for Set.iUnion₂_subset : ∀ {α : Type u_1} {ι : Sort u_4} {κ : ι → Sort u_7} {s : (i : ι) → κ i → Set α} {t : Set α},
  (∀ (i : ι) (j : κ i), s i j ⊆ t) → ⋃ i, ⋃ j, s i j ⊆ t
Succeeded for Polynomial.eval₂_eq_sum : ∀ {R : Type u} {S : Type v} [inst : Semiring R] {p : Polynomial R} [inst_1 : Semiring S] {f : R →+* S} {x : S},
  Polynomial.eval₂ f x p = p.sum fun e a => f a * x ^ e
Succeeded for Nat.find_min' : ∀ {p : ℕ → Prop} [inst : DecidablePred p] (H : ∃ n, p n) {m : ℕ}, p m → Nat.find H ≤ m
Failed for MeasureTheory.measure_lt_top : ∀ {α : Type u_1} {m0 : MeasurableSpace α} (μ : MeasureTheory.Measure α) [inst : MeasureTheory.IsFiniteMeasure μ]
  (s : Set α), ↑↑μ s < ⊤
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known

----
Failed for MeasureTheory.Measure.map_apply_of_aemeasurable : ∀ {α : Type u_1} {β : Type u_2} {m0 : MeasurableSpace α} [inst : MeasurableSpace β] {μ : MeasureTheory.Measure α}
  {f : α → β}, AEMeasurable f μ → ∀ {s : Set β}, MeasurableSet s → ↑↑(MeasureTheory.Measure.map f μ) s = ↑↑μ (f ⁻¹' s)
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known

----
Failed for Finset.prod_singleton : ∀ {α : Type u_3} {β : Type u_4} [inst : CommMonoid β] (f : α → β) (a : α), ({a}.prod fun x => f x) = f a
overloaded, errors 
  Invalid field notation: Type of
    {a}
  is not known; cannot resolve field `prod`
  
  invalid {...} notation, expected type is not known

----
Failed for EuclideanGeometry.oangle_eq_angle_of_sign_eq_one : ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]
  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]
  {p₁ p₂ p₃ : P},
  (EuclideanGeometry.oangle p₁ p₂ p₃).sign = 1 → EuclideanGeometry.oangle p₁ p₂ p₃ = ↑(EuclideanGeometry.angle p₁ p₂ p₃)
unknown constant 'FiniteDimensional.finrank'
failed to synthesize
  Fact (Module.finrank ℝ V = 2)

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.
failed to synthesize
  Fact (Module.finrank ℝ V = 2)

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Succeeded for Mathlib.Data.Multiset.Basic._auxLemma.6 : ∀ {α : Type u_1} {a b : α} {s : Multiset α}, (a ∈ b ::ₘ s) = (a = b ∨ a ∈ s)
Succeeded for Mathlib.Data.Multiset.Basic._auxLemma.55 : ∀ {α : Type u_1} {β : Type v} {f : α → β} {b : β} {s : Multiset α}, (b ∈ Multiset.map f s) = ∃ a ∈ s, f a = b
Succeeded for Int.emod_nonneg : ∀ (a : ℤ) {b : ℤ}, b ≠ 0 → 0 ≤ a % b
Succeeded for GaloisConnection.dual : ∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {l : α → β} {u : β → α},
  GaloisConnection l u →
    GaloisConnection (⇑OrderDual.toDual ∘ u ∘ ⇑OrderDual.ofDual) (⇑OrderDual.toDual ∘ l ∘ ⇑OrderDual.ofDual)
Succeeded for sdiff_self : ∀ {α : Type u_2} [inst : GeneralizedCoheytingAlgebra α] {a : α}, a \ a = ⊥
Succeeded for Nat.unpair_pair : ∀ (a b : ℕ), (a.pair b).unpair = (a, b)
Succeeded for Set.Ioo_subset_Ioc_self : ∀ {α : Type u_1} [inst : Preorder α] {a b : α}, Set.Ioo a b ⊆ Set.Ioc a b
Succeeded for star_one : ∀ (R : Type u) [inst : MulOneClass R] [inst_1 : StarMul R], star 1 = 1
Succeeded for Complex.continuous_re : Continuous Complex.re
Succeeded for Real.log_zero : Real.log 0 = 0
Succeeded for Eq.trans_lt : ∀ {α : Type u} {a b c : α} [inst : LT α], a = b → b < c → a < c
Failed for EuclideanGeometry.oangle_rotate_sign : ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]
  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]
  (p₁ p₂ p₃ : P), (EuclideanGeometry.oangle p₂ p₃ p₁).sign = (EuclideanGeometry.oangle p₁ p₂ p₃).sign
unknown constant 'FiniteDimensional.finrank'
failed to synthesize
  Fact (Module.finrank ℝ V = 2)

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.
failed to synthesize
  Fact (Module.finrank ℝ V = 2)

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Succeeded for List.tfae_of_cycle : ∀ {a b : Prop} {l : List Prop}, List.Chain (fun x x_1 => x → x_1) a (b :: l) → (l.getLastD b → a) → (a :: b :: l).TFAE
Failed for CategoryTheory.Limits.limit.w : ∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] {C : Type u} [inst_1 : CategoryTheory.Category.{v, u} C]
  (F : CategoryTheory.Functor J C) [inst_2 : CategoryTheory.Limits.HasLimit F] {j j' : J} (f : j ⟶ j'),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F j) (F.map f) = CategoryTheory.Limits.limit.π F j'
unknown universe level 'v₁'

----
Succeeded for isOpen_discrete : ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : DiscreteTopology α] (s : Set α), IsOpen s
Succeeded for ENNReal.ofReal_toReal : ∀ {a : ENNReal}, a ≠ ⊤ → ENNReal.ofReal a.toReal = a
Succeeded for Continuous.comp_continuousOn : ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]
  [inst_2 : TopologicalSpace γ] {g : β → γ} {f : α → β} {s : Set α},
  Continuous g → ContinuousOn f s → ContinuousOn (g ∘ f) s
Succeeded for AddSubmonoid.zero_mem : ∀ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M), 0 ∈ S
Succeeded for List.forall_mem_cons : ∀ {α : Type u_1} {p : α → Prop} {a : α} {l : List α}, (∀ x ∈ a :: l, p x) ↔ p a ∧ ∀ x ∈ l, p x
Succeeded for Matrix.diagonal_apply_ne : ∀ {n : Type u_3} {α : Type v} [inst : DecidableEq n] [inst_1 : Zero α] (d : n → α) {i j : n},
  i ≠ j → Matrix.diagonal d i j = 0
Succeeded for Option.some_ne_none : ∀ {α : Type u_1} (x : α), some x ≠ none
Succeeded for tsum_eq_zero_of_not_summable : ∀ {α : Type u_1} {β : Type u_2} [inst : AddCommMonoid α] [inst_1 : TopologicalSpace α] {f : β → α},
  ¬Summable f → ∑' (b : β), f b = 0
Succeeded for sup_le_iff : ∀ {α : Type u} [inst : SemilatticeSup α] {a b c : α}, a ⊔ b ≤ c ↔ a ≤ c ∧ b ≤ c
Failed for Set.not_mem_empty : ∀ {α : Type u} (x : α), x ∉ ∅
typeclass instance problem is stuck, it is often due to metavariables
  Membership α (?m.370 x)

----
Succeeded for Measurable.mul : ∀ {M : Type u_2} {α : Type u_3} [inst : MeasurableSpace M] [inst_1 : Mul M] {m : MeasurableSpace α} {f g : α → M}
  [inst_2 : MeasurableMul₂ M], Measurable f → Measurable g → Measurable fun a => f a * g a
Succeeded for Int.le_of_lt : ∀ {a b : ℤ}, a < b → a ≤ b
Succeeded for Equiv.cardinal_eq : ∀ {α β : Type u}, α ≃ β → Cardinal.mk α = Cardinal.mk β
Succeeded for Submonoid.subset_closure : ∀ {M : Type u_1} [inst : MulOneClass M] {s : Set M}, s ⊆ ↑(Submonoid.closure s)
Succeeded for HasDerivAt.comp : ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] (x : 𝕜) {𝕜' : Type u_1} [inst_1 : NontriviallyNormedField 𝕜']
  [inst_2 : NormedAlgebra 𝕜 𝕜'] {h : 𝕜 → 𝕜'} {h₂ : 𝕜' → 𝕜'} {h' h₂' : 𝕜'},
  HasDerivAt h₂ h₂' (h x) → HasDerivAt h h' x → HasDerivAt (h₂ ∘ h) (h₂' * h') x
Succeeded for LE.le.antisymm' : ∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≤ a → b = a
Succeeded for pow_orderOf_eq_one : ∀ {G : Type u_1} [inst : Monoid G] (x : G), x ^ orderOf x = 1
Failed for WithBot.bot_lt_coe : ∀ {α : Type u_1} [inst : LT α] (a : α), ⊥ < ↑a
failed to synthesize
  Bot α

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Succeeded for Set.mem_insert_of_mem : ∀ {α : Type u} {x : α} {s : Set α} (y : α), x ∈ s → x ∈ insert y s
Succeeded for RingHom.comp_apply : ∀ {α : Type u_2} {β : Type u_3} {γ : Type u_4} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β}
  {x_2 : NonAssocSemiring γ} (hnp : β →+* γ) (hmn : α →+* β) (x_3 : α), (hnp.comp hmn) x_3 = hnp (hmn x_3)
Failed for Set.singleton_nonempty : ∀ {α : Type u} (a : α), {a}.Nonempty
overloaded, errors 
  Invalid field notation: Type of
    {a}
  is not known; cannot resolve field `Nonempty`
  
  invalid {...} notation, expected type is not known

----
Succeeded for Subtype.mem : ∀ {α : Type u_1} {s : Set α} (p : ↑s), ↑p ∈ s
Failed for abs_sub_le_iff : ∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] {a b c : α}, |a - b| ≤ c ↔ a - b ≤ c ∧ b - a ≤ c
invalid binder annotation, type is not a class instance
  LinearOrderedAddCommGroup α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for Part.map_some : ∀ {α : Type u_1} {β : Type u_2} (f : α → β) (a : α), Part.map f (Part.some a) = Part.some (f a)
Failed for Linarith.lt_of_lt_of_eq : ∀ {α : Type u_1} [inst : OrderedSemiring α] {a b : α}, a < 0 → b = 0 → a + b < 0
invalid binder annotation, type is not a class instance
  OrderedSemiring α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for Finset.coe_Ioc : ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : LocallyFiniteOrder α] (a b : α), ↑(Finset.Ioc a b) = Set.Ioc a b
Failed for contDiff_iff_contDiffAt : ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}
  {n : ℕ∞}, ContDiff 𝕜 n f ↔ ∀ (x : E), ContDiffAt 𝕜 n f x
unknown universe level 'uE'
unknown universe level 'uF'

----
Succeeded for AddMonoidHom.map_nsmul : ∀ {M : Type u_4} {N : Type u_5} [inst : AddMonoid M] [inst_1 : AddMonoid N] (f : M →+ N) (a : M) (n : ℕ),
  f (n • a) = n • f a
Failed for IsCompact.measure_lt_top : ∀ {α : Type u_1} {m0 : MeasurableSpace α} [inst : TopologicalSpace α] {μ : MeasureTheory.Measure α}
  [inst_1 : MeasureTheory.IsFiniteMeasureOnCompacts μ] ⦃K : Set α⦄, IsCompact K → ↑↑μ K < ⊤
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known

----
Succeeded for Real.exp_log : ∀ {x : ℝ}, 0 < x → x.log.exp = x
Failed for Finset.card_univ : ∀ {α : Type u_1} [inst : Fintype α], Finset.univ.card = Fintype.card α
typeclass instance problem is stuck, it is often due to metavariables
  Fintype ?m.1241

----
Succeeded for DFunLike.congr_arg : ∀ {F : Sort u_1} {α : Sort u_2} {β : Sort u_3} [i : FunLike F α β] (f : F) {x y : α}, x = y → f x = f y
Succeeded for Int.natAbs_of_nonneg : ∀ {a : ℤ}, 0 ≤ a → ↑a.natAbs = a
Succeeded for OrderIso.map_sup : ∀ {α : Type u_2} {β : Type u_3} [inst : SemilatticeSup α] [inst_1 : SemilatticeSup β] (f : α ≃o β) (x y : α),
  f (x ⊔ y) = f x ⊔ f y
Succeeded for Mathlib.Data.Set.Basic._auxLemma.15 : ∀ {α : Type u} (s : Set α), (s ⊆ Set.univ) = True
Succeeded for mul_div_cancel_left : ∀ {G : Type u_3} [inst : CommGroup G] (a b : G), a * b / a = b
Succeeded for LipschitzWith.continuous : ∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {K : NNReal} {f : α → β},
  LipschitzWith K f → Continuous f
Succeeded for MeasureTheory.integral_undef : ∀ {α : Type u_1} {G : Type u_5} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}
  {μ : MeasureTheory.Measure α} {f : α → G}, ¬MeasureTheory.Integrable f μ → ∫ (a : α), f a ∂μ = 0
Succeeded for Set.disjoint_iff_inter_eq_empty : ∀ {α : Type u} {s t : Set α}, Disjoint s t ↔ s ∩ t = ∅
Succeeded for Nat.add_succ : ∀ (n m : ℕ), n + m.succ = (n + m).succ
Failed for inv_le_inv : ∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a b : α}, 0 < a → 0 < b → (a⁻¹ ≤ b⁻¹ ↔ b ≤ a)
invalid binder annotation, type is not a class instance
  LinearOrderedSemifield α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for AlternatingMap.map_eq_zero_of_eq : ∀ {R : Type u_1} [inst : Semiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_3}
  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {ι : Type u_7} (f : M [⋀^ι]→ₗ[R] N) (v : ι → M) {i j : ι},
  v i = v j → i ≠ j → f v = 0
Succeeded for Units.val_inv_eq_inv_val : ∀ {α : Type u} [inst : DivisionMonoid α] (u : αˣ), ↑u⁻¹ = (↑u)⁻¹
Failed for finrank_eq_rank : ∀ (R : Type u) (M : Type v) [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]
  [inst_3 : StrongRankCondition R] [inst_4 : Module.Finite R M], ↑(FiniteDimensional.finrank R M) = Module.rank R M
unknown constant 'FiniteDimensional.finrank'

----
Succeeded for Set.iUnion_subset : ∀ {α : Type u_1} {ι : Sort u_4} {s : ι → Set α} {t : Set α}, (∀ (i : ι), s i ⊆ t) → ⋃ i, s i ⊆ t
Succeeded for Bornology.IsBounded.subset : ∀ {α : Type u_2} {x : Bornology α} {s t : Set α}, Bornology.IsBounded t → s ⊆ t → Bornology.IsBounded s
Failed for MeasureTheory.stronglyMeasurable_const : ∀ {α : Type u_5} {β : Type u_6} {x : MeasurableSpace α} [inst : TopologicalSpace β] {b : β},
  MeasureTheory.StronglyMeasurable fun x => b
typeclass instance problem is stuck, it is often due to metavariables
  MeasurableSpace ?m.373

----
Succeeded for Set.mem_iUnion₂ : ∀ {γ : Type u_3} {ι : Sort u_4} {κ : ι → Sort u_7} {x : γ} {s : (i : ι) → κ i → Set γ},
  x ∈ ⋃ i, ⋃ j, s i j ↔ ∃ i j, x ∈ s i j
Succeeded for Finsupp.single_zero : ∀ {α : Type u_1} {M : Type u_5} [inst : Zero M] (a : α), (fun₀ | a => 0) = 0
Succeeded for smul_eq_zero : ∀ {R : Type u_2} {M : Type u_5} [inst : Zero R] [inst_1 : Zero M] [inst_2 : SMulWithZero R M]
  [inst_3 : NoZeroSMulDivisors R M] {c : R} {x : M}, c • x = 0 ↔ c = 0 ∨ x = 0
Succeeded for CategoryTheory.Limits.Sigma.hom_ext : ∀ {β : Type w} {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {f : β → C}
  [inst_1 : CategoryTheory.Limits.HasCoproduct f] {X : C} (g₁ g₂ : ∐ f ⟶ X),
  (∀ (b : β),
      CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι f b) g₁ =
        CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι f b) g₂) →
    g₁ = g₂
Succeeded for MeasurableSet.union : ∀ {α : Type u_1} {m : MeasurableSpace α} {s₁ s₂ : Set α}, MeasurableSet s₁ → MeasurableSet s₂ → MeasurableSet (s₁ ∪ s₂)
Succeeded for Submodule.add_mem : ∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : Module R M} (p : Submodule R M)
  {x y : M}, x ∈ p → y ∈ p → x + y ∈ p
Succeeded for List.not_mem_nil : ∀ {α : Type u_1} (a : α), a ∉ []
Succeeded for Equiv.symm_comp_self : ∀ {α : Sort u} {β : Sort v} (e : α ≃ β), ⇑e.symm ∘ ⇑e = id
Succeeded for ENNReal.coe_lt_coe : ∀ {r q : NNReal}, ↑r < ↑q ↔ r < q
Succeeded for deriv_zero_of_not_differentiableAt : ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {F : Type v} [inst_1 : NormedAddCommGroup F]
  [inst_2 : NormedSpace 𝕜 F] {f : 𝕜 → F} {x : 𝕜}, ¬DifferentiableAt 𝕜 f x → deriv f x = 0
Succeeded for IsFractionRing.injective : ∀ (R : Type u_1) [inst : CommRing R] (K : Type u_5) [inst_1 : CommRing K] [inst_2 : Algebra R K]
  [inst_3 : IsFractionRing R K], Function.Injective ⇑(algebraMap R K)
Succeeded for Setoid.symm : ∀ {α : Sort u} [inst : Setoid α] {a b : α}, a ≈ b → b ≈ a
Succeeded for Metric.ball_subset_closedBall : ∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α} {ε : ℝ}, Metric.ball x ε ⊆ Metric.closedBall x ε
Succeeded for Function.update_eq_self : ∀ {α : Sort u} {β : α → Sort v} [inst : DecidableEq α] (a : α) (f : (a : α) → β a), Function.update f a (f a) = f
Failed for Complex.ofReal_cos : ∀ (x : ℝ), ↑x.cos = (↑x).cos
invalid coercion notation, expected type is not known

----
Succeeded for Filter.Tendsto.le_comap : ∀ {α : Type u} {β : Type v} {f : α → β} {l₁ : Filter α} {l₂ : Filter β}, Filter.Tendsto f l₁ l₂ → l₁ ≤ Filter.comap f l₂
Succeeded for Linarith.eq_of_not_lt_of_not_gt : ∀ {α : Type u_1} [inst : LinearOrder α] (a b : α), ¬a < b → ¬b < a → a = b
Succeeded for not_not_intro : ∀ {p : Prop}, p → ¬¬p
Succeeded for Complex.ofReal_inj : ∀ {z w : ℝ}, ↑z = ↑w ↔ z = w
Failed for Real.toNNReal_coe : ∀ {r : NNReal}, (↑r).toNNReal = r
invalid coercion notation, expected type is not known

----
Succeeded for CategoryTheory.Discrete.eq_of_hom : ∀ {α : Type u₁} {X Y : CategoryTheory.Discrete α}, (X ⟶ Y) → X.as = Y.as
Succeeded for inf_sup_left : ∀ {α : Type u} [inst : DistribLattice α] (a b c : α), a ⊓ (b ⊔ c) = a ⊓ b ⊔ a ⊓ c
Failed for AddCommGroupCat.ext : ∀ {X Y : AddCommGroupCat} {f g : X ⟶ Y}, (∀ (x : ↑X), f x = g x) → f = g
failed to synthesize
  Quiver AddCommGroupCat

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.
failed to synthesize
  Quiver AddCommGroupCat

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.
type mismatch
  X
has type
  AddCommGroupCat : Type ?u.12
but is expected to have type
  Sort ?u.680 : Type ?u.680

----
Failed for nhds_induced : ∀ {α : Type u} {β : Type v} [T : TopologicalSpace α] (f : β → α) (a : β), nhds a = Filter.comap f (nhds (f a))
failed to synthesize
  TopologicalSpace β

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Failed for Subtype.range_val : ∀ {α : Type u_1} {s : Set α}, Set.range Subtype.val = s
don't know how to synthesize implicit argument 'ι'
  @Set.range α (Subtype ?m.53) Subtype.val
context:
α : Type u_1
s : Set α
⊢ Type (max 0 u_1)

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'p'
  @Subtype.val α ?m.53
context:
α : Type u_1
s : Set α
⊢ α → Prop

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for Metric.isOpen_ball : ∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α} {ε : ℝ}, IsOpen (Metric.ball x ε)
Succeeded for CategoryTheory.Limits.IsZero.eq_of_tgt : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C},
  CategoryTheory.Limits.IsZero X → ∀ (f g : Y ⟶ X), f = g
Succeeded for Homeomorph.isOpenMap : ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (h : X ≃ₜ Y), IsOpenMap ⇑h
Succeeded for Finset.cons_induction_on : ∀ {α : Type u_4} {p : Finset α → Prop} (s : Finset α),
  p ∅ → (∀ ⦃a : α⦄ {s : Finset α} (h : a ∉ s), p s → p (Finset.cons a s h)) → p s
Failed for MeasureTheory.Measure.dirac_apply' : ∀ {α : Type u_1} [inst : MeasurableSpace α] {s : Set α} (a : α),
  MeasurableSet s → ↑↑(MeasureTheory.Measure.dirac a) s = s.indicator 1 a
invalid coercion notation, expected type is not known
invalid coercion notation, expected type is not known

----
Succeeded for Submonoid.ext : ∀ {M : Type u_1} [inst : MulOneClass M] {S T : Submonoid M}, (∀ (x : M), x ∈ S ↔ x ∈ T) → S = T
Succeeded for Mathlib.Data.Finset.Basic._auxLemma.2 : ∀ {α : Type u_1} {a : α} {s : Finset α}, (a ∈ s.val) = (a ∈ s)
Succeeded for Complex.ext_iff : ∀ {z w : ℂ}, z = w ↔ z.re = w.re ∧ z.im = w.im
Succeeded for Filter.EventuallyEq.rfl : ∀ {α : Type u} {β : Type v} {l : Filter α} {f : α → β}, l.EventuallyEq f f
Succeeded for mul_lt_mul_of_pos_left : ∀ {α : Type u_1} {a b c : α} [inst : Mul α] [inst_1 : Zero α] [inst_2 : Preorder α] [inst_3 : PosMulStrictMono α],
  b < c → 0 < a → a * b < a * c
Succeeded for Int.zero_mul : ∀ (a : ℤ), 0 * a = 0
Succeeded for Real.sin_neg : ∀ (x : ℝ), (-x).sin = -x.sin
Succeeded for Complex.ofReal_pow : ∀ (r : ℝ) (n : ℕ), ↑(r ^ n) = ↑r ^ n
Failed for add_halves : ∀ {α : Type u_2} [inst : LinearOrderedSemifield α] (a : α), a / 2 + a / 2 = a
invalid binder annotation, type is not a class instance
  LinearOrderedSemifield α

Note: Use the command `set_option checkBinderAnnotations false` to disable the check

----
Succeeded for RingHom.map_neg : ∀ {α : Type u_2} {β : Type u_3} [inst : NonAssocRing α] [inst_1 : NonAssocRing β] (f : α →+* β) (x : α), f (-x) = -f x
Succeeded for Set.image2_subset_iff : ∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} {f : α → β → γ} {s : Set α} {t : Set β} {u : Set γ},
  Set.image2 f s t ⊆ u ↔ ∀ x ∈ s, ∀ y ∈ t, f x y ∈ u
Succeeded for Ideal.mul_mem_right : ∀ {α : Type u} {a : α} (b : α) [inst : CommSemiring α] (I : Ideal α), a ∈ I → a * b ∈ I
Failed for Continuous.fst' : ∀ {X : Type u} {Y : Type v} {Z : Type u_1} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]
  [inst_2 : TopologicalSpace Z] {f : X → Z}, Continuous f → Continuous fun x => f x.1
Invalid projection: Type of
  x
is not known; cannot resolve projection `1`

----
Succeeded for vadd_vsub : ∀ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (g : G) (p : P), g +ᵥ p -ᵥ p = g
Failed for Set.subsingleton_singleton : ∀ {α : Type u} {a : α}, {a}.Subsingleton
overloaded, errors 
  Invalid field notation: Type of
    {a}
  is not known; cannot resolve field `Subsingleton`
  
  invalid {...} notation, expected type is not known

----
Succeeded for Equiv.Perm.mem_support : ∀ {α : Type u_1} [inst : DecidableEq α] [inst_1 : Fintype α] {f : Equiv.Perm α} {x : α}, x ∈ f.support ↔ f x ≠ x
Succeeded for Set.image_preimage_subset : ∀ {α : Type u_1} {β : Type u_2} (f : α → β) (s : Set β), f '' (f ⁻¹' s) ⊆ s
Succeeded for Cardinal.lift_inj : ∀ {a b : Cardinal.{u}}, Cardinal.lift.{v, u} a = Cardinal.lift.{v, u} b ↔ a = b
Succeeded for norm_norm : ∀ {α : Type u_1} [inst : SeminormedAddCommGroup α] (x : α), ‖‖x‖‖ = ‖x‖
Succeeded for Int.eq_ofNat_of_zero_le : ∀ {a : ℤ}, 0 ≤ a → ∃ n, a = ↑n
Succeeded for Fin.succ_pred : ∀ {n : ℕ} (i : Fin (n + 1)) (h : i ≠ 0), (i.pred h).succ = i
Failed for Function.Surjective.comp : ∀ {α : Sort u₁} {β : Sort u₂} {φ : Sort u₃} {g : β → φ} {f : α → β},
  Function.Surjective g → Function.Surjective f → Function.Surjective (g ∘ f)
unexpected token 'φ'; expected '_' or identifier

----
Succeeded for nsmul_one : ∀ {A : Type u_6} [inst : AddMonoidWithOne A] (n : ℕ), n • 1 = ↑n
Succeeded for total_of : ∀ {α : Sort u} (r : α → α → Prop) [inst : IsTotal α r] (a b : α), r a b ∨ r b a
Failed for Option.some_injective : ∀ (α : Type u_5), Function.Injective some
don't know how to synthesize implicit argument 'β'
  @Function.Injective (?m.14 α) (Option (?m.14 α)) some
context:
α : Type u_5
⊢ Type ?u.9

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @Function.Injective (?m.14 α) (Option (?m.14 α)) some
context:
α : Type u_5
⊢ Type ?u.9

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed
don't know how to synthesize implicit argument 'α'
  @some (?m.14 α)
context:
α : Type u_5
⊢ Type ?u.9

Note: When the resulting type of a declaration is explicitly provided, all holes (e.g., `_`) in the header are resolved before the declaration body is processed

----
Succeeded for Finset.mem_product : ∀ {α : Type u_1} {β : Type u_2} {s : Finset α} {t : Finset β} {p : α × β}, p ∈ s ×ˢ t ↔ p.1 ∈ s ∧ p.2 ∈ t
Failed for Matrix.det_one : ∀ {n : Type u_2} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R], Matrix.det 1 = 1
failed to synthesize
  CommRing ℕ

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Succeeded for Finsupp.single_eq_of_ne : ∀ {α : Type u_1} {M : Type u_5} [inst : Zero M] {a a' : α} {b : M}, a ≠ a' → (fun₀ | a => b) a' = 0
Succeeded for Prime.not_unit : ∀ {α : Type u_1} [inst : CommMonoidWithZero α] {p : α}, Prime p → ¬IsUnit p
Failed for ContinuousMap.coe_zero : ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : Zero β], ⇑0 = 0
cannot coerce to function
  0

----
Succeeded for LocallyConstant.ext : ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] ⦃f g : LocallyConstant X Y⦄, (∀ (x : X), f x = g x) → f = g
Failed for Finsupp.coe_zero : ∀ {α : Type u_1} {M : Type u_5} [inst : Zero M], ⇑0 = 0
cannot coerce to function
  0

----
Succeeded for And.symm : ∀ {a b : Prop}, a ∧ b → b ∧ a
Succeeded for Mathlib.CategoryTheory.Idempotents.Karoubi._auxLemma.1 : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] {P Q : CategoryTheory.Idempotents.Karoubi C}
  {f g : P ⟶ Q}, (f = g) = (f.f = g.f)
Succeeded for intervalIntegral.integral_const : ∀ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace ℝ E] {a b : ℝ} (c : E),
  ∫ (x : ℝ) in a..b, c = (b - a) • c
Succeeded for CategoryTheory.mono_comp : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y Z : C} (f : X ⟶ Y) [inst_1 : CategoryTheory.Mono f]
  (g : Y ⟶ Z) [inst_2 : CategoryTheory.Mono g], CategoryTheory.Mono (CategoryTheory.CategoryStruct.comp f g)
Succeeded for Set.Finite.countable : ∀ {α : Type u} {s : Set α}, s.Finite → s.Countable
Succeeded for Monotone.map_min : ∀ {α : Type u} {β : Type v} [inst : LinearOrder α] [inst_1 : LinearOrder β] {f : α → β} {a b : α},
  Monotone f → f (min a b) = min (f a) (f b)
Succeeded for Filter.neBot_iff : ∀ {α : Type u} {f : Filter α}, f.NeBot ↔ f ≠ ⊥
Succeeded for CategoryTheory.Limits.isZero_zero : ∀ (C : Type u) [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroObject C],
  CategoryTheory.Limits.IsZero 0
Succeeded for Filter.inf_principal : ∀ {α : Type u} {s t : Set α}, Filter.principal s ⊓ Filter.principal t = Filter.principal (s ∩ t)
Succeeded for Int.ofNat_zero_le : ∀ (n : ℕ), 0 ≤ ↑n
Failed for Vector.head_cons : ∀ {α : Type u} {n : ℕ} (a : α) (v : Vector α n), (a ::ᵥ v).head = a
Application type mismatch: In the application
  a ::ᵥ v
the argument
  v
has type
  Vector α n : Type u
but is expected to have type
  List.Vector α (?m.1926 a v) : Type u

----
Succeeded for Nat.Prime.coprime_iff_not_dvd : ∀ {p n : ℕ}, p.Prime → (p.Coprime n ↔ ¬p ∣ n)
Succeeded for edist_dist : ∀ {α : Type u} [inst : PseudoMetricSpace α] (x y : α), edist x y = ENNReal.ofReal (dist x y)
Succeeded for iSup_mono : ∀ {α : Type u_1} {ι : Sort u_5} [inst : CompleteLattice α] {f g : ι → α}, (∀ (i : ι), f i ≤ g i) → iSup f ≤ iSup g
Succeeded for sSup_eq_iSup : ∀ {α : Type u_1} [inst : CompleteLattice α] {s : Set α}, sSup s = ⨆ a ∈ s, a
Succeeded for Nat.le.dest : ∀ {n m : ℕ}, n ≤ m → ∃ k, n + k = m
Succeeded for Mathlib.Data.Complex.Basic._auxLemma.1 : ∀ {z w : ℝ}, (↑z = ↑w) = (z = w)
Failed for Complex.smul_re : ∀ {R : Type u_1} [inst : SMul R ℝ] (r : R) (z : ℂ), (r • z).re = r • z.re
failed to synthesize
  HSMul R ℂ ?m.7347

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Failed for Complex.smul_im : ∀ {R : Type u_1} [inst : SMul R ℝ] (r : R) (z : ℂ), (r • z).im = r • z.im
failed to synthesize
  HSMul R ℂ ?m.7347

Hint: Additional diagnostic information may be available using the `set_option diagnostics true` command.

----
Failed for Continuous.snd' : ∀ {X : Type u} {Y : Type v} {Z : Type u_1} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]
  [inst_2 : TopologicalSpace Z] {f : Y → Z}, Continuous f → Continuous fun x => f x.2
Invalid projection: Type of
  x
is not known; cannot resolve projection `2`

----
Succeeded for Polynomial.map_C : ∀ {R : Type u} {S : Type v} {a : R} [inst : Semiring R] [inst_1 : Semiring S] (f : R →+* S),
  Polynomial.map f (Polynomial.C a) = Polynomial.C (f a)
Succeeded for Mathlib.Data.Set.Basic._auxLemma.9 : ∀ {α : Type u} (s : Set α), (∅ ⊆ s) = True
Succeeded for CategoryTheory.Limits.prod.lift_map : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {V W X Y Z : C}
  [inst_1 : CategoryTheory.Limits.HasBinaryPro