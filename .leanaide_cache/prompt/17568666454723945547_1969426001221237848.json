[["constructor for `prod` ",{"type":"{n : â„•} â†’ {Î± Î² : TypeVec.{u} n} â†’ (i : Fin2 n) â†’ Î± i â†’ Î² i â†’ TypeVec.prod Î± Î² i","name":"TypeVec.prod.mk","isProp":false,"docString":"constructor for `prod` ","distance":0.324379102040981914800710228519164957106113433837890625}],[" For any topological spaces X and Y, the first projection function Prod.fst from X Ã— Y to X is an open map.",{"type":"âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], IsOpenMap Prod.fst","name":"isOpenMap_fst","isProp":true,"docString":" For any topological spaces X and Y, the first projection function Prod.fst from X Ã— Y to X is an open map.","distance":0.46951095819239452300308812482398934662342071533203125}],["This theorem, which is a part of Profinite's NobelingProof, asserts the following: for any type `I` equipped with a linear order, a set `C` of Boolean-valued functions on `I`, a product `l` of elements from `I`, and a predicate `J` on `I`, if every element `a` in the product `l` satisfies the predicate `J`, then for any `j` in `I` that can be decided by `J`, the composition of the evaluation of `l` under the image of `Proj Ï€ J` with the restriction of `Proj Ï€ J` to `C`, is equal to the evaluation of `l` under `C`. \n\nIn simple terms, this theorem shows a relationship between the evaluation of a product under a set of functions and its projection restricted to a subset, assuming that all elements of the product satisfy a certain property. The mathematical operations involved are function composition and evaluation.",{"type":"âˆ€ {I : Type u} [inst : LinearOrder I] (C : Set (I â†’ Bool)) {l : Profinite.NobelingProof.Products I} (J : I â†’ Prop),\n  (âˆ€ a âˆˆ â†‘l, J a) â†’\n    âˆ€ [inst_1 : (j : I) â†’ Decidable (J j)],\n      â‡‘(Profinite.NobelingProof.Products.eval (Profinite.NobelingProof.Ï€ C J) l) âˆ˜\n          Profinite.NobelingProof.ProjRestrict C J =\n        â‡‘(Profinite.NobelingProof.Products.eval C l)","name":"Profinite.NobelingProof.Products.evalFacProp","isProp":true,"docString":"This theorem, which is a part of Profinite's NobelingProof, asserts the following: for any type `I` equipped with a linear order, a set `C` of Boolean-valued functions on `I`, a product `l` of elements from `I`, and a predicate `J` on `I`, if every element `a` in the product `l` satisfies the predicate `J`, then for any `j` in `I` that can be decided by `J`, the composition of the evaluation of `l` under the image of `Proj Ï€ J` with the restriction of `Proj Ï€ J` to `C`, is equal to the evaluation of `l` under `C`. \n\nIn simple terms, this theorem shows a relationship between the evaluation of a product under a set of functions and its projection restricted to a subset, assuming that all elements of the product satisfy a certain property. The mathematical operations involved are function composition and evaluation.","distance":0.445451046656548832469724175098235718905925750732421875}],["Delaborator for simple product projections. ",{"type":"Lean.PrettyPrinter.Delaborator.Delab","name":"delabProdProjs","isProp":false,"docString":"Delaborator for simple product projections. ","distance":0.33869213187494107142327948167803697288036346435546875}],[" The second projection of a product space is an open map, that is, the image of an open set under the second projection is an open set in the second factor space.",{"type":"âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], IsOpenMap Prod.snd","name":"isOpenMap_snd","isProp":true,"docString":" The second projection of a product space is an open map, that is, the image of an open set under the second projection is an open set in the second factor space.","distance":0.472885731745574577900015356135554611682891845703125}],["This theorem states that for any non-trivial normed field `ğ•œ`, any normed additive commutative group `E`, any normed vector space over `ğ•œ` of `E`, any normed additive commutative group `F`, and any normed vector space over `ğ•œ` of `F`, the second projection function `Prod.snd` is differentiable at any point `p` in the product space `E Ã— F`. In mathematical terms, if `p` belongs to the Cartesian product of sets `E` and `F`, the function `Prod.snd` that projects `p` onto the second coordinate (`F`) admits a derivative at `p`.",{"type":"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {p : E Ã— F},\n  DifferentiableAt ğ•œ Prod.snd p","name":"differentiableAt_snd","isProp":true,"docString":"This theorem states that for any non-trivial normed field `ğ•œ`, any normed additive commutative group `E`, any normed vector space over `ğ•œ` of `E`, any normed additive commutative group `F`, and any normed vector space over `ğ•œ` of `F`, the second projection function `Prod.snd` is differentiable at any point `p` in the product space `E Ã— F`. In mathematical terms, if `p` belongs to the Cartesian product of sets `E` and `F`, the function `Prod.snd` that projects `p` onto the second coordinate (`F`) admits a derivative at `p`.","distance":0.448688144376078124064832763906451873481273651123046875}],["The map from the coproduct into the pushout ",{"type":"{Î¹ : Type u_1} â†’\n  {G : Î¹ â†’ Type u_2} â†’\n    {H : Type u_3} â†’\n      [inst : (i : Î¹) â†’ Monoid (G i)] â†’\n        [inst_1 : Monoid H] â†’ {Ï† : (i : Î¹) â†’ H â†’* G i} â†’ Monoid.CoprodI G â†’* Monoid.PushoutI Ï†","name":"Monoid.PushoutI.ofCoprodI","isProp":false,"docString":"The map from the coproduct into the pushout ","distance":0.370809241989726923183212647927575744688510894775390625}],["The coproduct is the pushout under the initial object. ",{"type":"{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    {W X Y Z : C} â†’\n      (f : X âŸ¶ Z) â†’\n        (g : Y âŸ¶ Z) â†’\n          (h : W âŸ¶ X) â†’\n            (k : W âŸ¶ Y) â†’\n              (Hâ‚ : CategoryTheory.Limits.IsInitial W) â†’\n                CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.BinaryCofan.mk f g) â†’\n                  CategoryTheory.Limits.IsColimit\n                    (CategoryTheory.Limits.PushoutCocone.mk f g\n                      (_ : CategoryTheory.CategoryStruct.comp h f = CategoryTheory.CategoryStruct.comp k g))","name":"isPushoutOfIsInitialIsCoproduct","isProp":false,"docString":"The coproduct is the pushout under the initial object. ","distance":0.37126386796074328788819229885120876133441925048828125}],["The first projection from the product. ",{"type":"{X Y : TopCat} â†’ TopCat.of (â†‘X Ã— â†‘Y) âŸ¶ X","name":"TopCat.prodFst","isProp":false,"docString":"The first projection from the product. ","distance":0.371281955048824718890188023578957654535770416259765625}],["projection expression ",{"type":"Simps.ParsedProjectionData â†’ Option Lean.Expr","name":"Simps.ParsedProjectionData.expr?","isProp":false,"docString":"projection expression ","distance":0.37193191507911682602838254751986823976039886474609375}],["Notation for the product ",{"type":"Lean.TrailingParserDescr","name":"CategoryTheory.Limits.Â«term_â¨¯_Â»","isProp":false,"docString":"Notation for the product ","distance":0.379022805248075467243751290880027227103710174560546875}],["The second projection from the product. ",{"type":"{X Y : TopCat} â†’ TopCat.of (â†‘X Ã— â†‘Y) âŸ¶ Y","name":"TopCat.prodSnd","isProp":false,"docString":"The second projection from the product. ","distance":0.380204267026275244401034569818875752389430999755859375}],["The first projection of a product, as a smooth map. ",{"type":"{ğ•œ : Type u_1} â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    {E : Type u_2} â†’\n      [inst_1 : NormedAddCommGroup E] â†’\n        [inst_2 : NormedSpace ğ•œ E] â†’\n          {E' : Type u_3} â†’\n            [inst_3 : NormedAddCommGroup E'] â†’\n              [inst_4 : NormedSpace ğ•œ E'] â†’\n                {H : Type u_4} â†’\n                  [inst_5 : TopologicalSpace H] â†’\n                    {H' : Type u_5} â†’\n                      [inst_6 : TopologicalSpace H'] â†’\n                        {I : ModelWithCorners ğ•œ E H} â†’\n                          {I' : ModelWithCorners ğ•œ E' H'} â†’\n                            {M : Type u_6} â†’\n                              [inst_7 : TopologicalSpace M] â†’\n                                [inst_8 : ChartedSpace H M] â†’\n                                  {M' : Type u_7} â†’\n                                    [inst_9 : TopologicalSpace M'] â†’\n                                      [inst_10 : ChartedSpace H' M'] â†’\n                                        {n : â„•âˆ} â†’ ContMDiffMap (ModelWithCorners.prod I I') I (M Ã— M') M n","name":"ContMDiffMap.fst","isProp":false,"docString":"The first projection of a product, as a smooth map. ","distance":0.383861008105433165749076351858093403279781341552734375}],["left projection of a `prod` vector ",{"type":"{n : â„•} â†’ {Î± Î² : TypeVec.{u} n} â†’ TypeVec.Arrow (TypeVec.prod Î± Î²) Î±","name":"TypeVec.prod.fst","isProp":false,"docString":"left projection of a `prod` vector ","distance":0.385257759856341863713424800153006799519062042236328125}],["The set of good products. ",{"type":"{I : Type u} â†’ [inst : LinearOrder I] â†’ Set (I â†’ Bool) â†’ Set (Profinite.NobelingProof.Products I)","name":"Profinite.NobelingProof.GoodProducts","isProp":false,"docString":"The set of good products. ","distance":0.385446951196765585923031949278083629906177520751953125}],["The second projection of a product, as a smooth map. ",{"type":"{ğ•œ : Type u_1} â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    {E : Type u_2} â†’\n      [inst_1 : NormedAddCommGroup E] â†’\n        [inst_2 : NormedSpace ğ•œ E] â†’\n          {E' : Type u_3} â†’\n            [inst_3 : NormedAddCommGroup E'] â†’\n              [inst_4 : NormedSpace ğ•œ E'] â†’\n                {H : Type u_4} â†’\n                  [inst_5 : TopologicalSpace H] â†’\n                    {H' : Type u_5} â†’\n                      [inst_6 : TopologicalSpace H'] â†’\n                        {I : ModelWithCorners ğ•œ E H} â†’\n                          {I' : ModelWithCorners ğ•œ E' H'} â†’\n                            {M : Type u_6} â†’\n                              [inst_7 : TopologicalSpace M] â†’\n                                [inst_8 : ChartedSpace H M] â†’\n                                  {M' : Type u_7} â†’\n                                    [inst_9 : TopologicalSpace M'] â†’\n                                      [inst_10 : ChartedSpace H' M'] â†’\n                                        {n : â„•âˆ} â†’ ContMDiffMap (ModelWithCorners.prod I I') I' (M Ã— M') M' n","name":"ContMDiffMap.snd","isProp":false,"docString":"The second projection of a product, as a smooth map. ","distance":0.385727903248855252815729954818380065262317657470703125}],["The projection map to the first component of the product. ",{"type":"{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    {X Y : C} â†’ [inst_1 : CategoryTheory.Limits.HasBinaryProduct X Y] â†’ X â¨¯ Y âŸ¶ X","name":"CategoryTheory.Limits.prod.fst","isProp":false,"docString":"The projection map to the first component of the product. ","distance":0.388759880444312921898841750589781440794467926025390625}],["The program. ",{"type":"{Î“ : Type u_1} â†’\n  {Î› : Type u_2} â†’\n    [inst : Inhabited Î›] â†’ Turing.TM0.Machine Î“ Î› â†’ Turing.TM0to1.Î›' â†’ Turing.TM1.Stmt Î“ Turing.TM0to1.Î›' Unit","name":"Turing.TM0to1.tr","isProp":false,"docString":"The program. ","distance":0.38889930973349862153298772682319395244121551513671875}],["The property of preserving products expressed in terms of fans. ",{"type":"{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    {D : Type uâ‚‚} â†’\n      [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] â†’\n        (G : CategoryTheory.Functor C D) â†’\n          {J : Type w} â†’\n            (f : J â†’ C) â†’\n              [inst_2 : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Discrete.functor f) G] â†’\n                {P : C} â†’\n                  (g : (j : J) â†’ P âŸ¶ f j) â†’\n                    CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.Fan.mk P g) â†’\n                      CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.Fan.mk (G.obj P) fun j => G.map (g j))","name":"CategoryTheory.Limits.isLimitFanMkObjOfIsLimit","isProp":false,"docString":"The property of preserving products expressed in terms of fans. ","distance":0.3895648960196218535401158078457228839397430419921875}],["The first projection of a product is a linear map. ",{"type":"(R : Type u) â†’\n  (M : Type v) â†’\n    (Mâ‚‚ : Type w) â†’\n      [inst : Semiring R] â†’\n        [inst_1 : AddCommMonoid M] â†’\n          [inst_2 : AddCommMonoid Mâ‚‚] â†’ [inst_3 : Module R M] â†’ [inst_4 : Module R Mâ‚‚] â†’ M Ã— Mâ‚‚ â†’â‚—[R] M","name":"LinearMap.fst","isProp":false,"docString":"The first projection of a product is a linear map. ","distance":0.39122648649180880031650531236664392054080963134765625}],["`Prod.map` as a relation embedding. ",{"type":"{Î± : Type u_1} â†’\n  {Î² : Type u_2} â†’\n    {Î³ : Type u_3} â†’\n      {Î´ : Type u_4} â†’\n        {r : Î± â†’ Î± â†’ Prop} â†’\n          {s : Î² â†’ Î² â†’ Prop} â†’ {t : Î³ â†’ Î³ â†’ Prop} â†’ {u : Î´ â†’ Î´ â†’ Prop} â†’ r â†ªr s â†’ t â†ªr u â†’ Prod.Lex r t â†ªr Prod.Lex s u","name":"RelEmbedding.prodLexMap","isProp":false,"docString":"`Prod.map` as a relation embedding. ","distance":0.39212900372397374582078555249609053134918212890625}],["`prod` is functorial ",{"type":"{n : â„•} â†’\n  {Î± Î±' Î² Î²' : TypeVec.{u} n} â†’\n    TypeVec.Arrow Î± Î² â†’ TypeVec.Arrow Î±' Î²' â†’ TypeVec.Arrow (TypeVec.prod Î± Î±') (TypeVec.prod Î² Î²')","name":"TypeVec.prod.map","isProp":false,"docString":"`prod` is functorial ","distance":0.392286361677860406782514246515347622334957122802734375}],["The projection map to the second component of the product. ",{"type":"{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    {X Y : C} â†’ [inst_1 : CategoryTheory.Limits.HasBinaryProduct X Y] â†’ X â¨¯ Y âŸ¶ Y","name":"CategoryTheory.Limits.prod.snd","isProp":false,"docString":"The projection map to the second component of the product. ","distance":0.392918473555061542601407609254238195717334747314453125}],["The prod of two morphisms is a morphism. ",{"type":"{R : Type u} â†’\n  {A : Type v} â†’\n    {B : Type w} â†’\n      {C : Type wâ‚} â†’\n        [inst : Monoid R] â†’\n          [inst_1 : NonUnitalNonAssocSemiring A] â†’\n            [inst_2 : DistribMulAction R A] â†’\n              [inst_3 : NonUnitalNonAssocSemiring B] â†’\n                [inst_4 : DistribMulAction R B] â†’\n                  [inst_5 : NonUnitalNonAssocSemiring C] â†’\n                    [inst_6 : DistribMulAction R C] â†’ (A â†’â‚™â‚[R] B) â†’ (A â†’â‚™â‚[R] C) â†’ A â†’â‚™â‚[R] B Ã— C","name":"NonUnitalAlgHom.prod","isProp":false,"docString":"The prod of two morphisms is a morphism. ","distance":0.39452059082104706799754012536141090095043182373046875}]]