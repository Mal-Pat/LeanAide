[["constructor for `prod` ",{"type":"{n : ℕ} → {α β : TypeVec.{u} n} → (i : Fin2 n) → α i → β i → TypeVec.prod α β i","name":"TypeVec.prod.mk","isProp":false,"docString":"constructor for `prod` ","distance":0.324379102040981914800710228519164957106113433837890625}],[" For any topological spaces X and Y, the first projection function Prod.fst from X × Y to X is an open map.",{"type":"∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], IsOpenMap Prod.fst","name":"isOpenMap_fst","isProp":true,"docString":" For any topological spaces X and Y, the first projection function Prod.fst from X × Y to X is an open map.","distance":0.46951095819239452300308812482398934662342071533203125}],["This theorem, which is a part of Profinite's NobelingProof, asserts the following: for any type `I` equipped with a linear order, a set `C` of Boolean-valued functions on `I`, a product `l` of elements from `I`, and a predicate `J` on `I`, if every element `a` in the product `l` satisfies the predicate `J`, then for any `j` in `I` that can be decided by `J`, the composition of the evaluation of `l` under the image of `Proj π J` with the restriction of `Proj π J` to `C`, is equal to the evaluation of `l` under `C`. \n\nIn simple terms, this theorem shows a relationship between the evaluation of a product under a set of functions and its projection restricted to a subset, assuming that all elements of the product satisfy a certain property. The mathematical operations involved are function composition and evaluation.",{"type":"∀ {I : Type u} [inst : LinearOrder I] (C : Set (I → Bool)) {l : Profinite.NobelingProof.Products I} (J : I → Prop),\n  (∀ a ∈ ↑l, J a) →\n    ∀ [inst_1 : (j : I) → Decidable (J j)],\n      ⇑(Profinite.NobelingProof.Products.eval (Profinite.NobelingProof.π C J) l) ∘\n          Profinite.NobelingProof.ProjRestrict C J =\n        ⇑(Profinite.NobelingProof.Products.eval C l)","name":"Profinite.NobelingProof.Products.evalFacProp","isProp":true,"docString":"This theorem, which is a part of Profinite's NobelingProof, asserts the following: for any type `I` equipped with a linear order, a set `C` of Boolean-valued functions on `I`, a product `l` of elements from `I`, and a predicate `J` on `I`, if every element `a` in the product `l` satisfies the predicate `J`, then for any `j` in `I` that can be decided by `J`, the composition of the evaluation of `l` under the image of `Proj π J` with the restriction of `Proj π J` to `C`, is equal to the evaluation of `l` under `C`. \n\nIn simple terms, this theorem shows a relationship between the evaluation of a product under a set of functions and its projection restricted to a subset, assuming that all elements of the product satisfy a certain property. The mathematical operations involved are function composition and evaluation.","distance":0.445451046656548832469724175098235718905925750732421875}],["Delaborator for simple product projections. ",{"type":"Lean.PrettyPrinter.Delaborator.Delab","name":"delabProdProjs","isProp":false,"docString":"Delaborator for simple product projections. ","distance":0.33869213187494107142327948167803697288036346435546875}],[" The second projection of a product space is an open map, that is, the image of an open set under the second projection is an open set in the second factor space.",{"type":"∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], IsOpenMap Prod.snd","name":"isOpenMap_snd","isProp":true,"docString":" The second projection of a product space is an open map, that is, the image of an open set under the second projection is an open set in the second factor space.","distance":0.472885731745574577900015356135554611682891845703125}],["This theorem states that for any non-trivial normed field `𝕜`, any normed additive commutative group `E`, any normed vector space over `𝕜` of `E`, any normed additive commutative group `F`, and any normed vector space over `𝕜` of `F`, the second projection function `Prod.snd` is differentiable at any point `p` in the product space `E × F`. In mathematical terms, if `p` belongs to the Cartesian product of sets `E` and `F`, the function `Prod.snd` that projects `p` onto the second coordinate (`F`) admits a derivative at `p`.",{"type":"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {p : E × F},\n  DifferentiableAt 𝕜 Prod.snd p","name":"differentiableAt_snd","isProp":true,"docString":"This theorem states that for any non-trivial normed field `𝕜`, any normed additive commutative group `E`, any normed vector space over `𝕜` of `E`, any normed additive commutative group `F`, and any normed vector space over `𝕜` of `F`, the second projection function `Prod.snd` is differentiable at any point `p` in the product space `E × F`. In mathematical terms, if `p` belongs to the Cartesian product of sets `E` and `F`, the function `Prod.snd` that projects `p` onto the second coordinate (`F`) admits a derivative at `p`.","distance":0.448688144376078124064832763906451873481273651123046875}],["The map from the coproduct into the pushout ",{"type":"{ι : Type u_1} →\n  {G : ι → Type u_2} →\n    {H : Type u_3} →\n      [inst : (i : ι) → Monoid (G i)] →\n        [inst_1 : Monoid H] → {φ : (i : ι) → H →* G i} → Monoid.CoprodI G →* Monoid.PushoutI φ","name":"Monoid.PushoutI.ofCoprodI","isProp":false,"docString":"The map from the coproduct into the pushout ","distance":0.370809241989726923183212647927575744688510894775390625}],["The coproduct is the pushout under the initial object. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {W X Y Z : C} →\n      (f : X ⟶ Z) →\n        (g : Y ⟶ Z) →\n          (h : W ⟶ X) →\n            (k : W ⟶ Y) →\n              (H₁ : CategoryTheory.Limits.IsInitial W) →\n                CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.BinaryCofan.mk f g) →\n                  CategoryTheory.Limits.IsColimit\n                    (CategoryTheory.Limits.PushoutCocone.mk f g\n                      (_ : CategoryTheory.CategoryStruct.comp h f = CategoryTheory.CategoryStruct.comp k g))","name":"isPushoutOfIsInitialIsCoproduct","isProp":false,"docString":"The coproduct is the pushout under the initial object. ","distance":0.37126386796074328788819229885120876133441925048828125}],["The first projection from the product. ",{"type":"{X Y : TopCat} → TopCat.of (↑X × ↑Y) ⟶ X","name":"TopCat.prodFst","isProp":false,"docString":"The first projection from the product. ","distance":0.371281955048824718890188023578957654535770416259765625}],["projection expression ",{"type":"Simps.ParsedProjectionData → Option Lean.Expr","name":"Simps.ParsedProjectionData.expr?","isProp":false,"docString":"projection expression ","distance":0.37193191507911682602838254751986823976039886474609375}],["Notation for the product ",{"type":"Lean.TrailingParserDescr","name":"CategoryTheory.Limits.«term_⨯_»","isProp":false,"docString":"Notation for the product ","distance":0.379022805248075467243751290880027227103710174560546875}],["The second projection from the product. ",{"type":"{X Y : TopCat} → TopCat.of (↑X × ↑Y) ⟶ Y","name":"TopCat.prodSnd","isProp":false,"docString":"The second projection from the product. ","distance":0.380204267026275244401034569818875752389430999755859375}],["The first projection of a product, as a smooth map. ",{"type":"{𝕜 : Type u_1} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {E : Type u_2} →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : NormedSpace 𝕜 E] →\n          {E' : Type u_3} →\n            [inst_3 : NormedAddCommGroup E'] →\n              [inst_4 : NormedSpace 𝕜 E'] →\n                {H : Type u_4} →\n                  [inst_5 : TopologicalSpace H] →\n                    {H' : Type u_5} →\n                      [inst_6 : TopologicalSpace H'] →\n                        {I : ModelWithCorners 𝕜 E H} →\n                          {I' : ModelWithCorners 𝕜 E' H'} →\n                            {M : Type u_6} →\n                              [inst_7 : TopologicalSpace M] →\n                                [inst_8 : ChartedSpace H M] →\n                                  {M' : Type u_7} →\n                                    [inst_9 : TopologicalSpace M'] →\n                                      [inst_10 : ChartedSpace H' M'] →\n                                        {n : ℕ∞} → ContMDiffMap (ModelWithCorners.prod I I') I (M × M') M n","name":"ContMDiffMap.fst","isProp":false,"docString":"The first projection of a product, as a smooth map. ","distance":0.383861008105433165749076351858093403279781341552734375}],["left projection of a `prod` vector ",{"type":"{n : ℕ} → {α β : TypeVec.{u} n} → TypeVec.Arrow (TypeVec.prod α β) α","name":"TypeVec.prod.fst","isProp":false,"docString":"left projection of a `prod` vector ","distance":0.385257759856341863713424800153006799519062042236328125}],["The set of good products. ",{"type":"{I : Type u} → [inst : LinearOrder I] → Set (I → Bool) → Set (Profinite.NobelingProof.Products I)","name":"Profinite.NobelingProof.GoodProducts","isProp":false,"docString":"The set of good products. ","distance":0.385446951196765585923031949278083629906177520751953125}],["The second projection of a product, as a smooth map. ",{"type":"{𝕜 : Type u_1} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {E : Type u_2} →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : NormedSpace 𝕜 E] →\n          {E' : Type u_3} →\n            [inst_3 : NormedAddCommGroup E'] →\n              [inst_4 : NormedSpace 𝕜 E'] →\n                {H : Type u_4} →\n                  [inst_5 : TopologicalSpace H] →\n                    {H' : Type u_5} →\n                      [inst_6 : TopologicalSpace H'] →\n                        {I : ModelWithCorners 𝕜 E H} →\n                          {I' : ModelWithCorners 𝕜 E' H'} →\n                            {M : Type u_6} →\n                              [inst_7 : TopologicalSpace M] →\n                                [inst_8 : ChartedSpace H M] →\n                                  {M' : Type u_7} →\n                                    [inst_9 : TopologicalSpace M'] →\n                                      [inst_10 : ChartedSpace H' M'] →\n                                        {n : ℕ∞} → ContMDiffMap (ModelWithCorners.prod I I') I' (M × M') M' n","name":"ContMDiffMap.snd","isProp":false,"docString":"The second projection of a product, as a smooth map. ","distance":0.385727903248855252815729954818380065262317657470703125}],["The projection map to the first component of the product. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {X Y : C} → [inst_1 : CategoryTheory.Limits.HasBinaryProduct X Y] → X ⨯ Y ⟶ X","name":"CategoryTheory.Limits.prod.fst","isProp":false,"docString":"The projection map to the first component of the product. ","distance":0.388759880444312921898841750589781440794467926025390625}],["The program. ",{"type":"{Γ : Type u_1} →\n  {Λ : Type u_2} →\n    [inst : Inhabited Λ] → Turing.TM0.Machine Γ Λ → Turing.TM0to1.Λ' → Turing.TM1.Stmt Γ Turing.TM0to1.Λ' Unit","name":"Turing.TM0to1.tr","isProp":false,"docString":"The program. ","distance":0.38889930973349862153298772682319395244121551513671875}],["The property of preserving products expressed in terms of fans. ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        (G : CategoryTheory.Functor C D) →\n          {J : Type w} →\n            (f : J → C) →\n              [inst_2 : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Discrete.functor f) G] →\n                {P : C} →\n                  (g : (j : J) → P ⟶ f j) →\n                    CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.Fan.mk P g) →\n                      CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.Fan.mk (G.obj P) fun j => G.map (g j))","name":"CategoryTheory.Limits.isLimitFanMkObjOfIsLimit","isProp":false,"docString":"The property of preserving products expressed in terms of fans. ","distance":0.3895648960196218535401158078457228839397430419921875}],["The first projection of a product is a linear map. ",{"type":"(R : Type u) →\n  (M : Type v) →\n    (M₂ : Type w) →\n      [inst : Semiring R] →\n        [inst_1 : AddCommMonoid M] →\n          [inst_2 : AddCommMonoid M₂] → [inst_3 : Module R M] → [inst_4 : Module R M₂] → M × M₂ →ₗ[R] M","name":"LinearMap.fst","isProp":false,"docString":"The first projection of a product is a linear map. ","distance":0.39122648649180880031650531236664392054080963134765625}],["`Prod.map` as a relation embedding. ",{"type":"{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      {δ : Type u_4} →\n        {r : α → α → Prop} →\n          {s : β → β → Prop} → {t : γ → γ → Prop} → {u : δ → δ → Prop} → r ↪r s → t ↪r u → Prod.Lex r t ↪r Prod.Lex s u","name":"RelEmbedding.prodLexMap","isProp":false,"docString":"`Prod.map` as a relation embedding. ","distance":0.39212900372397374582078555249609053134918212890625}],["`prod` is functorial ",{"type":"{n : ℕ} →\n  {α α' β β' : TypeVec.{u} n} →\n    TypeVec.Arrow α β → TypeVec.Arrow α' β' → TypeVec.Arrow (TypeVec.prod α α') (TypeVec.prod β β')","name":"TypeVec.prod.map","isProp":false,"docString":"`prod` is functorial ","distance":0.392286361677860406782514246515347622334957122802734375}],["The projection map to the second component of the product. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {X Y : C} → [inst_1 : CategoryTheory.Limits.HasBinaryProduct X Y] → X ⨯ Y ⟶ Y","name":"CategoryTheory.Limits.prod.snd","isProp":false,"docString":"The projection map to the second component of the product. ","distance":0.392918473555061542601407609254238195717334747314453125}],["The prod of two morphisms is a morphism. ",{"type":"{R : Type u} →\n  {A : Type v} →\n    {B : Type w} →\n      {C : Type w₁} →\n        [inst : Monoid R] →\n          [inst_1 : NonUnitalNonAssocSemiring A] →\n            [inst_2 : DistribMulAction R A] →\n              [inst_3 : NonUnitalNonAssocSemiring B] →\n                [inst_4 : DistribMulAction R B] →\n                  [inst_5 : NonUnitalNonAssocSemiring C] →\n                    [inst_6 : DistribMulAction R C] → (A →ₙₐ[R] B) → (A →ₙₐ[R] C) → A →ₙₐ[R] B × C","name":"NonUnitalAlgHom.prod","isProp":false,"docString":"The prod of two morphisms is a morphism. ","distance":0.39452059082104706799754012536141090095043182373046875}]]