[["A product of finite numbers is still finite ",{"type":"∀ {ι : Type u_1} {R : Type u_8} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset ι} {f : ι → WithTop R},\n  (∀ i ∈ s, f i ≠ ⊤) → (Finset.prod s fun i => f i) < ⊤","name":"WithTop.prod_lt_top","isProp":true,"docString":"A product of finite numbers is still finite ","distance":0.26439545612771231386517456485307775437831878662109375}],[" For all natural numbers `n`, the product of `n` and `n-1` is an even number. Equivalently, the product of two consecutive natural numbers is an even number.",{"type":"∀ (n : ℕ), Even (n * (n - 1))","name":"Nat.even_mul_self_pred","isProp":true,"docString":" For all natural numbers `n`, the product of `n` and `n-1` is an even number. Equivalently, the product of two consecutive natural numbers is an even number.","distance":0.33088776864690905288313160781399346888065338134765625}],["This theorem states that for all natural numbers `n`, the product of `n` and `n - 1` is an even number. In mathematical terms, this theorem can be written as: \"∀ n ∈ ℕ, n*(n - 1) is even.\" Here, a number is considered even if it can be expressed as twice another number, in this case, n*(n - 1) = 2*r for some `r`.",{"type":"∀ (n : ℕ), Even (n * (n - 1))","name":"Nat.even_mul_self_pred","isProp":true,"docString":"This theorem states that for all natural numbers `n`, the product of `n` and `n - 1` is an even number. In mathematical terms, this theorem can be written as: \"∀ n ∈ ℕ, n*(n - 1) is even.\" Here, a number is considered even if it can be expressed as twice another number, in this case, n*(n - 1) = 2*r for some `r`.","distance":0.37475641023333039481002515458385460078716278076171875}],["The product of the factors is the original number ",{"type":"∀ (n : ℕ+), PrimeMultiset.prod (PNat.factorMultiset n) = n","name":"PNat.prod_factorMultiset","isProp":true,"docString":"The product of the factors is the original number ","distance":0.273878946519875210441341550904326140880584716796875}],[" For any list of non-negative real numbers, the product of their real number representations is equal to the real number representation of the product of the numbers in the list.",{"type":"∀ (l : List NNReal), ↑l.prod = (List.map NNReal.toReal l).prod","name":"NNReal.coe_list_prod","isProp":true,"docString":" For any list of non-negative real numbers, the product of their real number representations is equal to the real number representation of the product of the numbers in the list.","distance":0.348572157999256171390101144424988888204097747802734375}],["This theorem states that for any list of positive numbers in a strictly ordered semiring (a type of algebraic structure that includes operations analogous to addition and multiplication), the product of all numbers in the list is also positive. This theorem applies to any list of positive natural numbers and can be extended to any nontrivial ordered semiring.",{"type":"∀ {R : Type u_1} [inst : StrictOrderedSemiring R] (l : List R), (∀ a ∈ l, 0 < a) → 0 < l.prod","name":"List.prod_pos","isProp":true,"docString":"This theorem states that for any list of positive numbers in a strictly ordered semiring (a type of algebraic structure that includes operations analogous to addition and multiplication), the product of all numbers in the list is also positive. This theorem applies to any list of positive natural numbers and can be extended to any nontrivial ordered semiring.","distance":0.386567491467300350382885198996518738567829132080078125}],["A list with product less than one must have positive length. ",{"type":"∀ {M : Type u_3} [inst : Monoid M] [inst_1 : Preorder M] (L : List M), List.prod L < 1 → 0 < List.length L","name":"List.length_pos_of_prod_lt_one","isProp":true,"docString":"A list with product less than one must have positive length. ","distance":0.31651572507891800878354615633725188672542572021484375}],["A list with product greater than one must have positive length. ",{"type":"∀ {M : Type u_3} [inst : Monoid M] [inst_1 : Preorder M] (L : List M), 1 < List.prod L → 0 < List.length L","name":"List.length_pos_of_one_lt_prod","isProp":true,"docString":"A list with product greater than one must have positive length. ","distance":0.317071473517882729264982799577410332858562469482421875}],["Notation for the product ",{"type":"Lean.TrailingParserDescr","name":"CategoryTheory.Limits.«term_⨯_»","isProp":false,"docString":"Notation for the product ","distance":0.321686310429112831688058804502361454069614410400390625}],["Type product is associative up to an equivalence. ",{"type":"(α : Type u_1) → (β : Type u_2) → (γ : Type u_3) → (α × β) × γ ≃ α × β × γ","name":"Equiv.prodAssoc","isProp":false,"docString":"Type product is associative up to an equivalence. ","distance":0.322016703520702940455322504931245930492877960205078125}],["The set of good products. ",{"type":"{I : Type u} → [inst : LinearOrder I] → Set (I → Bool) → Set (Profinite.NobelingProof.Products I)","name":"Profinite.NobelingProof.GoodProducts","isProp":false,"docString":"The set of good products. ","distance":0.32207256088419200512618090215255506336688995361328125}],["The second projection from the product. ",{"type":"{X Y : TopCat} → TopCat.of (↑X × ↑Y) ⟶ Y","name":"TopCat.prodSnd","isProp":false,"docString":"The second projection from the product. ","distance":0.32507968174329093802299439630587585270404815673828125}],["Binary products are symmetric. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {X Y : C} →\n      {c : CategoryTheory.Limits.BinaryFan X Y} →\n        CategoryTheory.Limits.IsLimit c →\n          CategoryTheory.Limits.IsLimit\n            (CategoryTheory.Limits.BinaryFan.mk (CategoryTheory.Limits.BinaryFan.snd c)\n              (CategoryTheory.Limits.BinaryFan.fst c))","name":"CategoryTheory.Limits.BinaryFan.isLimitFlip","isProp":false,"docString":"Binary products are symmetric. ","distance":0.329371345115280877990926455822773277759552001953125}],["the image of a product is less or equal than the product of the images. ",{"type":"∀ {F : Type u_7} {α : outParam (Type u_8)} {β : outParam (Type u_9)} [inst : NonUnitalNonAssocRing α]\n  [inst_1 : OrderedSemiring β] [self : RingSeminormClass F α β] (f : F) (a b : α), f (a * b) ≤ f a * f b","name":"RingSeminormClass.map_mul_le_mul","isProp":true,"docString":"the image of a product is less or equal than the product of the images. ","distance":0.329533259790311172654497795520001091063022613525390625}],["A product is regular if and only if the factors are. ",{"type":"∀ {R : Type u_1} [inst : CommSemigroup R] {a b : R}, IsRegular (a * b) ↔ IsRegular a ∧ IsRegular b","name":"isRegular_mul_iff","isProp":true,"docString":"A product is regular if and only if the factors are. ","distance":0.331176434761267624029557055109762586653232574462890625}],["The inner product is positive definite. ",{"type":"∀ {𝕜 : Type u_4} {F : Type u_5} [inst : IsROrC 𝕜] [inst_1 : AddCommGroup F] [inst_2 : Module 𝕜 F]\n  (self : InnerProductSpace.Core 𝕜 F) (x : F), ⟪x, x⟫_𝕜 = 0 → x = 0","name":"InnerProductSpace.Core.definite","isProp":true,"docString":"The inner product is positive definite. ","distance":0.331587989627706913875471173014375381171703338623046875}],["the image of a product is less or equal than the sum of the images. ",{"type":"∀ {F : Type u_7} {α : outParam (Type u_8)} {β : outParam (Type u_9)} [inst : Mul α] [inst_1 : Add β] [inst_2 : LE β]\n  [self : MulLEAddHomClass F α β] (f : F) (a b : α), f (a * b) ≤ f a + f b","name":"MulLEAddHomClass.map_mul_le_add","isProp":true,"docString":"the image of a product is less or equal than the sum of the images. ","distance":0.332975105715384689375468951766379177570343017578125}],["The product of non-negative elements is non-negative. ",{"type":"∀ {α : Type u} [self : OrderedRing α] (a b : α), 0 ≤ a → 0 ≤ b → 0 ≤ a * b","name":"OrderedRing.mul_nonneg","isProp":true,"docString":"The product of non-negative elements is non-negative. ","distance":0.33332118815030520320163986980332992970943450927734375}],["The product over `Fin 2` of some rings is just the cartesian product of these rings. ",{"type":"(R : Fin 2 → Type u_1) → [inst : (i : Fin 2) → Semiring (R i)] → ((i : Fin 2) → R i) ≃+* R 0 × R 1","name":"RingEquiv.piFinTwo","isProp":false,"docString":"The product over `Fin 2` of some rings is just the cartesian product of these rings. ","distance":0.334623469826463015852624494073097594082355499267578125}],["If a direct product has finite order then so does each component. ",{"type":"∀ {η : Type u_6} {Gs : η → Type u_7} [inst : (i : η) → Monoid (Gs i)] {x : (i : η) → Gs i},\n  IsOfFinOrder x → ∀ (i : η), IsOfFinOrder (x i)","name":"IsOfFinOrder.apply","isProp":true,"docString":"If a direct product has finite order then so does each component. ","distance":0.336003491399114062598840746431960724294185638427734375}],["The projection map to the second component of the product. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {X Y : C} → [inst_1 : CategoryTheory.Limits.HasBinaryProduct X Y] → X ⨯ Y ⟶ Y","name":"CategoryTheory.Limits.prod.snd","isProp":false,"docString":"The projection map to the second component of the product. ","distance":0.33787045761309586477949551408528350293636322021484375}],["Two natural numbers are equal if and only if they have the same multiples. ",{"type":"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n","name":"Nat.dvd_right_iff_eq","isProp":true,"docString":"Two natural numbers are equal if and only if they have the same multiples. ","distance":0.338910123675090602102244474735925905406475067138671875}],["The inner product is positive (semi)definite. ",{"type":"∀ {𝕜 : Type u_4} {F : Type u_5} [inst : IsROrC 𝕜] [inst_1 : AddCommGroup F] [inst_2 : Module 𝕜 F]\n  (self : InnerProductSpace.Core 𝕜 F) (x : F), 0 ≤ IsROrC.re ⟪x, x⟫_𝕜","name":"InnerProductSpace.Core.nonneg_re","isProp":true,"docString":"The inner product is positive (semi)definite. ","distance":0.34086739142474964392448555372538976371288299560546875}],["Taking duals distributes over products. ",{"type":"(R : Type uR) →\n  (M : Type uM) →\n    [inst : CommSemiring R] →\n      [inst_1 : AddCommMonoid M] →\n        [inst_2 : Module R M] →\n          (M' : Type uM') →\n            [inst_3 : AddCommMonoid M'] →\n              [inst_4 : Module R M'] → (Module.Dual R M × Module.Dual R M') ≃ₗ[R] Module.Dual R (M × M')","name":"Module.dualProdDualEquivDual","isProp":false,"docString":"Taking duals distributes over products. ","distance":0.342404801882574105764689420539070852100849151611328125}]]