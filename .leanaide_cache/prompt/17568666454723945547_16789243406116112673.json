[["Open-open circular interval ",{"type":"{Œ± : Type u_1} ‚Üí [inst : CircularPreorder Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Set Œ±","name":"Set.cIoo","isProp":false,"docString":"Open-open circular interval ","distance":0.2975050729577042307738565796171315014362335205078125}],[" The projection map of an open subtype is open.",{"type":"‚àÄ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, IsOpen s ‚Üí IsOpenMap Subtype.val","name":"IsOpen.isOpenMap_subtype_val","isProp":true,"docString":" The projection map of an open subtype is open.","distance":0.426996774030972525704186182338162325322628021240234375}],["This theorem states that a set `s` is open if and only if for every point `x` in `s` and every point `y` that is close to `x`, `y` is also in `s`. Here, `X` is a type equipped with a topological space structure and `nhds x` represents the neighborhood filter of `x`. In terms of topology, this theorem captures the intuitive idea of open sets: if a point is in an open set, then all points sufficiently close to it are also in the set. This is essentially a precise formulation of the \"without boundary\" property of open sets.",{"type":"‚àÄ {X : Type u} {s : Set X} [inst : TopologicalSpace X], IsOpen s ‚Üî ‚àÄ x ‚àà s, ‚àÄ·∂† (y : X) in nhds x, y ‚àà s","name":"isOpen_iff_eventually","isProp":true,"docString":"This theorem states that a set `s` is open if and only if for every point `x` in `s` and every point `y` that is close to `x`, `y` is also in `s`. Here, `X` is a type equipped with a topological space structure and `nhds x` represents the neighborhood filter of `x`. In terms of topology, this theorem captures the intuitive idea of open sets: if a point is in an open set, then all points sufficiently close to it are also in the set. This is essentially a precise formulation of the \"without boundary\" property of open sets.","distance":0.4319338654182864889463644431089051067829132080078125}],["Left-open right-open interval ",{"type":"{Œ± : Type u_1} ‚Üí [inst : Preorder Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Set Œ±","name":"Set.Ioo","isProp":false,"docString":"Left-open right-open interval ","distance":0.323483628191053862455106582274311222136020660400390625}],[" A product set in a product space is open if and only if both factors are open or one of them is empty.",{"type":"‚àÄ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {s : Set X} {t : Set Y},\n  IsOpen (s √óÀ¢ t) ‚Üî IsOpen s ‚àß IsOpen t ‚à® s = ‚àÖ ‚à® t = ‚àÖ","name":"isOpen_prod_iff'","isProp":true,"docString":" A product set in a product space is open if and only if both factors are open or one of them is empty.","distance":0.4376092988323623256263772418606095016002655029296875}],["This theorem in Lean 4 states that for any topological space `Œ±`, any set `U` within `Œ±`, and given that `U` is an open set, the coercion of the structured type `Opens Œ±` (which includes `U` and the fact that `U` is open) to the type `Set Œ±` is equivalent to `U` itself. In other words, when we have a structured type with a set and its property of being open, coercing it to its base set doesn't change the set: it still refers to the same collection of elements. This theorem is related to the concept of type coercion in Lean 4.",{"type":"‚àÄ {Œ± : Type u_2} [inst : TopologicalSpace Œ±] {U : Set Œ±} {hU : IsOpen U}, ‚Üë{ carrier := U, is_open' := hU } = U","name":"TopologicalSpace.Opens.coe_mk","isProp":true,"docString":"This theorem in Lean 4 states that for any topological space `Œ±`, any set `U` within `Œ±`, and given that `U` is an open set, the coercion of the structured type `Opens Œ±` (which includes `U` and the fact that `U` is open) to the type `Set Œ±` is equivalent to `U` itself. In other words, when we have a structured type with a set and its property of being open, coercing it to its base set doesn't change the set: it still refers to the same collection of elements. This theorem is related to the concept of type coercion in Lean 4.","distance":0.434338574158638135447318973092478699982166290283203125}],["Reinterpret a compact open as an open. ",{"type":"{Œ± : Type u_1} ‚Üí [inst : TopologicalSpace Œ±] ‚Üí TopologicalSpace.CompactOpens Œ± ‚Üí TopologicalSpace.Opens Œ±","name":"TopologicalSpace.CompactOpens.toOpens","isProp":false,"docString":"Reinterpret a compact open as an open. ","distance":0.33471231333121631568161546965711750090122222900390625}],["Each set from the partially refined family is open. ",{"type":"‚àÄ {Œπ : Type u_1} {X : Type u_2} [inst : TopologicalSpace X] {u : Œπ ‚Üí Set X} {s : Set X}\n  (self : ShrinkingLemma.PartialRefinement u s) (i : Œπ), IsOpen (ShrinkingLemma.PartialRefinement.toFun self i)","name":"ShrinkingLemma.PartialRefinement.isOpen","isProp":true,"docString":"Each set from the partially refined family is open. ","distance":0.33790424183295664217752118929638527333736419677734375}],["Reinterpret a clopen as an open. ",{"type":"{Œ± : Type u_2} ‚Üí [inst : TopologicalSpace Œ±] ‚Üí TopologicalSpace.Clopens Œ± ‚Üí TopologicalSpace.Opens Œ±","name":"TopologicalSpace.Clopens.toOpens","isProp":false,"docString":"Reinterpret a clopen as an open. ","distance":0.339191009516739916396232956685707904398441314697265625}],["The (open) thickening is an open set. ",{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {Œ¥ : ‚Ñù} {E : Set Œ±}, IsOpen (Metric.thickening Œ¥ E)","name":"Metric.isOpen_thickening","isProp":true,"docString":"The (open) thickening is an open set. ","distance":0.340451191410584386165538717250456102192401885986328125}],["The closure of every open set is open. ",{"type":"‚àÄ {X : Type u} [inst : TopologicalSpace X] [self : ExtremallyDisconnected X] (U : Set X), IsOpen U ‚Üí IsOpen (closure U)","name":"ExtremallyDisconnected.open_closure","isProp":true,"docString":"The closure of every open set is open. ","distance":0.34861421972914408140553632620139978826045989990234375}],["The image of a compact open under a continuous open map. ",{"type":"{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    [inst : TopologicalSpace Œ±] ‚Üí\n      [inst_1 : TopologicalSpace Œ≤] ‚Üí\n        (f : Œ± ‚Üí Œ≤) ‚Üí Continuous f ‚Üí IsOpenMap f ‚Üí TopologicalSpace.CompactOpens Œ± ‚Üí TopologicalSpace.CompactOpens Œ≤","name":"TopologicalSpace.CompactOpens.map","isProp":false,"docString":"The image of a compact open under a continuous open map. ","distance":0.35122362229964199098475319260614924132823944091796875}],["Left-open right-closed interval ",{"type":"{Œ± : Type u_1} ‚Üí [inst : Preorder Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Set Œ±","name":"Set.Ioc","isProp":false,"docString":"Left-open right-closed interval ","distance":0.354766583947001501453399896490736864507198333740234375}],["The open upper half plane ",{"type":"Lean.ParserDescr","name":"UpperHalfPlane.term‚Ñç","isProp":false,"docString":"The open upper half plane ","distance":0.3554900649404526546959459665231406688690185546875}],["The image of an open immersion as an open set. ",{"type":"{X Y : AlgebraicGeometry.Scheme} ‚Üí\n  (f : X ‚ü∂ Y) ‚Üí [H : AlgebraicGeometry.IsOpenImmersion f] ‚Üí TopologicalSpace.Opens ‚Üë‚ÜëY.toPresheafedSpace","name":"AlgebraicGeometry.Scheme.Hom.opensRange","isProp":false,"docString":"The image of an open immersion as an open set. ","distance":0.355667043201582322442533268258557654917240142822265625}],["The sheaf hom on all basic opens, commuting with restrictions. ",{"type":"(X : AlgebraicGeometry.LocallyRingedSpace) ‚Üí\n  CategoryTheory.Functor.comp (CategoryTheory.inducedFunctor PrimeSpectrum.basicOpen).op\n      (AlgebraicGeometry.Spec.structureSheaf ‚Üë(AlgebraicGeometry.LocallyRingedSpace.Œì.obj (Opposite.op X))).val ‚ü∂\n    CategoryTheory.Functor.comp (CategoryTheory.inducedFunctor PrimeSpectrum.basicOpen).op\n      ((TopCat.Sheaf.pushforward CommRingCat (AlgebraicGeometry.LocallyRingedSpace.toŒìSpecBase X)).obj\n          (AlgebraicGeometry.LocallyRingedSpace.ùí™ X)).val","name":"AlgebraicGeometry.LocallyRingedSpace.toŒìSpecCBasicOpens","isProp":false,"docString":"The sheaf hom on all basic opens, commuting with restrictions. ","distance":0.355884392718916864328804194883559830486774444580078125}],["the subschemes of an open cover ",{"type":"{X : AlgebraicGeometry.Scheme} ‚Üí (self : AlgebraicGeometry.Scheme.OpenCover X) ‚Üí self.J ‚Üí AlgebraicGeometry.Scheme","name":"AlgebraicGeometry.Scheme.OpenCover.obj","isProp":false,"docString":"the subschemes of an open cover ","distance":0.3588616401640665198868873630999587476253509521484375}],["The open-closed uIcc with unordered bounds. ",{"type":"{Œ± : Type u_1} ‚Üí [inst : LinearOrder Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Set Œ±","name":"Set.uIoc","isProp":false,"docString":"The open-closed uIcc with unordered bounds. ","distance":0.362527166349765062047794117461307905614376068115234375}],["Left-closed right-open interval ",{"type":"{Œ± : Type u_1} ‚Üí [inst : Preorder Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Set Œ±","name":"Set.Ico","isProp":false,"docString":"Left-closed right-open interval ","distance":0.367074355331258928014648290627519600093364715576171875}],["Adding an open immersion into an open cover gives another open cover. ",{"type":"{X : AlgebraicGeometry.Scheme} ‚Üí\n  AlgebraicGeometry.Scheme.OpenCover X ‚Üí\n    {Y : AlgebraicGeometry.Scheme} ‚Üí\n      (f : Y ‚ü∂ X) ‚Üí [inst : AlgebraicGeometry.IsOpenImmersion f] ‚Üí AlgebraicGeometry.Scheme.OpenCover X","name":"AlgebraicGeometry.Scheme.OpenCover.add","isProp":false,"docString":"Adding an open immersion into an open cover gives another open cover. ","distance":0.368813800455282281287594514651573263108730316162109375}],["A set is clopen if it is both closed and open. ",{"type":"{X : Type u} ‚Üí [inst : TopologicalSpace X] ‚Üí Set X ‚Üí Prop","name":"IsClopen","isProp":false,"docString":"A set is clopen if it is both closed and open. ","distance":0.36986548165059740522764286652090959250926971435546875}],["The ideal is downward closed. ",{"type":"‚àÄ {P : Type u_2} [inst : LE P] {I : Set P}, Order.IsIdeal I ‚Üí IsLowerSet I","name":"Order.IsIdeal.IsLowerSet","isProp":true,"docString":"The ideal is downward closed. ","distance":0.37030832631272569965830143701168708503246307373046875}],["An inducing map with an open range is an open map. ",{"type":"‚àÄ {X : Type u_1} {Y : Type u_2} {f : X ‚Üí Y} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y],\n  Inducing f ‚Üí IsOpen (Set.range f) ‚Üí IsOpenMap f","name":"Inducing.isOpenMap","isProp":true,"docString":"An inducing map with an open range is an open map. ","distance":0.37196150441824882282304542968631722033023834228515625}],["Two different points can be separated by open sets. ",{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] {x y : X},\n  x ‚â† y ‚Üí ‚àÉ u v, IsOpen u ‚àß IsOpen v ‚àß x ‚àà u ‚àß y ‚àà v ‚àß Disjoint u v","name":"t2_separation","isProp":true,"docString":"Two different points can be separated by open sets. ","distance":0.373052273980582438372977094331872649490833282470703125}]]