[["The b's are less than 1 ",{"type":"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] {T : â„• â†’ â„} {g : â„ â†’ â„} {a b : Î± â†’ â„} {r : Î± â†’ â„• â†’ â„•},\n  AkraBazziRecurrence T g a b r â†’ âˆ€ (i : Î±), b i < 1","name":"AkraBazziRecurrence.b_lt_one","isProp":true,"docString":"The b's are less than 1 ","distance":0.353537325135550528631966926695895381271839141845703125}],[" In a T2 topological space and measurable space, two disjoint analytic sets can be separated by disjoint Borel sets.",{"type":"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] [inst_1 : T2Space Î±] [inst_2 : MeasurableSpace Î±]\n  [inst_3 : OpensMeasurableSpace Î±] {s t : Set Î±},\n  MeasureTheory.AnalyticSet s â†’ MeasureTheory.AnalyticSet t â†’ Disjoint s t â†’ MeasureTheory.MeasurablySeparable s t","name":"MeasureTheory.AnalyticSet.measurablySeparable","isProp":true,"docString":" In a T2 topological space and measurable space, two disjoint analytic sets can be separated by disjoint Borel sets.","distance":0.460060932684891066291044126046472229063510894775390625}],["**The SchrÃ¶der-Bernstein Theorem**: This theorem states that for any two types `Î±` and `Î²`, if there are embeddings from `Î±` to `Î²` and vice versa, there must exist an equivalence (bijection) between `Î±` and `Î²`. In other words, if `Î±` and `Î²` can be embedded into each other, they have the same cardinality.",{"type":"âˆ€ {Î± : Type u} {Î² : Type v}, (Î± â†ª Î²) â†’ (Î² â†ª Î±) â†’ Nonempty (Î± â‰ƒ Î²)","name":"Function.Embedding.antisymm","isProp":true,"docString":"**The SchrÃ¶der-Bernstein Theorem**: This theorem states that for any two types `Î±` and `Î²`, if there are embeddings from `Î±` to `Î²` and vice versa, there must exist an equivalence (bijection) between `Î±` and `Î²`. In other words, if `Î±` and `Î²` can be embedded into each other, they have the same cardinality.","distance":0.470991586422181696125477401437819935381412506103515625}],["The tails are equal ",{"type":"âˆ€ {F : PFunctor.{u}} {R : PFunctor.M F â†’ PFunctor.M F â†’ Prop},\n  PFunctor.M.IsBisimulation R â†’\n    âˆ€ {a : F.A} {f f' : PFunctor.B F a â†’ PFunctor.M F},\n      R (PFunctor.M.mk { fst := a, snd := f }) (PFunctor.M.mk { fst := a, snd := f' }) â†’\n        âˆ€ (i : PFunctor.B F a), R (f i) (f' i)","name":"PFunctor.M.IsBisimulation.tail","isProp":true,"docString":"The tails are equal ","distance":0.406399903198285061822758734706440009176731109619140625}],[" In a T2.5 space, every perfect and non-empty set contains two disjoint perfect subsets.",{"type":"âˆ€ {Î± : Type u_1} [inst : TopologicalSpace Î±] {C : Set Î±} [inst_1 : T25Space Î±],\n  Perfect C â†’\n    C.Nonempty â†’ âˆƒ Câ‚€ Câ‚, (Perfect Câ‚€ âˆ§ Câ‚€.Nonempty âˆ§ Câ‚€ âŠ† C) âˆ§ (Perfect Câ‚ âˆ§ Câ‚.Nonempty âˆ§ Câ‚ âŠ† C) âˆ§ Disjoint Câ‚€ Câ‚","name":"Perfect.splitting","isProp":true,"docString":" In a T2.5 space, every perfect and non-empty set contains two disjoint perfect subsets.","distance":0.462191737489905773994536275495192967355251312255859375}],["The theorem states that for an irrational number `r`, the sets of elements generated by two different variations of the Beatty sequence, `Bâº_r` and `Bâº'_r`, are the same. Specifically, the set of integers that can be obtained by taking any positive integer `k` and evaluating `Bâº'_r` at `k` (i.e., `âŒˆk * râŒ‰ - 1`) is equal to the set of integers that can be obtained by evaluating `Bâº_r` at `k` (i.e., `âŒŠk * râŒ‹`).",{"type":"âˆ€ {r : â„}, Irrational r â†’ {x | âˆƒ k > 0, beattySeq' r k = x} = {x | âˆƒ k > 0, beattySeq r k = x}","name":"Irrational.beattySeq'_pos_eq","isProp":true,"docString":"The theorem states that for an irrational number `r`, the sets of elements generated by two different variations of the Beatty sequence, `Bâº_r` and `Bâº'_r`, are the same. Specifically, the set of integers that can be obtained by taking any positive integer `k` and evaluating `Bâº'_r` at `k` (i.e., `âŒˆk * râŒ‰ - 1`) is equal to the set of integers that can be obtained by evaluating `Bâº_r` at `k` (i.e., `âŒŠk * râŒ‹`).","distance":0.473156673388877735408897251545567996799945831298828125}],["The `b`'s are nonzero ",{"type":"âˆ€ {Î± : Type u_1} [inst : Fintype Î±] {T : â„• â†’ â„} {g : â„ â†’ â„} {a b : Î± â†’ â„} {r : Î± â†’ â„• â†’ â„•},\n  AkraBazziRecurrence T g a b r â†’ âˆ€ (i : Î±), 0 < b i","name":"AkraBazziRecurrence.b_pos","isProp":true,"docString":"The `b`'s are nonzero ","distance":0.40692059305835581728416627811384387314319610595703125}],["The thin skeleton is thin. ",{"type":"âˆ€ (C : Type uâ‚) [inst : CategoryTheory.Category.{vâ‚, uâ‚} C], Quiver.IsThin (CategoryTheory.ThinSkeleton C)","name":"CategoryTheory.ThinSkeleton.thin","isProp":true,"docString":"The thin skeleton is thin. ","distance":0.408086591987540658887922973008244298398494720458984375}],["There is a splitting ",{"type":"âˆ€ {C : Type uâ‚} [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] {X Y : C} {f : X âŸ¶ Y} [self : CategoryTheory.IsSplitEpi f],\n  Nonempty (CategoryTheory.SplitEpi f)","name":"CategoryTheory.IsSplitEpi.exists_splitEpi","isProp":true,"docString":"There is a splitting ","distance":0.413098280261728845186297576219658367335796356201171875}],["`teichmuller` is a natural transformation. ",{"type":"âˆ€ (p : â„•) {R : Type u_1} {S : Type u_2} [hp : Fact (Nat.Prime p)] [inst : CommRing R] [inst_1 : CommRing S]\n  (f : R â†’+* S) (r : R), (WittVector.map f) ((WittVector.teichmuller p) r) = (WittVector.teichmuller p) (f r)","name":"WittVector.map_teichmuller","isProp":true,"docString":"`teichmuller` is a natural transformation. ","distance":0.4155174303026836213348360615782439708709716796875}],["tensorator ",{"type":"{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    [inst_1 : CategoryTheory.MonoidalCategory C] â†’\n      {D : Type uâ‚‚} â†’\n        [inst_2 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] â†’\n          [inst_3 : CategoryTheory.MonoidalCategory D] â†’\n            {F : C â†’ D} â†’\n              [inst_4 : CategoryTheory.Functorial F] â†’\n                [self : CategoryTheory.LaxMonoidal F] â†’\n                  (X Y : C) â†’\n                    CategoryTheory.MonoidalCategory.tensorObj (F X) (F Y) âŸ¶\n                      F (CategoryTheory.MonoidalCategory.tensorObj X Y)","name":"CategoryTheory.LaxMonoidal.Î¼","isProp":false,"docString":"tensorator ","distance":0.416962818834841486559383838539361022412776947021484375}],["The braiding is symmetric. ",{"type":"âˆ€ (R : Type u_1) {Î¹ : Type u_2} [inst : CommSemiring Î¹] [inst_1 : Module Î¹ (Additive â„¤Ë£)] [inst_2 : DecidableEq Î¹]\n  (ğ’œ : Î¹ â†’ Type u_5) (â„¬ : Î¹ â†’ Type u_6) [inst_3 : CommRing R] [inst_4 : (i : Î¹) â†’ AddCommGroup (ğ’œ i)]\n  [inst_5 : (i : Î¹) â†’ AddCommGroup (â„¬ i)] [inst_6 : (i : Î¹) â†’ Module R (ğ’œ i)] [inst_7 : (i : Î¹) â†’ Module R (â„¬ i)],\n  LinearEquiv.symm (TensorProduct.gradedComm R ğ’œ â„¬) = TensorProduct.gradedComm R â„¬ ğ’œ","name":"TensorProduct.gradedComm_symm","isProp":true,"docString":"The braiding is symmetric. ","distance":0.41782255957984382188641347966040484607219696044921875}],["The head of the trees are equal ",{"type":"âˆ€ {F : PFunctor.{u}} {R : PFunctor.M F â†’ PFunctor.M F â†’ Prop},\n  PFunctor.M.IsBisimulation R â†’\n    âˆ€ {a a' : F.A} {f : PFunctor.B F a â†’ PFunctor.M F} {f' : PFunctor.B F a' â†’ PFunctor.M F},\n      R (PFunctor.M.mk { fst := a, snd := f }) (PFunctor.M.mk { fst := a', snd := f' }) â†’ a = a'","name":"PFunctor.M.IsBisimulation.head","isProp":true,"docString":"The head of the trees are equal ","distance":0.419285245413765272903816594407544471323490142822265625}],["The Gram operator Tâ€ T is symmetric. ",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  [inst_3 : FiniteDimensional ğ•œ E] (T : E â†’â‚—[ğ•œ] E), LinearMap.IsSymmetric (LinearMap.adjoint T * T)","name":"LinearMap.isSymmetric_adjoint_mul_self","isProp":true,"docString":"The Gram operator Tâ€ T is symmetric. ","distance":0.419716107782922287494642432648106478154659271240234375}],["Stonean spaces are compact. ",{"type":"âˆ€ (X : Stonean), CompactSpace (CoeSort.coe X)","name":"Stonean.instCompactSpaceCoeStoneanTypeInstCoeSortStoneanTypeInstTopologicalSpace","isProp":true,"docString":"Stonean spaces are compact. ","distance":0.419836237394824396407244648798950947821140289306640625}],["The empty set is meagre. ",{"type":"âˆ€ {X : Type u_5} [inst : TopologicalSpace X], IsMeagre âˆ…","name":"meagre_empty","isProp":true,"docString":"The empty set is meagre. ","distance":0.421577988487494115243947589988238178193569183349609375}],["A terminal object is terminal. ",{"type":"{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] â†’ CategoryTheory.Limits.IsTerminal (âŠ¤_ C)","name":"CategoryTheory.Limits.terminalIsTerminal","isProp":false,"docString":"A terminal object is terminal. ","distance":0.423084665742871235405431207254878245294094085693359375}],["The tensorator as a natural isomorphism. ",{"type":"{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    [inst_1 : CategoryTheory.MonoidalCategory C] â†’\n      {D : Type uâ‚‚} â†’\n        [inst_2 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] â†’\n          [inst_3 : CategoryTheory.MonoidalCategory D] â†’\n            (F : CategoryTheory.MonoidalFunctor C D) â†’\n              CategoryTheory.Functor.comp (CategoryTheory.Functor.prod F.toFunctor F.toFunctor)\n                  (CategoryTheory.MonoidalCategory.tensor D) â‰…\n                CategoryTheory.Functor.comp (CategoryTheory.MonoidalCategory.tensor C) F.toFunctor","name":"CategoryTheory.MonoidalFunctor.Î¼NatIso","isProp":false,"docString":"The tensorator as a natural isomorphism. ","distance":0.42599968764776807716998519026674330234527587890625}],["The second inclusion of a binary cofan. ",{"type":"{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    {X Y : C} â†’\n      (s : CategoryTheory.Limits.BinaryCofan X Y) â†’\n        (CategoryTheory.Limits.pair X Y).obj { as := CategoryTheory.Limits.WalkingPair.right } âŸ¶\n          ((CategoryTheory.Functor.const (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair)).obj s.pt).obj\n            { as := CategoryTheory.Limits.WalkingPair.right }","name":"CategoryTheory.Limits.BinaryCofan.inr","isProp":false,"docString":"The second inclusion of a binary cofan. ","distance":0.426352480832821900680329463284579105675220489501953125}],["Bessel's inequality. ",{"type":"âˆ€ {ğ•œ : Type u_1} {E : Type u_2} [inst : IsROrC ğ•œ] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ğ•œ E]\n  {Î¹ : Type u_4} (x : E) {v : Î¹ â†’ E}, Orthonormal ğ•œ v â†’ âˆ‘' (i : Î¹), â€–âŸªv i, xâŸ«_ğ•œâ€– ^ 2 â‰¤ â€–xâ€– ^ 2","name":"Orthonormal.tsum_inner_products_le","isProp":true,"docString":"Bessel's inequality. ","distance":0.426921147416422008813441379970754496753215789794921875}],["The empty finset ",{"type":"{Î± : Type u_1} â†’ Finset Î±","name":"Finset.empty","isProp":false,"docString":"The empty finset ","distance":0.427247072959108076251055763350450433790683746337890625}],["Uniformizers are nonzero. ",{"type":"âˆ€ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] (K : Type u_2)\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K] (v : IsDedekindDomain.HeightOneSpectrum R),\n  Classical.choose (_ : âˆƒ Ï€, (IsDedekindDomain.HeightOneSpectrum.valuation v) Ï€ = â†‘(Multiplicative.ofAdd (-1))) â‰  0","name":"IsDedekindDomain.HeightOneSpectrum.valuation_uniformizer_ne_zero","isProp":true,"docString":"Uniformizers are nonzero. ","distance":0.427321293348644160037252959227771498262882232666015625}],["The Beck cofork is a coequalizer. ",{"type":"{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    {T : CategoryTheory.Monad C} â†’\n      (X : CategoryTheory.Monad.Algebra T) â†’ CategoryTheory.Limits.IsColimit (CategoryTheory.Monad.beckCofork X)","name":"CategoryTheory.Monad.beckCoequalizer","isProp":false,"docString":"The Beck cofork is a coequalizer. ","distance":0.427415664930539396237918481347151100635528564453125}],["Any type is equivalent to itself. ",{"type":"(Î± : Sort u_1) â†’ Î± â‰ƒ Î±","name":"Equiv.refl","isProp":false,"docString":"Any type is equivalent to itself. ","distance":0.4285443554318015824122767298831604421138763427734375}]]