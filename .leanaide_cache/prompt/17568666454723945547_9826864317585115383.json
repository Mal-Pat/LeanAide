[["The b's are less than 1 ",{"type":"∀ {α : Type u_1} [inst : Fintype α] {T : ℕ → ℝ} {g : ℝ → ℝ} {a b : α → ℝ} {r : α → ℕ → ℕ},\n  AkraBazziRecurrence T g a b r → ∀ (i : α), b i < 1","name":"AkraBazziRecurrence.b_lt_one","isProp":true,"docString":"The b's are less than 1 ","distance":0.353537325135550528631966926695895381271839141845703125}],[" In a T2 topological space and measurable space, two disjoint analytic sets can be separated by disjoint Borel sets.",{"type":"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : MeasurableSpace α]\n  [inst_3 : OpensMeasurableSpace α] {s t : Set α},\n  MeasureTheory.AnalyticSet s → MeasureTheory.AnalyticSet t → Disjoint s t → MeasureTheory.MeasurablySeparable s t","name":"MeasureTheory.AnalyticSet.measurablySeparable","isProp":true,"docString":" In a T2 topological space and measurable space, two disjoint analytic sets can be separated by disjoint Borel sets.","distance":0.460060932684891066291044126046472229063510894775390625}],["**The Schröder-Bernstein Theorem**: This theorem states that for any two types `α` and `β`, if there are embeddings from `α` to `β` and vice versa, there must exist an equivalence (bijection) between `α` and `β`. In other words, if `α` and `β` can be embedded into each other, they have the same cardinality.",{"type":"∀ {α : Type u} {β : Type v}, (α ↪ β) → (β ↪ α) → Nonempty (α ≃ β)","name":"Function.Embedding.antisymm","isProp":true,"docString":"**The Schröder-Bernstein Theorem**: This theorem states that for any two types `α` and `β`, if there are embeddings from `α` to `β` and vice versa, there must exist an equivalence (bijection) between `α` and `β`. In other words, if `α` and `β` can be embedded into each other, they have the same cardinality.","distance":0.470991586422181696125477401437819935381412506103515625}],["The tails are equal ",{"type":"∀ {F : PFunctor.{u}} {R : PFunctor.M F → PFunctor.M F → Prop},\n  PFunctor.M.IsBisimulation R →\n    ∀ {a : F.A} {f f' : PFunctor.B F a → PFunctor.M F},\n      R (PFunctor.M.mk { fst := a, snd := f }) (PFunctor.M.mk { fst := a, snd := f' }) →\n        ∀ (i : PFunctor.B F a), R (f i) (f' i)","name":"PFunctor.M.IsBisimulation.tail","isProp":true,"docString":"The tails are equal ","distance":0.406399903198285061822758734706440009176731109619140625}],[" In a T2.5 space, every perfect and non-empty set contains two disjoint perfect subsets.",{"type":"∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : T25Space α],\n  Perfect C →\n    C.Nonempty → ∃ C₀ C₁, (Perfect C₀ ∧ C₀.Nonempty ∧ C₀ ⊆ C) ∧ (Perfect C₁ ∧ C₁.Nonempty ∧ C₁ ⊆ C) ∧ Disjoint C₀ C₁","name":"Perfect.splitting","isProp":true,"docString":" In a T2.5 space, every perfect and non-empty set contains two disjoint perfect subsets.","distance":0.462191737489905773994536275495192967355251312255859375}],["The theorem states that for an irrational number `r`, the sets of elements generated by two different variations of the Beatty sequence, `B⁺_r` and `B⁺'_r`, are the same. Specifically, the set of integers that can be obtained by taking any positive integer `k` and evaluating `B⁺'_r` at `k` (i.e., `⌈k * r⌉ - 1`) is equal to the set of integers that can be obtained by evaluating `B⁺_r` at `k` (i.e., `⌊k * r⌋`).",{"type":"∀ {r : ℝ}, Irrational r → {x | ∃ k > 0, beattySeq' r k = x} = {x | ∃ k > 0, beattySeq r k = x}","name":"Irrational.beattySeq'_pos_eq","isProp":true,"docString":"The theorem states that for an irrational number `r`, the sets of elements generated by two different variations of the Beatty sequence, `B⁺_r` and `B⁺'_r`, are the same. Specifically, the set of integers that can be obtained by taking any positive integer `k` and evaluating `B⁺'_r` at `k` (i.e., `⌈k * r⌉ - 1`) is equal to the set of integers that can be obtained by evaluating `B⁺_r` at `k` (i.e., `⌊k * r⌋`).","distance":0.473156673388877735408897251545567996799945831298828125}],["The `b`'s are nonzero ",{"type":"∀ {α : Type u_1} [inst : Fintype α] {T : ℕ → ℝ} {g : ℝ → ℝ} {a b : α → ℝ} {r : α → ℕ → ℕ},\n  AkraBazziRecurrence T g a b r → ∀ (i : α), 0 < b i","name":"AkraBazziRecurrence.b_pos","isProp":true,"docString":"The `b`'s are nonzero ","distance":0.40692059305835581728416627811384387314319610595703125}],["The thin skeleton is thin. ",{"type":"∀ (C : Type u₁) [inst : CategoryTheory.Category.{v₁, u₁} C], Quiver.IsThin (CategoryTheory.ThinSkeleton C)","name":"CategoryTheory.ThinSkeleton.thin","isProp":true,"docString":"The thin skeleton is thin. ","distance":0.408086591987540658887922973008244298398494720458984375}],["There is a splitting ",{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X Y : C} {f : X ⟶ Y} [self : CategoryTheory.IsSplitEpi f],\n  Nonempty (CategoryTheory.SplitEpi f)","name":"CategoryTheory.IsSplitEpi.exists_splitEpi","isProp":true,"docString":"There is a splitting ","distance":0.413098280261728845186297576219658367335796356201171875}],["`teichmuller` is a natural transformation. ",{"type":"∀ (p : ℕ) {R : Type u_1} {S : Type u_2} [hp : Fact (Nat.Prime p)] [inst : CommRing R] [inst_1 : CommRing S]\n  (f : R →+* S) (r : R), (WittVector.map f) ((WittVector.teichmuller p) r) = (WittVector.teichmuller p) (f r)","name":"WittVector.map_teichmuller","isProp":true,"docString":"`teichmuller` is a natural transformation. ","distance":0.4155174303026836213348360615782439708709716796875}],["tensorator ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.MonoidalCategory C] →\n      {D : Type u₂} →\n        [inst_2 : CategoryTheory.Category.{v₂, u₂} D] →\n          [inst_3 : CategoryTheory.MonoidalCategory D] →\n            {F : C → D} →\n              [inst_4 : CategoryTheory.Functorial F] →\n                [self : CategoryTheory.LaxMonoidal F] →\n                  (X Y : C) →\n                    CategoryTheory.MonoidalCategory.tensorObj (F X) (F Y) ⟶\n                      F (CategoryTheory.MonoidalCategory.tensorObj X Y)","name":"CategoryTheory.LaxMonoidal.μ","isProp":false,"docString":"tensorator ","distance":0.416962818834841486559383838539361022412776947021484375}],["The braiding is symmetric. ",{"type":"∀ (R : Type u_1) {ι : Type u_2} [inst : CommSemiring ι] [inst_1 : Module ι (Additive ℤˣ)] [inst_2 : DecidableEq ι]\n  (𝒜 : ι → Type u_5) (ℬ : ι → Type u_6) [inst_3 : CommRing R] [inst_4 : (i : ι) → AddCommGroup (𝒜 i)]\n  [inst_5 : (i : ι) → AddCommGroup (ℬ i)] [inst_6 : (i : ι) → Module R (𝒜 i)] [inst_7 : (i : ι) → Module R (ℬ i)],\n  LinearEquiv.symm (TensorProduct.gradedComm R 𝒜 ℬ) = TensorProduct.gradedComm R ℬ 𝒜","name":"TensorProduct.gradedComm_symm","isProp":true,"docString":"The braiding is symmetric. ","distance":0.41782255957984382188641347966040484607219696044921875}],["The head of the trees are equal ",{"type":"∀ {F : PFunctor.{u}} {R : PFunctor.M F → PFunctor.M F → Prop},\n  PFunctor.M.IsBisimulation R →\n    ∀ {a a' : F.A} {f : PFunctor.B F a → PFunctor.M F} {f' : PFunctor.B F a' → PFunctor.M F},\n      R (PFunctor.M.mk { fst := a, snd := f }) (PFunctor.M.mk { fst := a', snd := f' }) → a = a'","name":"PFunctor.M.IsBisimulation.head","isProp":true,"docString":"The head of the trees are equal ","distance":0.419285245413765272903816594407544471323490142822265625}],["The Gram operator T†T is symmetric. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : FiniteDimensional 𝕜 E] (T : E →ₗ[𝕜] E), LinearMap.IsSymmetric (LinearMap.adjoint T * T)","name":"LinearMap.isSymmetric_adjoint_mul_self","isProp":true,"docString":"The Gram operator T†T is symmetric. ","distance":0.419716107782922287494642432648106478154659271240234375}],["Stonean spaces are compact. ",{"type":"∀ (X : Stonean), CompactSpace (CoeSort.coe X)","name":"Stonean.instCompactSpaceCoeStoneanTypeInstCoeSortStoneanTypeInstTopologicalSpace","isProp":true,"docString":"Stonean spaces are compact. ","distance":0.419836237394824396407244648798950947821140289306640625}],["The empty set is meagre. ",{"type":"∀ {X : Type u_5} [inst : TopologicalSpace X], IsMeagre ∅","name":"meagre_empty","isProp":true,"docString":"The empty set is meagre. ","distance":0.421577988487494115243947589988238178193569183349609375}],["A terminal object is terminal. ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] → CategoryTheory.Limits.IsTerminal (⊤_ C)","name":"CategoryTheory.Limits.terminalIsTerminal","isProp":false,"docString":"A terminal object is terminal. ","distance":0.423084665742871235405431207254878245294094085693359375}],["The tensorator as a natural isomorphism. ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.MonoidalCategory C] →\n      {D : Type u₂} →\n        [inst_2 : CategoryTheory.Category.{v₂, u₂} D] →\n          [inst_3 : CategoryTheory.MonoidalCategory D] →\n            (F : CategoryTheory.MonoidalFunctor C D) →\n              CategoryTheory.Functor.comp (CategoryTheory.Functor.prod F.toFunctor F.toFunctor)\n                  (CategoryTheory.MonoidalCategory.tensor D) ≅\n                CategoryTheory.Functor.comp (CategoryTheory.MonoidalCategory.tensor C) F.toFunctor","name":"CategoryTheory.MonoidalFunctor.μNatIso","isProp":false,"docString":"The tensorator as a natural isomorphism. ","distance":0.42599968764776807716998519026674330234527587890625}],["The second inclusion of a binary cofan. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {X Y : C} →\n      (s : CategoryTheory.Limits.BinaryCofan X Y) →\n        (CategoryTheory.Limits.pair X Y).obj { as := CategoryTheory.Limits.WalkingPair.right } ⟶\n          ((CategoryTheory.Functor.const (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair)).obj s.pt).obj\n            { as := CategoryTheory.Limits.WalkingPair.right }","name":"CategoryTheory.Limits.BinaryCofan.inr","isProp":false,"docString":"The second inclusion of a binary cofan. ","distance":0.426352480832821900680329463284579105675220489501953125}],["Bessel's inequality. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_4} (x : E) {v : ι → E}, Orthonormal 𝕜 v → ∑' (i : ι), ‖⟪v i, x⟫_𝕜‖ ^ 2 ≤ ‖x‖ ^ 2","name":"Orthonormal.tsum_inner_products_le","isProp":true,"docString":"Bessel's inequality. ","distance":0.426921147416422008813441379970754496753215789794921875}],["The empty finset ",{"type":"{α : Type u_1} → Finset α","name":"Finset.empty","isProp":false,"docString":"The empty finset ","distance":0.427247072959108076251055763350450433790683746337890625}],["Uniformizers are nonzero. ",{"type":"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] (K : Type u_2)\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K] (v : IsDedekindDomain.HeightOneSpectrum R),\n  Classical.choose (_ : ∃ π, (IsDedekindDomain.HeightOneSpectrum.valuation v) π = ↑(Multiplicative.ofAdd (-1))) ≠ 0","name":"IsDedekindDomain.HeightOneSpectrum.valuation_uniformizer_ne_zero","isProp":true,"docString":"Uniformizers are nonzero. ","distance":0.427321293348644160037252959227771498262882232666015625}],["The Beck cofork is a coequalizer. ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {T : CategoryTheory.Monad C} →\n      (X : CategoryTheory.Monad.Algebra T) → CategoryTheory.Limits.IsColimit (CategoryTheory.Monad.beckCofork X)","name":"CategoryTheory.Monad.beckCoequalizer","isProp":false,"docString":"The Beck cofork is a coequalizer. ","distance":0.427415664930539396237918481347151100635528564453125}],["Any type is equivalent to itself. ",{"type":"(α : Sort u_1) → α ≃ α","name":"Equiv.refl","isProp":false,"docString":"Any type is equivalent to itself. ","distance":0.4285443554318015824122767298831604421138763427734375}]]