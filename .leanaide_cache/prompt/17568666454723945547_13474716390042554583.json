[["constructor for `prod` ",{"type":"{n : ‚Ñï} ‚Üí {Œ± Œ≤ : TypeVec.{u} n} ‚Üí (i : Fin2 n) ‚Üí Œ± i ‚Üí Œ≤ i ‚Üí TypeVec.prod Œ± Œ≤ i","name":"TypeVec.prod.mk","isProp":false,"docString":"constructor for `prod` ","distance":0.32518916284444887576654537042486481368541717529296875}],[" For any category with binary products, the product of two objects exists.",{"type":"‚àÄ {C : Type u_2} [inst : CategoryTheory.Category.{u_1, u_2} C] [inst_1 : CategoryTheory.Limits.HasBinaryProducts C]\n  (X Y : C), CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair X Y)","name":"CategoryTheory.Limits.prod.functor.proof_1","isProp":true,"docString":" For any category with binary products, the product of two objects exists.","distance":0.4813592874230676610380896818242035806179046630859375}],["This theorem, which is a part of Profinite's NobelingProof, asserts the following: for any type `I` equipped with a linear order, a set `C` of Boolean-valued functions on `I`, a product `l` of elements from `I`, and a predicate `J` on `I`, if every element `a` in the product `l` satisfies the predicate `J`, then for any `j` in `I` that can be decided by `J`, the composition of the evaluation of `l` under the image of `Proj œÄ J` with the restriction of `Proj œÄ J` to `C`, is equal to the evaluation of `l` under `C`. \n\nIn simple terms, this theorem shows a relationship between the evaluation of a product under a set of functions and its projection restricted to a subset, assuming that all elements of the product satisfy a certain property. The mathematical operations involved are function composition and evaluation.",{"type":"‚àÄ {I : Type u} [inst : LinearOrder I] (C : Set (I ‚Üí Bool)) {l : Profinite.NobelingProof.Products I} (J : I ‚Üí Prop),\n  (‚àÄ a ‚àà ‚Üël, J a) ‚Üí\n    ‚àÄ [inst_1 : (j : I) ‚Üí Decidable (J j)],\n      ‚áë(Profinite.NobelingProof.Products.eval (Profinite.NobelingProof.œÄ C J) l) ‚àò\n          Profinite.NobelingProof.ProjRestrict C J =\n        ‚áë(Profinite.NobelingProof.Products.eval C l)","name":"Profinite.NobelingProof.Products.evalFacProp","isProp":true,"docString":"This theorem, which is a part of Profinite's NobelingProof, asserts the following: for any type `I` equipped with a linear order, a set `C` of Boolean-valued functions on `I`, a product `l` of elements from `I`, and a predicate `J` on `I`, if every element `a` in the product `l` satisfies the predicate `J`, then for any `j` in `I` that can be decided by `J`, the composition of the evaluation of `l` under the image of `Proj œÄ J` with the restriction of `Proj œÄ J` to `C`, is equal to the evaluation of `l` under `C`. \n\nIn simple terms, this theorem shows a relationship between the evaluation of a product under a set of functions and its projection restricted to a subset, assuming that all elements of the product satisfy a certain property. The mathematical operations involved are function composition and evaluation.","distance":0.4600097104619766952282589045353233814239501953125}],["Delaborator for simple product projections. ",{"type":"Lean.PrettyPrinter.Delaborator.Delab","name":"delabProdProjs","isProp":false,"docString":"Delaborator for simple product projections. ","distance":0.34519765779680799955286829572287388145923614501953125}],[" For any topological spaces X and Y, the first projection function Prod.fst from X √ó Y to X is an open map.",{"type":"‚àÄ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], IsOpenMap Prod.fst","name":"isOpenMap_fst","isProp":true,"docString":" For any topological spaces X and Y, the first projection function Prod.fst from X √ó Y to X is an open map.","distance":0.482564637832117393489994583433144725859165191650390625}],["This theorem states that for any non-trivially normed field `ùïú`, normed additively commutative groups `E` and `F`, which are both normed spaces over `ùïú`, and for any set `s` consisting of ordered pairs of elements from `E` and `F`, the second projection function `Prod.snd` is infinitely differentiable (denoted `C^‚àû` in mathematical notation) on the set `s`. In mathematical language, this means that the function which projects an ordered pair to its second component, when applied to any point in the set `s`, has all of its derivatives exist and are continuous.",{"type":"‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] {n : ‚Ñï‚àû}\n  {s : Set (E √ó F)}, ContDiffOn ùïú n Prod.snd s","name":"contDiffOn_snd","isProp":true,"docString":"This theorem states that for any non-trivially normed field `ùïú`, normed additively commutative groups `E` and `F`, which are both normed spaces over `ùïú`, and for any set `s` consisting of ordered pairs of elements from `E` and `F`, the second projection function `Prod.snd` is infinitely differentiable (denoted `C^‚àû` in mathematical notation) on the set `s`. In mathematical language, this means that the function which projects an ordered pair to its second component, when applied to any point in the set `s`, has all of its derivatives exist and are continuous.","distance":0.463739725590076312666809599249972961843013763427734375}],["Products of completions ",{"type":"{Œ± : Type u_1} ‚Üí\n  [inst : UniformSpace Œ±] ‚Üí\n    AbstractCompletion Œ± ‚Üí\n      {Œ≤ : Type u_2} ‚Üí [inst_1 : UniformSpace Œ≤] ‚Üí AbstractCompletion Œ≤ ‚Üí AbstractCompletion (Œ± √ó Œ≤)","name":"AbstractCompletion.prod","isProp":false,"docString":"Products of completions ","distance":0.3634324693368162773055018988088704645633697509765625}],["The first projection from the product. ",{"type":"{X Y : TopCat} ‚Üí TopCat.of (‚ÜëX √ó ‚ÜëY) ‚ü∂ X","name":"TopCat.prodFst","isProp":false,"docString":"The first projection from the product. ","distance":0.37558729039251825820855401616427116096019744873046875}],["`prod` is functorial ",{"type":"{n : ‚Ñï} ‚Üí\n  {Œ± Œ±' Œ≤ Œ≤' : TypeVec.{u} n} ‚Üí\n    TypeVec.Arrow Œ± Œ≤ ‚Üí TypeVec.Arrow Œ±' Œ≤' ‚Üí TypeVec.Arrow (TypeVec.prod Œ± Œ±') (TypeVec.prod Œ≤ Œ≤')","name":"TypeVec.prod.map","isProp":false,"docString":"`prod` is functorial ","distance":0.382270190970288192833237417289637960493564605712890625}],["Notation for the product ",{"type":"Lean.TrailingParserDescr","name":"CategoryTheory.Limits.¬´term_‚®Ø_¬ª","isProp":false,"docString":"Notation for the product ","distance":0.385559319445963055716930512062390334904193878173828125}],["The product cone induced by the concrete product. ",{"type":"{R : Type u} ‚Üí [inst : Ring R] ‚Üí {Œπ : Type v} ‚Üí (Z : Œπ ‚Üí ModuleCatMax R) ‚Üí CategoryTheory.Limits.Fan Z","name":"ModuleCat.productCone","isProp":false,"docString":"The product cone induced by the concrete product. ","distance":0.385654261352195659728891996564925648272037506103515625}],["The product of the factors is the original number ",{"type":"‚àÄ (n : ‚Ñï+), PrimeMultiset.prod (PNat.factorMultiset n) = n","name":"PNat.prod_factorMultiset","isProp":true,"docString":"The product of the factors is the original number ","distance":0.386111102748693202357799236779101192951202392578125}],["The prod of two morphisms is a morphism. ",{"type":"{R : Type u} ‚Üí\n  {A : Type v} ‚Üí\n    {B : Type w} ‚Üí\n      {C : Type w‚ÇÅ} ‚Üí\n        [inst : Monoid R] ‚Üí\n          [inst_1 : NonUnitalNonAssocSemiring A] ‚Üí\n            [inst_2 : DistribMulAction R A] ‚Üí\n              [inst_3 : NonUnitalNonAssocSemiring B] ‚Üí\n                [inst_4 : DistribMulAction R B] ‚Üí\n                  [inst_5 : NonUnitalNonAssocSemiring C] ‚Üí\n                    [inst_6 : DistribMulAction R C] ‚Üí (A ‚Üí‚Çô‚Çê[R] B) ‚Üí (A ‚Üí‚Çô‚Çê[R] C) ‚Üí A ‚Üí‚Çô‚Çê[R] B √ó C","name":"NonUnitalAlgHom.prod","isProp":false,"docString":"The prod of two morphisms is a morphism. ","distance":0.386311204081275338939605035193380899727344512939453125}],["The second projection from the product. ",{"type":"{X Y : TopCat} ‚Üí TopCat.of (‚ÜëX √ó ‚ÜëY) ‚ü∂ Y","name":"TopCat.prodSnd","isProp":false,"docString":"The second projection from the product. ","distance":0.387093230649931230313853802726953290402889251708984375}],["The coproduct is the pushout under the initial object. ",{"type":"{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    {W X Y Z : C} ‚Üí\n      (f : X ‚ü∂ Z) ‚Üí\n        (g : Y ‚ü∂ Z) ‚Üí\n          (h : W ‚ü∂ X) ‚Üí\n            (k : W ‚ü∂ Y) ‚Üí\n              (H‚ÇÅ : CategoryTheory.Limits.IsInitial W) ‚Üí\n                CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.BinaryCofan.mk f g) ‚Üí\n                  CategoryTheory.Limits.IsColimit\n                    (CategoryTheory.Limits.PushoutCocone.mk f g\n                      (_ : CategoryTheory.CategoryStruct.comp h f = CategoryTheory.CategoryStruct.comp k g))","name":"isPushoutOfIsInitialIsCoproduct","isProp":false,"docString":"The coproduct is the pushout under the initial object. ","distance":0.3889879324902565382870989196817390620708465576171875}],["The set of good products. ",{"type":"{I : Type u} ‚Üí [inst : LinearOrder I] ‚Üí Set (I ‚Üí Bool) ‚Üí Set (Profinite.NobelingProof.Products I)","name":"Profinite.NobelingProof.GoodProducts","isProp":false,"docString":"The set of good products. ","distance":0.389682410353824837390135371606447733938694000244140625}],["A product of measures in `tprod Œ± l`. ",{"type":"{Œ¥ : Type u_4} ‚Üí\n  {œÄ : Œ¥ ‚Üí Type u_5} ‚Üí\n    [inst : (x : Œ¥) ‚Üí MeasurableSpace (œÄ x)] ‚Üí\n      (l : List Œ¥) ‚Üí ((i : Œ¥) ‚Üí MeasureTheory.Measure (œÄ i)) ‚Üí MeasureTheory.Measure (List.TProd œÄ l)","name":"MeasureTheory.Measure.tprod","isProp":false,"docString":"A product of measures in `tprod Œ± l`. ","distance":0.389712977598923149269438681585597805678844451904296875}],["Coproduct of filters. ",{"type":"{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí Filter Œ± ‚Üí Filter Œ≤ ‚Üí Filter (Œ± √ó Œ≤)","name":"Filter.coprod","isProp":false,"docString":"Coproduct of filters. ","distance":0.38974771653856221664824488470912910997867584228515625}],["The first projection of a product, as a smooth map. ",{"type":"{ùïú : Type u_1} ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [inst_2 : NormedSpace ùïú E] ‚Üí\n          {E' : Type u_3} ‚Üí\n            [inst_3 : NormedAddCommGroup E'] ‚Üí\n              [inst_4 : NormedSpace ùïú E'] ‚Üí\n                {H : Type u_4} ‚Üí\n                  [inst_5 : TopologicalSpace H] ‚Üí\n                    {H' : Type u_5} ‚Üí\n                      [inst_6 : TopologicalSpace H'] ‚Üí\n                        {I : ModelWithCorners ùïú E H} ‚Üí\n                          {I' : ModelWithCorners ùïú E' H'} ‚Üí\n                            {M : Type u_6} ‚Üí\n                              [inst_7 : TopologicalSpace M] ‚Üí\n                                [inst_8 : ChartedSpace H M] ‚Üí\n                                  {M' : Type u_7} ‚Üí\n                                    [inst_9 : TopologicalSpace M'] ‚Üí\n                                      [inst_10 : ChartedSpace H' M'] ‚Üí\n                                        {n : ‚Ñï‚àû} ‚Üí ContMDiffMap (ModelWithCorners.prod I I') I (M √ó M') M n","name":"ContMDiffMap.fst","isProp":false,"docString":"The first projection of a product, as a smooth map. ","distance":0.389852851161981261984834645772934891283512115478515625}],["The map from the coproduct into the pushout ",{"type":"{Œπ : Type u_1} ‚Üí\n  {G : Œπ ‚Üí Type u_2} ‚Üí\n    {H : Type u_3} ‚Üí\n      [inst : (i : Œπ) ‚Üí Monoid (G i)] ‚Üí\n        [inst_1 : Monoid H] ‚Üí {œÜ : (i : Œπ) ‚Üí H ‚Üí* G i} ‚Üí Monoid.CoprodI G ‚Üí* Monoid.PushoutI œÜ","name":"Monoid.PushoutI.ofCoprodI","isProp":false,"docString":"The map from the coproduct into the pushout ","distance":0.3928090886815851501268070933292619884014129638671875}],["The second projection of a product, as a smooth map. ",{"type":"{ùïú : Type u_1} ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [inst_2 : NormedSpace ùïú E] ‚Üí\n          {E' : Type u_3} ‚Üí\n            [inst_3 : NormedAddCommGroup E'] ‚Üí\n              [inst_4 : NormedSpace ùïú E'] ‚Üí\n                {H : Type u_4} ‚Üí\n                  [inst_5 : TopologicalSpace H] ‚Üí\n                    {H' : Type u_5} ‚Üí\n                      [inst_6 : TopologicalSpace H'] ‚Üí\n                        {I : ModelWithCorners ùïú E H} ‚Üí\n                          {I' : ModelWithCorners ùïú E' H'} ‚Üí\n                            {M : Type u_6} ‚Üí\n                              [inst_7 : TopologicalSpace M] ‚Üí\n                                [inst_8 : ChartedSpace H M] ‚Üí\n                                  {M' : Type u_7} ‚Üí\n                                    [inst_9 : TopologicalSpace M'] ‚Üí\n                                      [inst_10 : ChartedSpace H' M'] ‚Üí\n                                        {n : ‚Ñï‚àû} ‚Üí ContMDiffMap (ModelWithCorners.prod I I') I' (M √ó M') M' n","name":"ContMDiffMap.snd","isProp":false,"docString":"The second projection of a product, as a smooth map. ","distance":0.39321154716032680198622983880341053009033203125}],["The projection map to the first component of the product. ",{"type":"{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    {X Y : C} ‚Üí [inst_1 : CategoryTheory.Limits.HasBinaryProduct X Y] ‚Üí X ‚®Ø Y ‚ü∂ X","name":"CategoryTheory.Limits.prod.fst","isProp":false,"docString":"The projection map to the first component of the product. ","distance":0.396937163533329695486173704921384342014789581298828125}],["The product of a family of types over a list. ",{"type":"{Œπ : Type u} ‚Üí (Œπ ‚Üí Type v) ‚Üí List Œπ ‚Üí Type v","name":"List.TProd","isProp":false,"docString":"The product of a family of types over a list. ","distance":0.3970969347398531912318730974220670759677886962890625}],["Product of partial functions. ",{"type":"{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí {Œ≥ : Type u_3} ‚Üí (Œ± ‚Üí. Œ≤) ‚Üí (Œ± ‚Üí. Œ≥) ‚Üí Œ± ‚Üí. Œ≤ √ó Œ≥","name":"PFun.prodLift","isProp":false,"docString":"Product of partial functions. ","distance":0.39856194170405689902736412477679550647735595703125}]]