[["constructor for `prod` ",{"type":"{n : â„•} â†’ {Î± Î² : TypeVec.{u} n} â†’ (i : Fin2 n) â†’ Î± i â†’ Î² i â†’ TypeVec.prod Î± Î² i","name":"TypeVec.prod.mk","isProp":false,"docString":"constructor for `prod` ","distance":0.32518916284444887576654537042486481368541717529296875}],[" For any category with binary products, the product of two objects exists.",{"type":"âˆ€ {C : Type u_2} [inst : CategoryTheory.Category.{u_1, u_2} C] [inst_1 : CategoryTheory.Limits.HasBinaryProducts C]\n  (X Y : C), CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair X Y)","name":"CategoryTheory.Limits.prod.functor.proof_1","isProp":true,"docString":" For any category with binary products, the product of two objects exists.","distance":0.4813592874230676610380896818242035806179046630859375}],["This theorem, which is a part of Profinite's NobelingProof, asserts the following: for any type `I` equipped with a linear order, a set `C` of Boolean-valued functions on `I`, a product `l` of elements from `I`, and a predicate `J` on `I`, if every element `a` in the product `l` satisfies the predicate `J`, then for any `j` in `I` that can be decided by `J`, the composition of the evaluation of `l` under the image of `Proj Ï€ J` with the restriction of `Proj Ï€ J` to `C`, is equal to the evaluation of `l` under `C`. \n\nIn simple terms, this theorem shows a relationship between the evaluation of a product under a set of functions and its projection restricted to a subset, assuming that all elements of the product satisfy a certain property. The mathematical operations involved are function composition and evaluation.",{"type":"âˆ€ {I : Type u} [inst : LinearOrder I] (C : Set (I â†’ Bool)) {l : Profinite.NobelingProof.Products I} (J : I â†’ Prop),\n  (âˆ€ a âˆˆ â†‘l, J a) â†’\n    âˆ€ [inst_1 : (j : I) â†’ Decidable (J j)],\n      â‡‘(Profinite.NobelingProof.Products.eval (Profinite.NobelingProof.Ï€ C J) l) âˆ˜\n          Profinite.NobelingProof.ProjRestrict C J =\n        â‡‘(Profinite.NobelingProof.Products.eval C l)","name":"Profinite.NobelingProof.Products.evalFacProp","isProp":true,"docString":"This theorem, which is a part of Profinite's NobelingProof, asserts the following: for any type `I` equipped with a linear order, a set `C` of Boolean-valued functions on `I`, a product `l` of elements from `I`, and a predicate `J` on `I`, if every element `a` in the product `l` satisfies the predicate `J`, then for any `j` in `I` that can be decided by `J`, the composition of the evaluation of `l` under the image of `Proj Ï€ J` with the restriction of `Proj Ï€ J` to `C`, is equal to the evaluation of `l` under `C`. \n\nIn simple terms, this theorem shows a relationship between the evaluation of a product under a set of functions and its projection restricted to a subset, assuming that all elements of the product satisfy a certain property. The mathematical operations involved are function composition and evaluation.","distance":0.4600097104619766952282589045353233814239501953125}],["Delaborator for simple product projections. ",{"type":"Lean.PrettyPrinter.Delaborator.Delab","name":"delabProdProjs","isProp":false,"docString":"Delaborator for simple product projections. ","distance":0.34519765779680799955286829572287388145923614501953125}],[" For any topological spaces X and Y, the first projection function Prod.fst from X Ã— Y to X is an open map.",{"type":"âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], IsOpenMap Prod.fst","name":"isOpenMap_fst","isProp":true,"docString":" For any topological spaces X and Y, the first projection function Prod.fst from X Ã— Y to X is an open map.","distance":0.482564637832117393489994583433144725859165191650390625}],["This theorem states that for any non-trivially normed field `ğ•œ`, normed additively commutative groups `E` and `F`, which are both normed spaces over `ğ•œ`, and for any set `s` consisting of ordered pairs of elements from `E` and `F`, the second projection function `Prod.snd` is infinitely differentiable (denoted `C^âˆ` in mathematical notation) on the set `s`. In mathematical language, this means that the function which projects an ordered pair to its second component, when applied to any point in the set `s`, has all of its derivatives exist and are continuous.",{"type":"âˆ€ {ğ•œ : Type u_1} [inst : NontriviallyNormedField ğ•œ] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ğ•œ E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ğ•œ F] {n : â„•âˆ}\n  {s : Set (E Ã— F)}, ContDiffOn ğ•œ n Prod.snd s","name":"contDiffOn_snd","isProp":true,"docString":"This theorem states that for any non-trivially normed field `ğ•œ`, normed additively commutative groups `E` and `F`, which are both normed spaces over `ğ•œ`, and for any set `s` consisting of ordered pairs of elements from `E` and `F`, the second projection function `Prod.snd` is infinitely differentiable (denoted `C^âˆ` in mathematical notation) on the set `s`. In mathematical language, this means that the function which projects an ordered pair to its second component, when applied to any point in the set `s`, has all of its derivatives exist and are continuous.","distance":0.463739725590076312666809599249972961843013763427734375}],["Products of completions ",{"type":"{Î± : Type u_1} â†’\n  [inst : UniformSpace Î±] â†’\n    AbstractCompletion Î± â†’\n      {Î² : Type u_2} â†’ [inst_1 : UniformSpace Î²] â†’ AbstractCompletion Î² â†’ AbstractCompletion (Î± Ã— Î²)","name":"AbstractCompletion.prod","isProp":false,"docString":"Products of completions ","distance":0.3634324693368162773055018988088704645633697509765625}],["The first projection from the product. ",{"type":"{X Y : TopCat} â†’ TopCat.of (â†‘X Ã— â†‘Y) âŸ¶ X","name":"TopCat.prodFst","isProp":false,"docString":"The first projection from the product. ","distance":0.37558729039251825820855401616427116096019744873046875}],["`prod` is functorial ",{"type":"{n : â„•} â†’\n  {Î± Î±' Î² Î²' : TypeVec.{u} n} â†’\n    TypeVec.Arrow Î± Î² â†’ TypeVec.Arrow Î±' Î²' â†’ TypeVec.Arrow (TypeVec.prod Î± Î±') (TypeVec.prod Î² Î²')","name":"TypeVec.prod.map","isProp":false,"docString":"`prod` is functorial ","distance":0.382270190970288192833237417289637960493564605712890625}],["Notation for the product ",{"type":"Lean.TrailingParserDescr","name":"CategoryTheory.Limits.Â«term_â¨¯_Â»","isProp":false,"docString":"Notation for the product ","distance":0.385559319445963055716930512062390334904193878173828125}],["The product cone induced by the concrete product. ",{"type":"{R : Type u} â†’ [inst : Ring R] â†’ {Î¹ : Type v} â†’ (Z : Î¹ â†’ ModuleCatMax R) â†’ CategoryTheory.Limits.Fan Z","name":"ModuleCat.productCone","isProp":false,"docString":"The product cone induced by the concrete product. ","distance":0.385654261352195659728891996564925648272037506103515625}],["The product of the factors is the original number ",{"type":"âˆ€ (n : â„•+), PrimeMultiset.prod (PNat.factorMultiset n) = n","name":"PNat.prod_factorMultiset","isProp":true,"docString":"The product of the factors is the original number ","distance":0.386111102748693202357799236779101192951202392578125}],["The prod of two morphisms is a morphism. ",{"type":"{R : Type u} â†’\n  {A : Type v} â†’\n    {B : Type w} â†’\n      {C : Type wâ‚} â†’\n        [inst : Monoid R] â†’\n          [inst_1 : NonUnitalNonAssocSemiring A] â†’\n            [inst_2 : DistribMulAction R A] â†’\n              [inst_3 : NonUnitalNonAssocSemiring B] â†’\n                [inst_4 : DistribMulAction R B] â†’\n                  [inst_5 : NonUnitalNonAssocSemiring C] â†’\n                    [inst_6 : DistribMulAction R C] â†’ (A â†’â‚™â‚[R] B) â†’ (A â†’â‚™â‚[R] C) â†’ A â†’â‚™â‚[R] B Ã— C","name":"NonUnitalAlgHom.prod","isProp":false,"docString":"The prod of two morphisms is a morphism. ","distance":0.386311204081275338939605035193380899727344512939453125}],["The second projection from the product. ",{"type":"{X Y : TopCat} â†’ TopCat.of (â†‘X Ã— â†‘Y) âŸ¶ Y","name":"TopCat.prodSnd","isProp":false,"docString":"The second projection from the product. ","distance":0.387093230649931230313853802726953290402889251708984375}],["The coproduct is the pushout under the initial object. ",{"type":"{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    {W X Y Z : C} â†’\n      (f : X âŸ¶ Z) â†’\n        (g : Y âŸ¶ Z) â†’\n          (h : W âŸ¶ X) â†’\n            (k : W âŸ¶ Y) â†’\n              (Hâ‚ : CategoryTheory.Limits.IsInitial W) â†’\n                CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.BinaryCofan.mk f g) â†’\n                  CategoryTheory.Limits.IsColimit\n                    (CategoryTheory.Limits.PushoutCocone.mk f g\n                      (_ : CategoryTheory.CategoryStruct.comp h f = CategoryTheory.CategoryStruct.comp k g))","name":"isPushoutOfIsInitialIsCoproduct","isProp":false,"docString":"The coproduct is the pushout under the initial object. ","distance":0.3889879324902565382870989196817390620708465576171875}],["The set of good products. ",{"type":"{I : Type u} â†’ [inst : LinearOrder I] â†’ Set (I â†’ Bool) â†’ Set (Profinite.NobelingProof.Products I)","name":"Profinite.NobelingProof.GoodProducts","isProp":false,"docString":"The set of good products. ","distance":0.389682410353824837390135371606447733938694000244140625}],["A product of measures in `tprod Î± l`. ",{"type":"{Î´ : Type u_4} â†’\n  {Ï€ : Î´ â†’ Type u_5} â†’\n    [inst : (x : Î´) â†’ MeasurableSpace (Ï€ x)] â†’\n      (l : List Î´) â†’ ((i : Î´) â†’ MeasureTheory.Measure (Ï€ i)) â†’ MeasureTheory.Measure (List.TProd Ï€ l)","name":"MeasureTheory.Measure.tprod","isProp":false,"docString":"A product of measures in `tprod Î± l`. ","distance":0.389712977598923149269438681585597805678844451904296875}],["Coproduct of filters. ",{"type":"{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ Filter Î± â†’ Filter Î² â†’ Filter (Î± Ã— Î²)","name":"Filter.coprod","isProp":false,"docString":"Coproduct of filters. ","distance":0.38974771653856221664824488470912910997867584228515625}],["The first projection of a product, as a smooth map. ",{"type":"{ğ•œ : Type u_1} â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    {E : Type u_2} â†’\n      [inst_1 : NormedAddCommGroup E] â†’\n        [inst_2 : NormedSpace ğ•œ E] â†’\n          {E' : Type u_3} â†’\n            [inst_3 : NormedAddCommGroup E'] â†’\n              [inst_4 : NormedSpace ğ•œ E'] â†’\n                {H : Type u_4} â†’\n                  [inst_5 : TopologicalSpace H] â†’\n                    {H' : Type u_5} â†’\n                      [inst_6 : TopologicalSpace H'] â†’\n                        {I : ModelWithCorners ğ•œ E H} â†’\n                          {I' : ModelWithCorners ğ•œ E' H'} â†’\n                            {M : Type u_6} â†’\n                              [inst_7 : TopologicalSpace M] â†’\n                                [inst_8 : ChartedSpace H M] â†’\n                                  {M' : Type u_7} â†’\n                                    [inst_9 : TopologicalSpace M'] â†’\n                                      [inst_10 : ChartedSpace H' M'] â†’\n                                        {n : â„•âˆ} â†’ ContMDiffMap (ModelWithCorners.prod I I') I (M Ã— M') M n","name":"ContMDiffMap.fst","isProp":false,"docString":"The first projection of a product, as a smooth map. ","distance":0.389852851161981261984834645772934891283512115478515625}],["The map from the coproduct into the pushout ",{"type":"{Î¹ : Type u_1} â†’\n  {G : Î¹ â†’ Type u_2} â†’\n    {H : Type u_3} â†’\n      [inst : (i : Î¹) â†’ Monoid (G i)] â†’\n        [inst_1 : Monoid H] â†’ {Ï† : (i : Î¹) â†’ H â†’* G i} â†’ Monoid.CoprodI G â†’* Monoid.PushoutI Ï†","name":"Monoid.PushoutI.ofCoprodI","isProp":false,"docString":"The map from the coproduct into the pushout ","distance":0.3928090886815851501268070933292619884014129638671875}],["The second projection of a product, as a smooth map. ",{"type":"{ğ•œ : Type u_1} â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    {E : Type u_2} â†’\n      [inst_1 : NormedAddCommGroup E] â†’\n        [inst_2 : NormedSpace ğ•œ E] â†’\n          {E' : Type u_3} â†’\n            [inst_3 : NormedAddCommGroup E'] â†’\n              [inst_4 : NormedSpace ğ•œ E'] â†’\n                {H : Type u_4} â†’\n                  [inst_5 : TopologicalSpace H] â†’\n                    {H' : Type u_5} â†’\n                      [inst_6 : TopologicalSpace H'] â†’\n                        {I : ModelWithCorners ğ•œ E H} â†’\n                          {I' : ModelWithCorners ğ•œ E' H'} â†’\n                            {M : Type u_6} â†’\n                              [inst_7 : TopologicalSpace M] â†’\n                                [inst_8 : ChartedSpace H M] â†’\n                                  {M' : Type u_7} â†’\n                                    [inst_9 : TopologicalSpace M'] â†’\n                                      [inst_10 : ChartedSpace H' M'] â†’\n                                        {n : â„•âˆ} â†’ ContMDiffMap (ModelWithCorners.prod I I') I' (M Ã— M') M' n","name":"ContMDiffMap.snd","isProp":false,"docString":"The second projection of a product, as a smooth map. ","distance":0.39321154716032680198622983880341053009033203125}],["The projection map to the first component of the product. ",{"type":"{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    {X Y : C} â†’ [inst_1 : CategoryTheory.Limits.HasBinaryProduct X Y] â†’ X â¨¯ Y âŸ¶ X","name":"CategoryTheory.Limits.prod.fst","isProp":false,"docString":"The projection map to the first component of the product. ","distance":0.396937163533329695486173704921384342014789581298828125}],["The product of a family of types over a list. ",{"type":"{Î¹ : Type u} â†’ (Î¹ â†’ Type v) â†’ List Î¹ â†’ Type v","name":"List.TProd","isProp":false,"docString":"The product of a family of types over a list. ","distance":0.3970969347398531912318730974220670759677886962890625}],["Product of partial functions. ",{"type":"{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ {Î³ : Type u_3} â†’ (Î± â†’. Î²) â†’ (Î± â†’. Î³) â†’ Î± â†’. Î² Ã— Î³","name":"PFun.prodLift","isProp":false,"docString":"Product of partial functions. ","distance":0.39856194170405689902736412477679550647735595703125}]]