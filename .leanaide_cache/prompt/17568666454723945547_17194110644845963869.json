[["Notation for the product ",{"type":"Lean.TrailingParserDescr","name":"CategoryTheory.Limits.«term_⨯_»","isProp":false,"docString":"Notation for the product ","distance":0.26286771346407367122566256512072868645191192626953125}],[" If the product of the opposites of two elements has at most one representation as a product of elements from two sets under multiplication, then the product of the original elements has at most one representation as a product of an element from each set.",{"type":"∀ {G : Type u_1} [inst : Mul G] {A B : Finset G} {a0 b0 : G},\n  UniqueMul (Finset.map { toFun := MulOpposite.op, inj' := ⋯ } B) (Finset.map { toFun := MulOpposite.op, inj' := ⋯ } A)\n      (MulOpposite.op b0) (MulOpposite.op a0) →\n    UniqueMul A B a0 b0","name":"UniqueMul.of_mulOpposite","isProp":true,"docString":" If the product of the opposites of two elements has at most one representation as a product of elements from two sets under multiplication, then the product of the original elements has at most one representation as a product of an element from each set.","distance":0.38765255557288913479396796901710331439971923828125}],["This theorem is known as the *Euler Product* for completely multiplicative functions. If you have a completely multiplicative function `f` from natural numbers to a complete normed field `F`, and the norm of `f` is summable (i.e., the series of the norms of `f` converges), then the product over all prime numbers `p` of `(1 - f p)⁻¹` converges to the sum over all natural numbers `n` of `f n`. Concretely, this says the infinite product `∏' p : Nat.Primes, (1 - f p)⁻¹` equals the infinite sum `∑' n, f n`. This theorem is stated in the form of convergence of finite partial products, meaning that as you consider more and more terms in the product, the value of the product gets closer and closer to the value of the infinite sum.",{"type":"∀ {F : Type u_1} [inst : NormedField F] [inst_1 : CompleteSpace F] {f : ℕ →*₀ F},\n  (Summable fun x => ‖f x‖) →\n    Filter.Tendsto (fun n => n.primesBelow.prod fun p => (1 - f p)⁻¹) Filter.atTop (nhds (∑' (n : ℕ), f n))","name":"EulerProduct.eulerProduct_completely_multiplicative","isProp":true,"docString":"This theorem is known as the *Euler Product* for completely multiplicative functions. If you have a completely multiplicative function `f` from natural numbers to a complete normed field `F`, and the norm of `f` is summable (i.e., the series of the norms of `f` converges), then the product over all prime numbers `p` of `(1 - f p)⁻¹` converges to the sum over all natural numbers `n` of `f n`. Concretely, this says the infinite product `∏' p : Nat.Primes, (1 - f p)⁻¹` equals the infinite sum `∑' n, f n`. This theorem is stated in the form of convergence of finite partial products, meaning that as you consider more and more terms in the product, the value of the product gets closer and closer to the value of the infinite sum.","distance":0.38473984624150114886020901394658721983432769775390625}],["The product of the factors is the original number ",{"type":"∀ (n : ℕ+), PrimeMultiset.prod (PNat.factorMultiset n) = n","name":"PNat.prod_factorMultiset","isProp":true,"docString":"The product of the factors is the original number ","distance":0.27753008841017356989055997473769821226596832275390625}],[" For any category with binary products, the product of two objects exists.",{"type":"∀ {C : Type u_2} [inst : CategoryTheory.Category.{u_1, u_2} C] [inst_1 : CategoryTheory.Limits.HasBinaryProducts C]\n  (X Y : C), CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair X Y)","name":"CategoryTheory.Limits.prod.functor.proof_1","isProp":true,"docString":" For any category with binary products, the product of two objects exists.","distance":0.39109971516176378347751096953288652002811431884765625}],["This theorem states that for all integers `a` and `b`, the product of the negations of `a` and `b` (i.e., `-a * -b`) is equal to the product of `a` and `b` (i.e., `a * b`). This is a formal expression of the mathematical rule that the product of two negative numbers is a positive number.",{"type":"∀ (a b : ℤ), -a * -b = a * b","name":"Int.neg_mul_neg","isProp":true,"docString":"This theorem states that for all integers `a` and `b`, the product of the negations of `a` and `b` (i.e., `-a * -b`) is equal to the product of `a` and `b` (i.e., `a * b`). This is a formal expression of the mathematical rule that the product of two negative numbers is a positive number.","distance":0.386653258591021842249801920843310654163360595703125}],["The second projection from the product. ",{"type":"{X Y : TopCat} → TopCat.of (↑X × ↑Y) ⟶ Y","name":"TopCat.prodSnd","isProp":false,"docString":"The second projection from the product. ","distance":0.29832011716263540090920969305443577468395233154296875}],["Product of two rings is a ring. ",{"type":"{R : Type u_3} → {S : Type u_5} → [inst : Ring R] → [inst : Ring S] → Ring (R × S)","name":"Prod.instRing","isProp":false,"docString":"Product of two rings is a ring. ","distance":0.300866966152561421399269647736218757927417755126953125}],["Product of partial functions. ",{"type":"{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α →. β) → (α →. γ) → α →. β × γ","name":"PFun.prodLift","isProp":false,"docString":"Product of partial functions. ","distance":0.301238614926091996526480443208129145205020904541015625}],["The first projection from the product. ",{"type":"{X Y : TopCat} → TopCat.of (↑X × ↑Y) ⟶ X","name":"TopCat.prodFst","isProp":false,"docString":"The first projection from the product. ","distance":0.3014084610733382962877158206538297235965728759765625}],["The projection onto a summand of a biproduct. ",{"type":"{J : Type w} →\n  {C : Type u} →\n    [inst : CategoryTheory.Category.{v, u} C] →\n      [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n        (f : J → C) → [inst_2 : CategoryTheory.Limits.HasBiproduct f] → (b : J) → ⨁ f ⟶ f b","name":"CategoryTheory.Limits.biproduct.π","isProp":false,"docString":"The projection onto a summand of a biproduct. ","distance":0.31139371858431530437627543506096117198467254638671875}],["The inclusion of a summand into the free product. ",{"type":"{ι : Type u_1} → {M : ι → Type u_2} → [inst : (i : ι) → Monoid (M i)] → {i : ι} → M i →* Monoid.CoprodI M","name":"Monoid.CoprodI.of","isProp":false,"docString":"The inclusion of a summand into the free product. ","distance":0.31139671174743377424221080218558199703693389892578125}],["Tensor products distribute over a product on the left . ",{"type":"(R : Type uR) →\n  (M₁ : Type uM₁) →\n    (M₂ : Type uM₂) →\n      (M₃ : Type uM₃) →\n        [inst : CommSemiring R] →\n          [inst_1 : AddCommMonoid M₁] →\n            [inst_2 : AddCommMonoid M₂] →\n              [inst_3 : AddCommMonoid M₃] →\n                [inst_4 : Module R M₁] →\n                  [inst_5 : Module R M₂] →\n                    [inst_6 : Module R M₃] →\n                      TensorProduct R (M₁ × M₂) M₃ ≃ₗ[R] TensorProduct R M₁ M₃ × TensorProduct R M₂ M₃","name":"TensorProduct.prodLeft","isProp":false,"docString":"Tensor products distribute over a product on the left . ","distance":0.314538494062921281102518378247623331844806671142578125}],["The equivalence between the opposite of a product and the product of the opposites. ",{"type":"(C : Type u₃) →\n  [inst : CategoryTheory.Category.{v₃, u₃} C] →\n    {D : Type u₄} → [inst_1 : CategoryTheory.Category.{v₄, u₄} D] → (C × D)ᵒᵖ ≌ Cᵒᵖ × Dᵒᵖ","name":"CategoryTheory.prodOpEquiv","isProp":false,"docString":"The equivalence between the opposite of a product and the product of the opposites. ","distance":0.314844339530417405281781384474015794694423675537109375}],["The coproduct is the pushout under the initial object. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {W X Y Z : C} →\n      (f : X ⟶ Z) →\n        (g : Y ⟶ Z) →\n          (h : W ⟶ X) →\n            (k : W ⟶ Y) →\n              (H₁ : CategoryTheory.Limits.IsInitial W) →\n                CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.BinaryCofan.mk f g) →\n                  CategoryTheory.Limits.IsColimit\n                    (CategoryTheory.Limits.PushoutCocone.mk f g\n                      (_ : CategoryTheory.CategoryStruct.comp h f = CategoryTheory.CategoryStruct.comp k g))","name":"isPushoutOfIsInitialIsCoproduct","isProp":false,"docString":"The coproduct is the pushout under the initial object. ","distance":0.3150508641711347035396784121985547244548797607421875}],["Tensor products distribute over a product on the right. ",{"type":"(R : Type uR) →\n  (M₁ : Type uM₁) →\n    (M₂ : Type uM₂) →\n      (M₃ : Type uM₃) →\n        [inst : CommSemiring R] →\n          [inst_1 : AddCommMonoid M₁] →\n            [inst_2 : AddCommMonoid M₂] →\n              [inst_3 : AddCommMonoid M₃] →\n                [inst_4 : Module R M₁] →\n                  [inst_5 : Module R M₂] →\n                    [inst_6 : Module R M₃] →\n                      TensorProduct R M₁ (M₂ × M₃) ≃ₗ[R] TensorProduct R M₁ M₂ × TensorProduct R M₁ M₃","name":"TensorProduct.prodRight","isProp":false,"docString":"Tensor products distribute over a product on the right. ","distance":0.31529235681445222372332182203535921871662139892578125}],["The inclusion into a summand of a biproduct. ",{"type":"{J : Type w} →\n  {C : Type u} →\n    [inst : CategoryTheory.Category.{v, u} C] →\n      [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n        (f : J → C) → [inst_2 : CategoryTheory.Limits.HasBiproduct f] → (b : J) → f b ⟶ ⨁ f","name":"CategoryTheory.Limits.biproduct.ι","isProp":false,"docString":"The inclusion into a summand of a biproduct. ","distance":0.321287139907021568330236505062202922999858856201171875}],["An inner product with a sum on the right. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_4} (s : Finset ι) (f : ι → E) (x : E), ⟪x, Finset.sum s fun i => f i⟫_𝕜 = Finset.sum s fun i => ⟪x, f i⟫_𝕜","name":"inner_sum","isProp":true,"docString":"An inner product with a sum on the right. ","distance":0.3228527658139503930811997634009458124637603759765625}],["An inner product with a sum on the left. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_4} (s : Finset ι) (f : ι → E) (x : E), ⟪Finset.sum s fun i => f i, x⟫_𝕜 = Finset.sum s fun i => ⟪f i, x⟫_𝕜","name":"sum_inner","isProp":true,"docString":"An inner product with a sum on the left. ","distance":0.322967842676872229912277134644682519137859344482421875}],["The projection onto the first summand of a binary biproduct. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      {X Y : C} → [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct X Y] → X ⊞ Y ⟶ X","name":"CategoryTheory.Limits.biprod.fst","isProp":false,"docString":"The projection onto the first summand of a binary biproduct. ","distance":0.32332165947206892298027014476247131824493408203125}],["The composition-product of a measure and a kernel. ",{"type":"Lean.TrailingParserDescr","name":"ProbabilityTheory.«term_⊗ₘ_»","isProp":false,"docString":"The composition-product of a measure and a kernel. ","distance":0.324906075188935494768571743406937457621097564697265625}],["The map from the coproduct into the pushout ",{"type":"{ι : Type u_1} →\n  {G : ι → Type u_2} →\n    {H : Type u_3} →\n      [inst : (i : ι) → Monoid (G i)] →\n        [inst_1 : Monoid H] → {φ : (i : ι) → H →* G i} → Monoid.CoprodI G →* Monoid.PushoutI φ","name":"Monoid.PushoutI.ofCoprodI","isProp":false,"docString":"The map from the coproduct into the pushout ","distance":0.325492961471629815850548084199544973671436309814453125}],["The fiber product $X \\times_Y X$. ",{"type":"{X : Type u_1} → {Y : Sort u_2} → (X → Y) → Type u_1","name":"Function.PullbackSelf","isProp":false,"docString":"The fiber product $X \\times_Y X$. ","distance":0.3262508916775368472684704101993702352046966552734375}],["Product of a list of elements in a subfield is in the subfield. ",{"type":"∀ {K : Type u} [inst : DivisionRing K] (s : Subfield K) {l : List K}, (∀ x ∈ l, x ∈ s) → List.prod l ∈ s","name":"Subfield.list_prod_mem","isProp":true,"docString":"Product of a list of elements in a subfield is in the subfield. ","distance":0.32644140274596133988183055407716892659664154052734375}]]