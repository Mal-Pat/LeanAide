[["an arrow ",{"type":"{V : Type u} → [inst : Quiver V] → (self : Quiver.Total V) → self.left ⟶ self.right","name":"Quiver.Total.hom","isProp":false,"docString":"an arrow ","distance":0.388453937987165709433412530415807850658893585205078125}],[" A natural number is odd if and only if it is not even, or equivalently, a natural number is odd if and only if it can be expressed as 2 times an integer plus one, while an even number can be expressed as the sum of two integers.",{"type":"∀ {n : ℕ}, Odd n ↔ ¬Even n","name":"Nat.odd_iff_not_even","isProp":true,"docString":" A natural number is odd if and only if it is not even, or equivalently, a natural number is odd if and only if it can be expressed as 2 times an integer plus one, while an even number can be expressed as the sum of two integers.","distance":0.50692440211279732320548419011174701154232025146484375}],["This theorem states that there exists a unique solution for an ordinary differential equation (ODE) of the form \\(\\dot x = v(t, x)\\) with a given initial value, provided that the right-hand side function 'v' is Lipschitz continuous in 'x'. More specifically, given two solutions 'f' and 'g' of the ODE, both continuously defined on a closed interval [a, b], with the derivative of each at 't' in the right-closed interval [a, b) being the value of 'v' evaluated at 't' and the function value, and both solutions having the same initial value at 'a', then 'f' and 'g' should be equal on the whole interval [a, b].",{"type":"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {v : ℝ → E → E} {K : NNReal} {f g : ℝ → E}\n  {a b : ℝ},\n  (∀ (t : ℝ), LipschitzWith K (v t)) →\n    ContinuousOn f (Set.Icc a b) →\n      (∀ t ∈ Set.Ico a b, HasDerivWithinAt f (v t (f t)) (Set.Ici t) t) →\n        ContinuousOn g (Set.Icc a b) →\n          (∀ t ∈ Set.Ico a b, HasDerivWithinAt g (v t (g t)) (Set.Ici t) t) → f a = g a → Set.EqOn f g (Set.Icc a b)","name":"ODE_solution_unique","isProp":true,"docString":"This theorem states that there exists a unique solution for an ordinary differential equation (ODE) of the form \\(\\dot x = v(t, x)\\) with a given initial value, provided that the right-hand side function 'v' is Lipschitz continuous in 'x'. More specifically, given two solutions 'f' and 'g' of the ODE, both continuously defined on a closed interval [a, b], with the derivative of each at 't' in the right-closed interval [a, b) being the value of 'v' evaluated at 't' and the function value, and both solutions having the same initial value at 'a', then 'f' and 'g' should be equal on the whole interval [a, b].","distance":0.4617427845504569194901023365673609077930450439453125}],["Standard part predicate ",{"type":"ℝ* → ℝ → Prop","name":"Hyperreal.IsSt","isProp":false,"docString":"Standard part predicate ","distance":0.414183401654940663849657767059397883713245391845703125}],[" A natural number is odd if and only if its residue modulo 4 is 1 or 3.",{"type":"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3","name":"Nat.odd_mod_four_iff","isProp":true,"docString":" A natural number is odd if and only if its residue modulo 4 is 1 or 3.","distance":0.51272148116296378805856193139334209263324737548828125}],["This theorem states that a natural number is odd if and only if its remainder when divided by 4 is either 1 or 3. In other words, it characterizes odd numbers in terms of their residues modulo 4.",{"type":"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3","name":"Nat.odd_mod_four_iff","isProp":true,"docString":"This theorem states that a natural number is odd if and only if its remainder when divided by 4 is either 1 or 3. In other words, it characterizes odd numbers in terms of their residues modulo 4.","distance":0.47306576358036889207170361260068602859973907470703125}],["the distinguished element ",{"type":"(self : Pointed) → self.X","name":"Pointed.point","isProp":false,"docString":"the distinguished element ","distance":0.41418772023300032270043402604642324149608612060546875}],["The empty word ",{"type":"{G : Type u_1} →\n  [inst : Group G] →\n    {A B : Subgroup G} → {d : HNNExtension.NormalWord.TransversalPair G A B} → HNNExtension.NormalWord d","name":"HNNExtension.NormalWord.empty","isProp":false,"docString":"The empty word ","distance":0.4159305453569033250715847316314466297626495361328125}],["The one of the ring ",{"type":"{d : ℤ} → One (ℤ√d)","name":"Zsqrtd.instOneZsqrtd","isProp":false,"docString":"The one of the ring ","distance":0.416089455054085899377014357014559209346771240234375}],["an object in the source category ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {F : CategoryTheory.Functor C D} →\n          {X : C} →\n            {S : CategoryTheory.Presieve X} →\n              {Y : D} → {f : Y ⟶ F.obj X} → CategoryTheory.Presieve.FunctorPushforwardStructure F S f → C","name":"CategoryTheory.Presieve.FunctorPushforwardStructure.preobj","isProp":false,"docString":"an object in the source category ","distance":0.41702033731139398486931213483330793678760528564453125}],["an endomorphism of the object ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] → (self : CategoryTheory.Idempotents.Karoubi C) → self.X ⟶ self.X","name":"CategoryTheory.Idempotents.Karoubi.p","isProp":false,"docString":"an endomorphism of the object ","distance":0.417272975692499270561341973007074557244777679443359375}],["The adjoined root. ",{"type":"{R : Type u} → [inst : CommRing R] → (f : Polynomial R) → AdjoinRoot f","name":"AdjoinRoot.root","isProp":false,"docString":"The adjoined root. ","distance":0.4173290464287193746173443287261761724948883056640625}],["There is a splitting ",{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X Y : C} {f : X ⟶ Y} [self : CategoryTheory.IsSplitEpi f],\n  Nonempty (CategoryTheory.SplitEpi f)","name":"CategoryTheory.IsSplitEpi.exists_splitEpi","isProp":true,"docString":"There is a splitting ","distance":0.41813729647504960240667060134001076221466064453125}],["Left whiskering of an oplax natural transformation and a modification. ",{"type":"{B : Type u₁} →\n  [inst : CategoryTheory.Bicategory B] →\n    {C : Type u₂} →\n      [inst_1 : CategoryTheory.Bicategory C] →\n        {F G H : CategoryTheory.OplaxFunctor B C} →\n          (η : F ⟶ G) →\n            {θ ι : G ⟶ H} → (θ ⟶ ι) → (CategoryTheory.CategoryStruct.comp η θ ⟶ CategoryTheory.CategoryStruct.comp η ι)","name":"CategoryTheory.OplaxNatTrans.whiskerLeft","isProp":false,"docString":"Left whiskering of an oplax natural transformation and a modification. ","distance":0.4201998099631356620164979176479391753673553466796875}],["the morphism on the right objects ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_3, u_1} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      {S₁ S₂ : CategoryTheory.ShortComplex C} → CategoryTheory.ShortComplex.Hom S₁ S₂ → (S₁.X₃ ⟶ S₂.X₃)","name":"CategoryTheory.ShortComplex.Hom.τ₃","isProp":false,"docString":"the morphism on the right objects ","distance":0.420762699784744509390321809405577369034290313720703125}],["The identity oplax natural transformation. ",{"type":"{B : Type u₁} →\n  [inst : CategoryTheory.Bicategory B] →\n    {C : Type u₂} →\n      [inst_1 : CategoryTheory.Bicategory C] → (F : CategoryTheory.OplaxFunctor B C) → CategoryTheory.OplaxNatTrans F F","name":"CategoryTheory.OplaxNatTrans.id","isProp":false,"docString":"The identity oplax natural transformation. ","distance":0.422535309551007653983134559894097037613391876220703125}],["the axiom of choice ",{"type":"∀ {α : Sort u} {β : α → Sort v} {r : (x : α) → β x → Prop}, (∀ (x : α), ∃ y, r x y) → ∃ f, ∀ (x : α), r x (f x)","name":"Classical.axiomOfChoice","isProp":true,"docString":"the axiom of choice ","distance":0.42351736038413301255189935545786283910274505615234375}],["Head term ",{"type":"{α : Type u_1} → GeneralizedContinuedFraction α → α","name":"GeneralizedContinuedFraction.h","isProp":false,"docString":"Head term ","distance":0.423767068019309245396897267710301093757152557373046875}],["The empty finset ",{"type":"{α : Type u_1} → Finset α","name":"Finset.empty","isProp":false,"docString":"The empty finset ","distance":0.42457031286298885230934274659375660121440887451171875}],["Right whiskering of an oplax natural transformation and a modification. ",{"type":"{B : Type u₁} →\n  [inst : CategoryTheory.Bicategory B] →\n    {C : Type u₂} →\n      [inst_1 : CategoryTheory.Bicategory C] →\n        {F G H : CategoryTheory.OplaxFunctor B C} →\n          {η θ : F ⟶ G} →\n            (η ⟶ θ) → (ι : G ⟶ H) → CategoryTheory.CategoryStruct.comp η ι ⟶ CategoryTheory.CategoryStruct.comp θ ι","name":"CategoryTheory.OplaxNatTrans.whiskerRight","isProp":false,"docString":"Right whiskering of an oplax natural transformation and a modification. ","distance":0.425116930215693467065563027063035406172275543212890625}],["the morphism on the middle objects ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_3, u_1} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      {S₁ S₂ : CategoryTheory.ShortComplex C} → CategoryTheory.ShortComplex.Hom S₁ S₂ → (S₁.X₂ ⟶ S₂.X₂)","name":"CategoryTheory.ShortComplex.Hom.τ₂","isProp":false,"docString":"the morphism on the middle objects ","distance":0.425353704368326202001071578706614673137664794921875}],["the morphism on the left objects ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_3, u_1} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      {S₁ S₂ : CategoryTheory.ShortComplex C} → CategoryTheory.ShortComplex.Hom S₁ S₂ → (S₁.X₁ ⟶ S₂.X₁)","name":"CategoryTheory.ShortComplex.Hom.τ₁","isProp":false,"docString":"the morphism on the left objects ","distance":0.42561882001976858447278573294170200824737548828125}],["`id` is entire ",{"type":"∀ (𝕜 : Type u_1) [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {s : Set E}, AnalyticOn 𝕜 (fun x => x) s","name":"analyticOn_id","isProp":true,"docString":"`id` is entire ","distance":0.425680504608496323992739007735508494079113006591796875}],["tensorator ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.MonoidalCategory C] →\n      {D : Type u₂} →\n        [inst_2 : CategoryTheory.Category.{v₂, u₂} D] →\n          [inst_3 : CategoryTheory.MonoidalCategory D] →\n            {F : C → D} →\n              [inst_4 : CategoryTheory.Functorial F] →\n                [self : CategoryTheory.LaxMonoidal F] →\n                  (X Y : C) →\n                    CategoryTheory.MonoidalCategory.tensorObj (F X) (F Y) ⟶\n                      F (CategoryTheory.MonoidalCategory.tensorObj X Y)","name":"CategoryTheory.LaxMonoidal.μ","isProp":false,"docString":"tensorator ","distance":0.42572132077161672913945267282542772591114044189453125}]]