[["Vertical composition of oplax natural transformations. ",{"type":"{B : Type u₁} →\n  [inst : CategoryTheory.Bicategory B] →\n    {C : Type u₂} →\n      [inst_1 : CategoryTheory.Bicategory C] →\n        {F G H : CategoryTheory.OplaxFunctor B C} →\n          CategoryTheory.OplaxNatTrans F G → CategoryTheory.OplaxNatTrans G H → CategoryTheory.OplaxNatTrans F H","name":"CategoryTheory.OplaxNatTrans.vcomp","isProp":false,"docString":"Vertical composition of oplax natural transformations. ","distance":0.426623524445831348028690399587503634393215179443359375}],[" For any open immersion $f : X \\to Y$ between presheaves over a category $C$, and any open set $U$ in the underlying topological space of $X$, we have $U^op = (f(U))^op \\cap X^op$, where $A^op$ denotes the opposite of an object $A$.",{"type":"∀ {C : Type u_2} [inst : CategoryTheory.Category.{u_3, u_2} C] {X Y : AlgebraicGeometry.PresheafedSpace C} {f : X ⟶ Y}\n  (H : AlgebraicGeometry.PresheafedSpace.IsOpenImmersion f) (U : TopologicalSpace.Opens ↑↑X),\n  Opposite.op U = Opposite.op ((TopologicalSpace.Opens.map f.base).obj (Opposite.op (H.openFunctor.obj U)).unop)","name":"AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.invApp.proof_1","isProp":true,"docString":" For any open immersion $f : X \\to Y$ between presheaves over a category $C$, and any open set $U$ in the underlying topological space of $X$, we have $U^op = (f(U))^op \\cap X^op$, where $A^op$ denotes the opposite of an object $A$.","distance":0.51504732011434539717953384752036072313785552978515625}],["This theorem states that for any type `α` that is a Heyting algebra, the pseudocomplement `⊤ᶜ` of the top element `⊤` is equal to the bottom element `⊥`. In other words, in the context of a Heyting algebra, the \"inverse\" or \"opposite\" of the top element is the bottom element.",{"type":"∀ {α : Type u_2} [inst : HeytingAlgebra α], ⊤ᶜ = ⊥","name":"compl_top","isProp":true,"docString":"This theorem states that for any type `α` that is a Heyting algebra, the pseudocomplement `⊤ᶜ` of the top element `⊤` is equal to the bottom element `⊥`. In other words, in the context of a Heyting algebra, the \"inverse\" or \"opposite\" of the top element is the bottom element.","distance":0.5074287801908086148472420973121188580989837646484375}],["an arrow ",{"type":"{V : Type u} → [inst : Quiver V] → (self : Quiver.Total V) → self.left ⟶ self.right","name":"Quiver.Total.hom","isProp":false,"docString":"an arrow ","distance":0.431775288617666286317131607574992813169956207275390625}],[" For every element in the additive opposite type of a type α, there exists an element in α mapping to it under the AddOpposite.op function.",{"type":"∀ {α : Type u_1}, Function.Surjective AddOpposite.op","name":"AddOpposite.op_surjective","isProp":true,"docString":" For every element in the additive opposite type of a type α, there exists an element in α mapping to it under the AddOpposite.op function.","distance":0.5245610588960303299899123885552398860454559326171875}],["This theorem states that in category theory, for any category J (of objects `u₁` and morphisms `v₁`), any category C (of objects `u₃` and morphisms `v₃`), any contravariant functor F from J to the opposite category of C, any cone c on the opposite functor of F, and any object j in J, the application of the natural transformation `ι` of the cocone derived from c by `coconeOfConeLeftOp` to the object j is equal to the opposite of the application of the natural transformation `π` of the cone c to the opposite of the object j.",{"type":"∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] {C : Type u₃} [inst_1 : CategoryTheory.Category.{v₃, u₃} C]\n  {F : CategoryTheory.Functor J Cᵒᵖ} (c : CategoryTheory.Limits.Cone F.leftOp) (j : J),\n  (CategoryTheory.Limits.coconeOfConeLeftOp c).ι.app j = (c.π.app (Opposite.op j)).op","name":"CategoryTheory.Limits.coconeOfConeLeftOp_ι_app","isProp":true,"docString":"This theorem states that in category theory, for any category J (of objects `u₁` and morphisms `v₁`), any category C (of objects `u₃` and morphisms `v₃`), any contravariant functor F from J to the opposite category of C, any cone c on the opposite functor of F, and any object j in J, the application of the natural transformation `ι` of the cocone derived from c by `coconeOfConeLeftOp` to the object j is equal to the opposite of the application of the natural transformation `π` of the cone c to the opposite of the object j.","distance":0.5116110181226958264488757777144201099872589111328125}],["compatibility with the composition ",{"type":"∀ {c : Type u → Type u} {hom : ⦃α β : Type u⦄ → c α → c β → Type u} (self : CategoryTheory.BundledHom hom)\n  {α β γ : Type u} (Iα : c α) (Iβ : c β) (Iγ : c γ) (f : hom Iα Iβ) (g : hom Iβ Iγ),\n  CategoryTheory.BundledHom.toFun self Iα Iγ (CategoryTheory.BundledHom.comp self Iα Iβ Iγ g f) =\n    CategoryTheory.BundledHom.toFun self Iβ Iγ g ∘ CategoryTheory.BundledHom.toFun self Iα Iβ f","name":"CategoryTheory.BundledHom.comp_toFun","isProp":true,"docString":"compatibility with the composition ","distance":0.434711588551145278191967236125492490828037261962890625}],["Heyting negation ",{"type":"Lean.ParserDescr","name":"«term￢_»","isProp":false,"docString":"Heyting negation ","distance":0.43549054518917007516876083172974176704883575439453125}],["A choice of wide pushout. ",{"type":"{J : Type w} →\n  {C : Type u} →\n    [inst : CategoryTheory.Category.{v, u} C] →\n      (B : C) →\n        (objs : J → C) →\n          (arrows : (j : J) → B ⟶ objs j) → [inst : CategoryTheory.Limits.HasWidePushout B objs arrows] → C","name":"CategoryTheory.Limits.widePushout","isProp":false,"docString":"A choice of wide pushout. ","distance":0.436732099146297070291211639414541423320770263671875}],["The identity oplax natural transformation. ",{"type":"{B : Type u₁} →\n  [inst : CategoryTheory.Bicategory B] →\n    {C : Type u₂} →\n      [inst_1 : CategoryTheory.Bicategory C] → (F : CategoryTheory.OplaxFunctor B C) → CategoryTheory.OplaxNatTrans F F","name":"CategoryTheory.OplaxNatTrans.id","isProp":false,"docString":"The identity oplax natural transformation. ","distance":0.4375781212071239156813362569664604961872100830078125}],["tensorator ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.MonoidalCategory C] →\n      {D : Type u₂} →\n        [inst_2 : CategoryTheory.Category.{v₂, u₂} D] →\n          [inst_3 : CategoryTheory.MonoidalCategory D] →\n            {F : C → D} →\n              [inst_4 : CategoryTheory.Functorial F] →\n                [self : CategoryTheory.LaxMonoidal F] →\n                  (X Y : C) →\n                    CategoryTheory.MonoidalCategory.tensorObj (F X) (F Y) ⟶\n                      F (CategoryTheory.MonoidalCategory.tensorObj X Y)","name":"CategoryTheory.LaxMonoidal.μ","isProp":false,"docString":"tensorator ","distance":0.43993872969792058302829218519036658108234405517578125}],["Head term ",{"type":"{α : Type u_1} → GeneralizedContinuedFraction α → α","name":"GeneralizedContinuedFraction.h","isProp":false,"docString":"Head term ","distance":0.442248756865821490702472829070757143199443817138671875}],["Left unitor for the vertical composition of oplax natural transformations. ",{"type":"{B : Type u₁} →\n  [inst : CategoryTheory.Bicategory B] →\n    {C : Type u₂} →\n      [inst_1 : CategoryTheory.Bicategory C] →\n        {F G : CategoryTheory.OplaxFunctor B C} →\n          (η : F ⟶ G) → CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id F) η ≅ η","name":"CategoryTheory.OplaxNatTrans.leftUnitor","isProp":false,"docString":"Left unitor for the vertical composition of oplax natural transformations. ","distance":0.4426126362773266098571411930606700479984283447265625}],["The counit of the coalgebra ",{"type":"{R : Type u} →\n  {A : Type v} →\n    [inst : CommSemiring R] →\n      [inst_1 : AddCommMonoid A] → [inst_2 : Module R A] → [self : CoalgebraStruct R A] → A →ₗ[R] R","name":"CoalgebraStruct.counit","isProp":false,"docString":"The counit of the coalgebra ","distance":0.44269679718982180016695338053978048264980316162109375}],["projection expression ",{"type":"Simps.ParsedProjectionData → Option Lean.Expr","name":"Simps.ParsedProjectionData.expr?","isProp":false,"docString":"projection expression ","distance":0.443139934419838954493542360069113783538341522216796875}],["Closure under star. ",{"type":"∀ {S : Type u_1} {R : Type u_2} [inst : Star R] [inst_1 : SetLike S R] [self : StarMemClass S R] {s : S} {r : R},\n  r ∈ s → star r ∈ s","name":"StarMemClass.star_mem","isProp":true,"docString":"Closure under star. ","distance":0.444267801343878832032174841515370644629001617431640625}],["the underlying presieve ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] → {X : C} → CategoryTheory.Sieve X → CategoryTheory.Presieve X","name":"CategoryTheory.Sieve.arrows","isProp":false,"docString":"the underlying presieve ","distance":0.444867215413821792679982536355964839458465576171875}],["an auxiliary type ",{"type":"{I₁ : Type u_6} →\n  {I₂ : Type u_7} →\n    {I₃ : Type u_8} →\n      {J : Type u_9} → {r : I₁ × I₂ × I₃ → J} → CategoryTheory.GradedObject.BifunctorComp₁₂IndexData r → Type u_10","name":"CategoryTheory.GradedObject.BifunctorComp₁₂IndexData.I₁₂","isProp":false,"docString":"an auxiliary type ","distance":0.44492470415491613966452177919563837349414825439453125}],["Left whiskering of an oplax natural transformation and a modification. ",{"type":"{B : Type u₁} →\n  [inst : CategoryTheory.Bicategory B] →\n    {C : Type u₂} →\n      [inst_1 : CategoryTheory.Bicategory C] →\n        {F G H : CategoryTheory.OplaxFunctor B C} →\n          (η : F ⟶ G) →\n            {θ ι : G ⟶ H} → (θ ⟶ ι) → (CategoryTheory.CategoryStruct.comp η θ ⟶ CategoryTheory.CategoryStruct.comp η ι)","name":"CategoryTheory.OplaxNatTrans.whiskerLeft","isProp":false,"docString":"Left whiskering of an oplax natural transformation and a modification. ","distance":0.4459415963330559673494235539692454040050506591796875}],["underlying object ",{"type":"{C : Type uC} →\n  [inst : CategoryTheory.Category.{uC', uC} C] →\n    {W : CategoryTheory.MorphismProperty C} → CategoryTheory.Localization.Construction.LocQuiver W → C","name":"CategoryTheory.Localization.Construction.LocQuiver.obj","isProp":false,"docString":"underlying object ","distance":0.446951901993444977723157762738992460072040557861328125}],["The open upper half plane ",{"type":"Lean.ParserDescr","name":"UpperHalfPlane.termℍ","isProp":false,"docString":"The open upper half plane ","distance":0.449213583101015723197946272193803451955318450927734375}],["The composition of relations ",{"type":"{α : Type ua} → Set (α × α) → Set (α × α) → Set (α × α)","name":"compRel","isProp":false,"docString":"The composition of relations ","distance":0.4493228589417570528752321479259990155696868896484375}],["The addition rule. ",{"type":"∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (self : Projectivization.Subspace K V) (v w : V) (hv : v ≠ 0) (hw : w ≠ 0) (hvw : v + w ≠ 0),\n  Projectivization.mk K v hv ∈ self.carrier →\n    Projectivization.mk K w hw ∈ self.carrier → Projectivization.mk K (v + w) hvw ∈ self.carrier","name":"Projectivization.Subspace.mem_add'","isProp":true,"docString":"The addition rule. ","distance":0.45009937515002584884626912753446958959102630615234375}],["Starting state. ",{"type":"{α : Type u} → {σ : Type v} → DFA α σ → σ","name":"DFA.start","isProp":false,"docString":"Starting state. ","distance":0.45055207248816830922777398882317356765270233154296875}]]