[["The set of good products. ",{"type":"{I : Type u} → [inst : LinearOrder I] → Set (I → Bool) → Set (Profinite.NobelingProof.Products I)","name":"Profinite.NobelingProof.GoodProducts","isProp":false,"docString":"The set of good products. ","distance":0.265459599495806219948690340970642864704132080078125}],[" For any category with binary products, the product of two objects exists.",{"type":"∀ {C : Type u_2} [inst : CategoryTheory.Category.{u_1, u_2} C] [inst_1 : CategoryTheory.Limits.HasBinaryProducts C]\n  (X Y : C), CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair X Y)","name":"CategoryTheory.Limits.prod.functor.proof_1","isProp":true,"docString":" For any category with binary products, the product of two objects exists.","distance":0.388717613565605468739505568009917624294757843017578125}],["This theorem states that any category, denoted by `C`, which has pullbacks and a terminal object, possesses binary products. In the language of category theory, a category has binary products if for any pair of objects in the category, there exists a product object and product morphisms. This product object has the property that for any other object with morphisms to the given pair, there is a unique factorisation through the product. The theorem thus establishes how the existence of certain limit types (pullbacks and terminal objects) in a category guarantees the existence of another limit type (binary products).",{"type":"∀ (C : Type u) [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasTerminal C]\n  [inst_2 : CategoryTheory.Limits.HasPullbacks C], CategoryTheory.Limits.HasBinaryProducts C","name":"hasBinaryProducts_of_hasTerminal_and_pullbacks","isProp":true,"docString":"This theorem states that any category, denoted by `C`, which has pullbacks and a terminal object, possesses binary products. In the language of category theory, a category has binary products if for any pair of objects in the category, there exists a product object and product morphisms. This product object has the property that for any other object with morphisms to the given pair, there is a unique factorisation through the product. The theorem thus establishes how the existence of certain limit types (pullbacks and terminal objects) in a category guarantees the existence of another limit type (binary products).","distance":0.41766850474735195408726440291502512991428375244140625}],["Notation for the product ",{"type":"Lean.TrailingParserDescr","name":"CategoryTheory.Limits.«term_⨯_»","isProp":false,"docString":"Notation for the product ","distance":0.28066995298037744621666433886275626718997955322265625}],[" A product set in a product space is open if and only if both factors are open or one of them is empty.",{"type":"∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {s : Set X} {t : Set Y},\n  IsOpen (s ×ˢ t) ↔ IsOpen s ∧ IsOpen t ∨ s = ∅ ∨ t = ∅","name":"isOpen_prod_iff'","isProp":true,"docString":" A product set in a product space is open if and only if both factors are open or one of them is empty.","distance":0.410222458012918067549179568231920711696147918701171875}],["This theorem states that if a category has all products, it necessarily has finite products as well. In other words, given a category 'C', if for every type 'J', the category 'C' has limits of shape 'Discrete J' (which essentially means the category has all products), then the category 'C' also has finite products. This is part of the larger field of category theory in mathematics, which is particularly useful in areas like algebra and topology.",{"type":"∀ (C : Type u) [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasProducts C],\n  CategoryTheory.Limits.HasFiniteProducts C","name":"CategoryTheory.Limits.hasFiniteProducts_of_hasProducts","isProp":true,"docString":"This theorem states that if a category has all products, it necessarily has finite products as well. In other words, given a category 'C', if for every type 'J', the category 'C' has limits of shape 'Discrete J' (which essentially means the category has all products), then the category 'C' also has finite products. This is part of the larger field of category theory in mathematics, which is particularly useful in areas like algebra and topology.","distance":0.4192461090861383521399829987785778939723968505859375}],["Evaluation of good products. ",{"type":"{I : Type u} →\n  [inst : LinearOrder I] →\n    (C : Set (I → Bool)) → { l // Profinite.NobelingProof.Products.isGood C l } → LocallyConstant ↑C ℤ","name":"Profinite.NobelingProof.GoodProducts.eval","isProp":false,"docString":"Evaluation of good products. ","distance":0.288341366144102051460862412568530999124050140380859375}],["The type of good products is equivalent to its image. ",{"type":"{I : Type u} →\n  [inst : LinearOrder I] →\n    (C : Set (I → Bool)) → ↑(Profinite.NobelingProof.GoodProducts C) ≃ ↑(Profinite.NobelingProof.GoodProducts.range C)","name":"Profinite.NobelingProof.GoodProducts.equiv_range","isProp":false,"docString":"The type of good products is equivalent to its image. ","distance":0.291825525631733473375106768799014389514923095703125}],["The product is the pullback over the terminal object. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {W X Y Z : C} →\n      (f : X ⟶ Z) →\n        (g : Y ⟶ Z) →\n          (h : W ⟶ X) →\n            (k : W ⟶ Y) →\n              (H₁ : CategoryTheory.Limits.IsTerminal Z) →\n                CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.BinaryFan.mk h k) →\n                  CategoryTheory.Limits.IsLimit\n                    (CategoryTheory.Limits.PullbackCone.mk h k\n                      (_ : CategoryTheory.CategoryStruct.comp h f = CategoryTheory.CategoryStruct.comp k g))","name":"isPullbackOfIsTerminalIsProduct","isProp":false,"docString":"The product is the pullback over the terminal object. ","distance":0.292090018402043460898909188472316600382328033447265625}],["The first projection from the product. ",{"type":"{X Y : TopCat} → TopCat.of (↑X × ↑Y) ⟶ X","name":"TopCat.prodFst","isProp":false,"docString":"The first projection from the product. ","distance":0.295216459231983308075797367564518935978412628173828125}],["introduce a product where both components are the same ",{"type":"{n : ℕ} → {α : TypeVec.{u} n} → TypeVec.Arrow α (TypeVec.prod α α)","name":"TypeVec.prod.diag","isProp":false,"docString":"introduce a product where both components are the same ","distance":0.29780562337192428845611402721260674297809600830078125}],["Lexicographical order for products ",{"type":"{α : Type u_1} → {β : Type u_2} → [inst : LT α] → [inst : LT β] → α × β → α × β → Prop","name":"Prod.lexLt","isProp":false,"docString":"Lexicographical order for products ","distance":0.298698510899672420304540310098673216998577117919921875}],["The product of two two-pointings. ",{"type":"{α : Type u_1} → {β : Type u_2} → TwoPointing α → TwoPointing β → TwoPointing (α × β)","name":"TwoPointing.prod","isProp":false,"docString":"The product of two two-pointings. ","distance":0.29935410469546230860515834137913770973682403564453125}],["The product cone induced by the concrete product. ",{"type":"{R : Type u} → [inst : Ring R] → {ι : Type v} → (Z : ι → ModuleCatMax R) → CategoryTheory.Limits.Fan Z","name":"ModuleCat.productCone","isProp":false,"docString":"The product cone induced by the concrete product. ","distance":0.299407629166738631365518585880636237561702728271484375}],["Products of completions ",{"type":"{α : Type u_1} →\n  [inst : UniformSpace α] →\n    AbstractCompletion α →\n      {β : Type u_2} → [inst_1 : UniformSpace β] → AbstractCompletion β → AbstractCompletion (α × β)","name":"AbstractCompletion.prod","isProp":false,"docString":"Products of completions ","distance":0.29967537049292525264121422878815792500972747802734375}],["The product of the factors is the original number ",{"type":"∀ (n : ℕ+), PrimeMultiset.prod (PNat.factorMultiset n) = n","name":"PNat.prod_factorMultiset","isProp":true,"docString":"The product of the factors is the original number ","distance":0.2999268071822884795807340196915902197360992431640625}],["Delaborator for simple product projections. ",{"type":"Lean.PrettyPrinter.Delaborator.Delab","name":"delabProdProjs","isProp":false,"docString":"Delaborator for simple product projections. ","distance":0.304299543845828635024730601799092255532741546630859375}],["A limit can be realised as a subobject of a product. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {J : Type w} →\n      [inst_1 : CategoryTheory.SmallCategory J] →\n        [inst_2 : CategoryTheory.Limits.HasLimitsOfSize.{w, w, v, u} C] →\n          (F : CategoryTheory.Functor J C) → CategoryTheory.Limits.limit F ⟶ ∏ fun j => F.obj j","name":"CategoryTheory.Limits.limitSubobjectProduct","isProp":false,"docString":"A limit can be realised as a subobject of a product. ","distance":0.3116993224561122044491412452771328389644622802734375}],["The product of a family of types over a list. ",{"type":"{ι : Type u} → (ι → Type v) → List ι → Type v","name":"List.TProd","isProp":false,"docString":"The product of a family of types over a list. ","distance":0.314004182350447413885063951966003514826297760009765625}],["A product of distinguished triangles is distinguished ",{"type":"∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.HasShift C ℤ] [inst_3 : CategoryTheory.Preadditive C]\n  [inst_4 : ∀ (n : ℤ), CategoryTheory.Functor.Additive (CategoryTheory.shiftFunctor C n)]\n  [hC : CategoryTheory.Pretriangulated C] {J : Type u_1} (T : J → CategoryTheory.Pretriangulated.Triangle C),\n  (∀ (j : J), T j ∈ CategoryTheory.Pretriangulated.distinguishedTriangles) →\n    ∀ [inst_5 : CategoryTheory.Limits.HasProduct fun j => (T j).obj₁]\n      [inst_6 : CategoryTheory.Limits.HasProduct fun j => (T j).obj₂]\n      [inst_7 : CategoryTheory.Limits.HasProduct fun j => (T j).obj₃]\n      [inst_8 : CategoryTheory.Limits.HasProduct fun j => (CategoryTheory.shiftFunctor C 1).obj (T j).obj₁],\n      CategoryTheory.Pretriangulated.productTriangle T ∈ CategoryTheory.Pretriangulated.distinguishedTriangles","name":"CategoryTheory.Pretriangulated.productTriangle_distinguished","isProp":true,"docString":"A product of distinguished triangles is distinguished ","distance":0.31542060327841248135172236288781277835369110107421875}],["Type product is associative up to an equivalence. ",{"type":"(α : Type u_1) → (β : Type u_2) → (γ : Type u_3) → (α × β) × γ ≃ α × β × γ","name":"Equiv.prodAssoc","isProp":false,"docString":"Type product is associative up to an equivalence. ","distance":0.315430708023030581532708538361475802958011627197265625}],["A product is regular if and only if the factors are. ",{"type":"∀ {R : Type u_1} [inst : CommSemigroup R] {a b : R}, IsRegular (a * b) ↔ IsRegular a ∧ IsRegular b","name":"isRegular_mul_iff","isProp":true,"docString":"A product is regular if and only if the factors are. ","distance":0.316260045235405129471217833270202390849590301513671875}],["The first projection of a product, as a smooth map. ",{"type":"{𝕜 : Type u_1} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {E : Type u_2} →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : NormedSpace 𝕜 E] →\n          {E' : Type u_3} →\n            [inst_3 : NormedAddCommGroup E'] →\n              [inst_4 : NormedSpace 𝕜 E'] →\n                {H : Type u_4} →\n                  [inst_5 : TopologicalSpace H] →\n                    {H' : Type u_5} →\n                      [inst_6 : TopologicalSpace H'] →\n                        {I : ModelWithCorners 𝕜 E H} →\n                          {I' : ModelWithCorners 𝕜 E' H'} →\n                            {M : Type u_6} →\n                              [inst_7 : TopologicalSpace M] →\n                                [inst_8 : ChartedSpace H M] →\n                                  {M' : Type u_7} →\n                                    [inst_9 : TopologicalSpace M'] →\n                                      [inst_10 : ChartedSpace H' M'] →\n                                        {n : ℕ∞} → ContMDiffMap (ModelWithCorners.prod I I') I (M × M') M n","name":"ContMDiffMap.fst","isProp":false,"docString":"The first projection of a product, as a smooth map. ","distance":0.318939207744102615205150641486397944390773773193359375}],["the image of a product is less or equal than the product of the images. ",{"type":"∀ {F : Type u_7} {α : outParam (Type u_8)} {β : outParam (Type u_9)} [inst : NonUnitalNonAssocRing α]\n  [inst_1 : OrderedSemiring β] [self : RingSeminormClass F α β] (f : F) (a b : α), f (a * b) ≤ f a * f b","name":"RingSeminormClass.map_mul_le_mul","isProp":true,"docString":"the image of a product is less or equal than the product of the images. ","distance":0.319881099156424875129545171148492954671382904052734375}]]