[["Delaborator for simple product projections. ",{"type":"Lean.PrettyPrinter.Delaborator.Delab","name":"delabProdProjs","isProp":false,"docString":"Delaborator for simple product projections. ","distance":0.347413247766718280562514564735465683043003082275390625}],[" For any category with binary products, the product of two objects exists.",{"type":"âˆ€ {C : Type u_2} [inst : CategoryTheory.Category.{u_1, u_2} C] [inst_1 : CategoryTheory.Limits.HasBinaryProducts C]\n  (X Y : C), CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair X Y)","name":"CategoryTheory.Limits.prod.functor.proof_1","isProp":true,"docString":" For any category with binary products, the product of two objects exists.","distance":0.495081931244093553790008854775805957615375518798828125}],["This theorem, which is a part of Profinite's NobelingProof, asserts the following: for any type `I` equipped with a linear order, a set `C` of Boolean-valued functions on `I`, a product `l` of elements from `I`, and a predicate `J` on `I`, if every element `a` in the product `l` satisfies the predicate `J`, then for any `j` in `I` that can be decided by `J`, the composition of the evaluation of `l` under the image of `Proj Ï€ J` with the restriction of `Proj Ï€ J` to `C`, is equal to the evaluation of `l` under `C`. \n\nIn simple terms, this theorem shows a relationship between the evaluation of a product under a set of functions and its projection restricted to a subset, assuming that all elements of the product satisfy a certain property. The mathematical operations involved are function composition and evaluation.",{"type":"âˆ€ {I : Type u} [inst : LinearOrder I] (C : Set (I â†’ Bool)) {l : Profinite.NobelingProof.Products I} (J : I â†’ Prop),\n  (âˆ€ a âˆˆ â†‘l, J a) â†’\n    âˆ€ [inst_1 : (j : I) â†’ Decidable (J j)],\n      â‡‘(Profinite.NobelingProof.Products.eval (Profinite.NobelingProof.Ï€ C J) l) âˆ˜\n          Profinite.NobelingProof.ProjRestrict C J =\n        â‡‘(Profinite.NobelingProof.Products.eval C l)","name":"Profinite.NobelingProof.Products.evalFacProp","isProp":true,"docString":"This theorem, which is a part of Profinite's NobelingProof, asserts the following: for any type `I` equipped with a linear order, a set `C` of Boolean-valued functions on `I`, a product `l` of elements from `I`, and a predicate `J` on `I`, if every element `a` in the product `l` satisfies the predicate `J`, then for any `j` in `I` that can be decided by `J`, the composition of the evaluation of `l` under the image of `Proj Ï€ J` with the restriction of `Proj Ï€ J` to `C`, is equal to the evaluation of `l` under `C`. \n\nIn simple terms, this theorem shows a relationship between the evaluation of a product under a set of functions and its projection restricted to a subset, assuming that all elements of the product satisfy a certain property. The mathematical operations involved are function composition and evaluation.","distance":0.466539673487106398841461896154214628040790557861328125}],["The first projection from the product. ",{"type":"{X Y : TopCat} â†’ TopCat.of (â†‘X Ã— â†‘Y) âŸ¶ X","name":"TopCat.prodFst","isProp":false,"docString":"The first projection from the product. ","distance":0.3803033138289981796020811088965274393558502197265625}],[" For any group with division and inversion, the action of an element on another element is equal to their conjugation, that is, the product of the element, the second element, and the inverse of the first element.",{"type":"âˆ€ {G : Type u_3} [inst : DivInvMonoid G] (g : ConjAct G) (h : G),\n  g â€¢ h = ConjAct.ofConjAct g * h * (ConjAct.ofConjAct g)â»Â¹","name":"ConjAct.smul_def","isProp":true,"docString":" For any group with division and inversion, the action of an element on another element is equal to their conjugation, that is, the product of the element, the second element, and the inverse of the first element.","distance":0.49870663910808266106045039123273454606533050537109375}],["This theorem, termed as the \"projection formula\" for Frobenius and Verschiebung, states that for any natural number 'p' which is prime, any type 'R' that forms a commutative ring, and any two Witt vectors 'x' and 'y' of type 'R' with 'p' coefficients, the Verschiebung (which shifts coefficients upwards by one) of the product of 'x' and the Frobenius (which raises each coefficient to the power 'p') of 'y' is equal to the product of the Verschiebung of 'x' and 'y'. In other words, Verschiebung and Frobenius operations distribute over multiplication in Witt vectors.",{"type":"âˆ€ {p : â„•} {R : Type u_1} [hp : Fact p.Prime] [inst : CommRing R] (x y : WittVector p R),\n  WittVector.verschiebung (x * WittVector.frobenius y) = WittVector.verschiebung x * y","name":"WittVector.verschiebung_mul_frobenius","isProp":true,"docString":"This theorem, termed as the \"projection formula\" for Frobenius and Verschiebung, states that for any natural number 'p' which is prime, any type 'R' that forms a commutative ring, and any two Witt vectors 'x' and 'y' of type 'R' with 'p' coefficients, the Verschiebung (which shifts coefficients upwards by one) of the product of 'x' and the Frobenius (which raises each coefficient to the power 'p') of 'y' is equal to the product of the Verschiebung of 'x' and 'y'. In other words, Verschiebung and Frobenius operations distribute over multiplication in Witt vectors.","distance":0.46846122523410105298324879186111502349376678466796875}],["Notation for the product ",{"type":"Lean.TrailingParserDescr","name":"CategoryTheory.Limits.Â«term_â¨¯_Â»","isProp":false,"docString":"Notation for the product ","distance":0.385324888719692448812992324747028760612010955810546875}],["constructor for `prod` ",{"type":"{n : â„•} â†’ {Î± Î² : TypeVec.{u} n} â†’ (i : Fin2 n) â†’ Î± i â†’ Î² i â†’ TypeVec.prod Î± Î² i","name":"TypeVec.prod.mk","isProp":false,"docString":"constructor for `prod` ","distance":0.385775062558255388278638520205277018249034881591796875}],["The program. ",{"type":"{Î“ : Type u_1} â†’\n  {Î› : Type u_2} â†’\n    [inst : Inhabited Î›] â†’ Turing.TM0.Machine Î“ Î› â†’ Turing.TM0to1.Î›' â†’ Turing.TM1.Stmt Î“ Turing.TM0to1.Î›' Unit","name":"Turing.TM0to1.tr","isProp":false,"docString":"The program. ","distance":0.38746613410412422684458988442202098667621612548828125}],["The property of preserving products expressed in terms of fans. ",{"type":"{C : Type uâ‚} â†’\n  [inst : CategoryTheory.Category.{vâ‚, uâ‚} C] â†’\n    {D : Type uâ‚‚} â†’\n      [inst_1 : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D] â†’\n        (G : CategoryTheory.Functor C D) â†’\n          {J : Type w} â†’\n            (f : J â†’ C) â†’\n              [inst_2 : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Discrete.functor f) G] â†’\n                {P : C} â†’\n                  (g : (j : J) â†’ P âŸ¶ f j) â†’\n                    CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.Fan.mk P g) â†’\n                      CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.Fan.mk (G.obj P) fun j => G.map (g j))","name":"CategoryTheory.Limits.isLimitFanMkObjOfIsLimit","isProp":false,"docString":"The property of preserving products expressed in terms of fans. ","distance":0.38833534135780922724734409712255001068115234375}],["The coproduct is the pushout under the initial object. ",{"type":"{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    {W X Y Z : C} â†’\n      (f : X âŸ¶ Z) â†’\n        (g : Y âŸ¶ Z) â†’\n          (h : W âŸ¶ X) â†’\n            (k : W âŸ¶ Y) â†’\n              (Hâ‚ : CategoryTheory.Limits.IsInitial W) â†’\n                CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.BinaryCofan.mk f g) â†’\n                  CategoryTheory.Limits.IsColimit\n                    (CategoryTheory.Limits.PushoutCocone.mk f g\n                      (_ : CategoryTheory.CategoryStruct.comp h f = CategoryTheory.CategoryStruct.comp k g))","name":"isPushoutOfIsInitialIsCoproduct","isProp":false,"docString":"The coproduct is the pushout under the initial object. ","distance":0.390814141456631680693334374154801480472087860107421875}],["The composition-product of a measure and a kernel. ",{"type":"Lean.TrailingParserDescr","name":"ProbabilityTheory.Â«term_âŠ—â‚˜_Â»","isProp":false,"docString":"The composition-product of a measure and a kernel. ","distance":0.390832683002257763593689787740004248917102813720703125}],["The map from the coproduct into the pushout ",{"type":"{Î¹ : Type u_1} â†’\n  {G : Î¹ â†’ Type u_2} â†’\n    {H : Type u_3} â†’\n      [inst : (i : Î¹) â†’ Monoid (G i)] â†’\n        [inst_1 : Monoid H] â†’ {Ï† : (i : Î¹) â†’ H â†’* G i} â†’ Monoid.CoprodI G â†’* Monoid.PushoutI Ï†","name":"Monoid.PushoutI.ofCoprodI","isProp":false,"docString":"The map from the coproduct into the pushout ","distance":0.392360303647306174479325591164524666965007781982421875}],["The composition of relations ",{"type":"{Î± : Type ua} â†’ Set (Î± Ã— Î±) â†’ Set (Î± Ã— Î±) â†’ Set (Î± Ã— Î±)","name":"compRel","isProp":false,"docString":"The composition of relations ","distance":0.392504190290064947088666258423472754657268524169921875}],["The product of the factors is the original number ",{"type":"âˆ€ (n : â„•+), PrimeMultiset.prod (PNat.factorMultiset n) = n","name":"PNat.prod_factorMultiset","isProp":true,"docString":"The product of the factors is the original number ","distance":0.394391514526109931981778800036408938467502593994140625}],["projection expression ",{"type":"Simps.ParsedProjectionData â†’ Option Lean.Expr","name":"Simps.ParsedProjectionData.expr?","isProp":false,"docString":"projection expression ","distance":0.3956846342041451247695249548996798694133758544921875}],["The first projection of a product, as a smooth map. ",{"type":"{ğ•œ : Type u_1} â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    {E : Type u_2} â†’\n      [inst_1 : NormedAddCommGroup E] â†’\n        [inst_2 : NormedSpace ğ•œ E] â†’\n          {E' : Type u_3} â†’\n            [inst_3 : NormedAddCommGroup E'] â†’\n              [inst_4 : NormedSpace ğ•œ E'] â†’\n                {H : Type u_4} â†’\n                  [inst_5 : TopologicalSpace H] â†’\n                    {H' : Type u_5} â†’\n                      [inst_6 : TopologicalSpace H'] â†’\n                        {I : ModelWithCorners ğ•œ E H} â†’\n                          {I' : ModelWithCorners ğ•œ E' H'} â†’\n                            {M : Type u_6} â†’\n                              [inst_7 : TopologicalSpace M] â†’\n                                [inst_8 : ChartedSpace H M] â†’\n                                  {M' : Type u_7} â†’\n                                    [inst_9 : TopologicalSpace M'] â†’\n                                      [inst_10 : ChartedSpace H' M'] â†’\n                                        {n : â„•âˆ} â†’ ContMDiffMap (ModelWithCorners.prod I I') I (M Ã— M') M n","name":"ContMDiffMap.fst","isProp":false,"docString":"The first projection of a product, as a smooth map. ","distance":0.395755151648204794856411581349675543606281280517578125}],["The set of good products. ",{"type":"{I : Type u} â†’ [inst : LinearOrder I] â†’ Set (I â†’ Bool) â†’ Set (Profinite.NobelingProof.Products I)","name":"Profinite.NobelingProof.GoodProducts","isProp":false,"docString":"The set of good products. ","distance":0.396284554358561968978591494305874221026897430419921875}],["Tensor products distribute over a product on the left . ",{"type":"(R : Type uR) â†’\n  (Mâ‚ : Type uMâ‚) â†’\n    (Mâ‚‚ : Type uMâ‚‚) â†’\n      (Mâ‚ƒ : Type uMâ‚ƒ) â†’\n        [inst : CommSemiring R] â†’\n          [inst_1 : AddCommMonoid Mâ‚] â†’\n            [inst_2 : AddCommMonoid Mâ‚‚] â†’\n              [inst_3 : AddCommMonoid Mâ‚ƒ] â†’\n                [inst_4 : Module R Mâ‚] â†’\n                  [inst_5 : Module R Mâ‚‚] â†’\n                    [inst_6 : Module R Mâ‚ƒ] â†’\n                      TensorProduct R (Mâ‚ Ã— Mâ‚‚) Mâ‚ƒ â‰ƒâ‚—[R] TensorProduct R Mâ‚ Mâ‚ƒ Ã— TensorProduct R Mâ‚‚ Mâ‚ƒ","name":"TensorProduct.prodLeft","isProp":false,"docString":"Tensor products distribute over a product on the left . ","distance":0.39636462132260741331180042834603227674961090087890625}],["Products of completions ",{"type":"{Î± : Type u_1} â†’\n  [inst : UniformSpace Î±] â†’\n    AbstractCompletion Î± â†’\n      {Î² : Type u_2} â†’ [inst_1 : UniformSpace Î²] â†’ AbstractCompletion Î² â†’ AbstractCompletion (Î± Ã— Î²)","name":"AbstractCompletion.prod","isProp":false,"docString":"Products of completions ","distance":0.39733156628816435063100698243943043053150177001953125}],["The second projection from the product. ",{"type":"{X Y : TopCat} â†’ TopCat.of (â†‘X Ã— â†‘Y) âŸ¶ Y","name":"TopCat.prodSnd","isProp":false,"docString":"The second projection from the product. ","distance":0.397406182560621268340383949180250056087970733642578125}],["The relation we quotient by to form the pushout ",{"type":"{Î¹ : Type u_1} â†’\n  {G : Î¹ â†’ Type u_2} â†’\n    {H : Type u_3} â†’\n      [inst : (i : Î¹) â†’ Monoid (G i)] â†’\n        [inst_1 : Monoid H] â†’ ((i : Î¹) â†’ H â†’* G i) â†’ Con (Monoid.Coprod (Monoid.CoprodI G) H)","name":"Monoid.PushoutI.con","isProp":false,"docString":"The relation we quotient by to form the pushout ","distance":0.39743154562375415661534816536004655063152313232421875}],["representation function for dependent products ",{"type":"{n : â„•} â†’\n  {A : Type u} â†’\n    (F : A â†’ TypeVec.{u} n â†’ Type u) â†’\n      [inst : (Î± : A) â†’ MvFunctor (F Î±)] â†’\n        [inst_1 : (Î± : A) â†’ MvQPF (F Î±)] â†’ â¦ƒÎ± : TypeVec.{u} nâ¦„ â†’ MvQPF.Pi F Î± â†’ â†‘(MvQPF.Pi.P F) Î±","name":"MvQPF.Pi.repr","isProp":false,"docString":"representation function for dependent products ","distance":0.399990349131358502443589486574637703597545623779296875}],["Function value ",{"type":"Lean.TrailingParserDescr","name":"Class.Â«term_â€²_Â»","isProp":false,"docString":"Function value ","distance":0.4002211269035347296352256307727657258510589599609375}]]