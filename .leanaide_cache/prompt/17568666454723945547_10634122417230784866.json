[["The finset of those partitions in which every part is odd. ",{"type":"(n : ℕ) → Finset (Nat.Partition n)","name":"Nat.Partition.odds","isProp":false,"docString":"The finset of those partitions in which every part is odd. ","distance":0.376700325282345482857948582022800110280513763427734375}],[" A natural number is odd if and only if it is not even, or equivalently, a natural number is odd if and only if it can be expressed as 2 times an integer plus one, while an even number can be expressed as the sum of two integers.",{"type":"∀ {n : ℕ}, Odd n ↔ ¬Even n","name":"Nat.odd_iff_not_even","isProp":true,"docString":" A natural number is odd if and only if it is not even, or equivalently, a natural number is odd if and only if it can be expressed as 2 times an integer plus one, while an even number can be expressed as the sum of two integers.","distance":0.438308822666078901075792373376316390931606292724609375}],["This theorem states that a natural number is odd if and only if its remainder when divided by 4 is either 1 or 3. In other words, it characterizes odd numbers in terms of their residues modulo 4.",{"type":"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3","name":"Nat.odd_mod_four_iff","isProp":true,"docString":"This theorem states that a natural number is odd if and only if its remainder when divided by 4 is either 1 or 3. In other words, it characterizes odd numbers in terms of their residues modulo 4.","distance":0.422104749531043876853431129347882233560085296630859375}],["The addition rule. ",{"type":"∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (self : Projectivization.Subspace K V) (v w : V) (hv : v ≠ 0) (hw : w ≠ 0) (hvw : v + w ≠ 0),\n  Projectivization.mk K v hv ∈ self.carrier →\n    Projectivization.mk K w hw ∈ self.carrier → Projectivization.mk K (v + w) hvw ∈ self.carrier","name":"Projectivization.Subspace.mem_add'","isProp":true,"docString":"The addition rule. ","distance":0.376859356390333799513570056660682894289493560791015625}],[" A natural number is odd if and only if its residue modulo 4 is 1 or 3.",{"type":"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3","name":"Nat.odd_mod_four_iff","isProp":true,"docString":" A natural number is odd if and only if its residue modulo 4 is 1 or 3.","distance":0.439408512173075693763024673899053595960140228271484375}],["This theorem states that for every natural number `n`, `n` being odd is equivalent to `n` not being even. In other words, a natural number is odd if and only if it is not even. Here, a number is considered odd if it can be expressed as `2*k + 1` for some `k`, and a number is considered even if it can be written as `r + r` for some `r`.",{"type":"∀ {n : ℕ}, Odd n ↔ ¬Even n","name":"Nat.odd_iff_not_even","isProp":true,"docString":"This theorem states that for every natural number `n`, `n` being odd is equivalent to `n` not being even. In other words, a natural number is odd if and only if it is not even. Here, a number is considered odd if it can be expressed as `2*k + 1` for some `k`, and a number is considered even if it can be written as `r + r` for some `r`.","distance":0.441500761627791116215036026915186084806919097900390625}],["Boolean exclusive or ",{"type":"Bool → Bool → Bool","name":"Bool.xor","isProp":false,"docString":"Boolean exclusive or ","distance":0.38260111955609177325499103972106240689754486083984375}],["Heyting negation ",{"type":"Lean.ParserDescr","name":"«term￢_»","isProp":false,"docString":"Heyting negation ","distance":0.382634428335413112609586505641345866024494171142578125}],["addition commutes ",{"type":"∀ {M : Type u_1} [inst : Add M] {z : M}, IsAddCentral z → ∀ (a : M), z + a = a + z","name":"IsAddCentral.comm","isProp":true,"docString":"addition commutes ","distance":0.382986757984570658219780625586281530559062957763671875}],["There is a splitting ",{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X Y : C} {f : X ⟶ Y} [self : CategoryTheory.IsSplitEpi f],\n  Nonempty (CategoryTheory.SplitEpi f)","name":"CategoryTheory.IsSplitEpi.exists_splitEpi","isProp":true,"docString":"There is a splitting ","distance":0.38419583057069461862198522794642485678195953369140625}],["A choice of wide pushout. ",{"type":"{J : Type w} →\n  {C : Type u} →\n    [inst : CategoryTheory.Category.{v, u} C] →\n      (B : C) →\n        (objs : J → C) →\n          (arrows : (j : J) → B ⟶ objs j) → [inst : CategoryTheory.Limits.HasWidePushout B objs arrows] → C","name":"CategoryTheory.Limits.widePushout","isProp":false,"docString":"A choice of wide pushout. ","distance":0.38431321707469801030043754508369602262973785400390625}],["the zeroth row ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] → CategoryTheory.ShortComplex.SnakeInput C → CategoryTheory.ShortComplex C","name":"CategoryTheory.ShortComplex.SnakeInput.L₀","isProp":false,"docString":"the zeroth row ","distance":0.388824852649990837516469355250592343509197235107421875}],["the distinguished element ",{"type":"(self : Pointed) → self.X","name":"Pointed.point","isProp":false,"docString":"the distinguished element ","distance":0.389468798834498530769820945351966656744480133056640625}],["The negative part function. ",{"type":"{α : Type u_1} → [self : NegPart α] → α → α","name":"NegPart.neg","isProp":false,"docString":"The negative part function. ","distance":0.389672105994804340856063618048210628330707550048828125}],["an arrow ",{"type":"{V : Type u} → [inst : Quiver V] → (self : Quiver.Total V) → self.left ⟶ self.right","name":"Quiver.Total.hom","isProp":false,"docString":"an arrow ","distance":0.390201858642797827503301277829450555145740509033203125}],["Negation of games. ",{"type":"SetTheory.Game → SetTheory.Game","name":"SetTheory.Game.neg","isProp":false,"docString":"Negation of games. ","distance":0.390342008405480778154839072158210910856723785400390625}],["the second row ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] → CategoryTheory.ShortComplex.SnakeInput C → CategoryTheory.ShortComplex C","name":"CategoryTheory.ShortComplex.SnakeInput.L₂","isProp":false,"docString":"the second row ","distance":0.39049230777991017493633307822165079414844512939453125}],["for every pair of objects there exists another object \"to the right\" ",{"type":"∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [self : CategoryTheory.IsFilteredOrEmpty C] (X Y : C),\n  ∃ Z x x, True","name":"CategoryTheory.IsFilteredOrEmpty.cocone_objs","isProp":true,"docString":"for every pair of objects there exists another object \"to the right\" ","distance":0.390557698206099812576752583481720648705959320068359375}],["compatibility with the left addition with 0 ",{"type":"∀ {C : Type u} {A : Type u_1} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : AddMonoid A]\n  (self : CategoryTheory.ShiftMkCore C A) (n : A) (X : C),\n  (CategoryTheory.ShiftMkCore.add self 0 n).hom.app X =\n    CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.eqToHom\n        (_ :\n          (CategoryTheory.ShiftMkCore.F self (0 + n)).obj X =\n            (CategoryTheory.ShiftMkCore.F self n).obj ((CategoryTheory.Functor.id C).obj X)))\n      ((CategoryTheory.ShiftMkCore.F self n).map (self.zero.inv.app X))","name":"CategoryTheory.ShiftMkCore.zero_add_hom_app","isProp":true,"docString":"compatibility with the left addition with 0 ","distance":0.390629903217882656907278260405291803181171417236328125}],["the axiom of choice ",{"type":"∀ {α : Sort u} {β : α → Sort v} {r : (x : α) → β x → Prop}, (∀ (x : α), ∃ y, r x y) → ∃ f, ∀ (x : α), r x (f x)","name":"Classical.axiomOfChoice","isProp":true,"docString":"the axiom of choice ","distance":0.392565907376668465911251360012101940810680389404296875}],["the morphism on the right objects ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_3, u_1} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      {S₁ S₂ : CategoryTheory.ShortComplex C} → CategoryTheory.ShortComplex.Hom S₁ S₂ → (S₁.X₃ ⟶ S₂.X₃)","name":"CategoryTheory.ShortComplex.Hom.τ₃","isProp":false,"docString":"the morphism on the right objects ","distance":0.393832924099795478323216002536355517804622650146484375}],["the third row ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] → CategoryTheory.ShortComplex.SnakeInput C → CategoryTheory.ShortComplex C","name":"CategoryTheory.ShortComplex.SnakeInput.L₃","isProp":false,"docString":"the third row ","distance":0.39404268570122791270904372140648774802684783935546875}],["The empty word ",{"type":"{G : Type u_1} →\n  [inst : Group G] →\n    {A B : Subgroup G} → {d : HNNExtension.NormalWord.TransversalPair G A B} → HNNExtension.NormalWord d","name":"HNNExtension.NormalWord.empty","isProp":false,"docString":"The empty word ","distance":0.394093814318818402853139559738337993621826171875}],["The empty set is meagre. ",{"type":"∀ {X : Type u_5} [inst : TopologicalSpace X], IsMeagre ∅","name":"meagre_empty","isProp":true,"docString":"The empty set is meagre. ","distance":0.394201079795751530010505803147680126130580902099609375}]]