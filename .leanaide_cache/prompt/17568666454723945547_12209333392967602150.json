[["The set of good products. ",{"type":"{I : Type u} → [inst : LinearOrder I] → Set (I → Bool) → Set (Profinite.NobelingProof.Products I)","name":"Profinite.NobelingProof.GoodProducts","isProp":false,"docString":"The set of good products. ","distance":0.279498761375946147555993093192228116095066070556640625}],[" For any category with binary products, the product of two objects exists.",{"type":"∀ {C : Type u_2} [inst : CategoryTheory.Category.{u_1, u_2} C] [inst_1 : CategoryTheory.Limits.HasBinaryProducts C]\n  (X Y : C), CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair X Y)","name":"CategoryTheory.Limits.prod.functor.proof_1","isProp":true,"docString":" For any category with binary products, the product of two objects exists.","distance":0.402245254815709440965321164185297675430774688720703125}],["This theorem, which is a part of Profinite's NobelingProof, asserts the following: for any type `I` equipped with a linear order, a set `C` of Boolean-valued functions on `I`, a product `l` of elements from `I`, and a predicate `J` on `I`, if every element `a` in the product `l` satisfies the predicate `J`, then for any `j` in `I` that can be decided by `J`, the composition of the evaluation of `l` under the image of `Proj π J` with the restriction of `Proj π J` to `C`, is equal to the evaluation of `l` under `C`. \n\nIn simple terms, this theorem shows a relationship between the evaluation of a product under a set of functions and its projection restricted to a subset, assuming that all elements of the product satisfy a certain property. The mathematical operations involved are function composition and evaluation.",{"type":"∀ {I : Type u} [inst : LinearOrder I] (C : Set (I → Bool)) {l : Profinite.NobelingProof.Products I} (J : I → Prop),\n  (∀ a ∈ ↑l, J a) →\n    ∀ [inst_1 : (j : I) → Decidable (J j)],\n      ⇑(Profinite.NobelingProof.Products.eval (Profinite.NobelingProof.π C J) l) ∘\n          Profinite.NobelingProof.ProjRestrict C J =\n        ⇑(Profinite.NobelingProof.Products.eval C l)","name":"Profinite.NobelingProof.Products.evalFacProp","isProp":true,"docString":"This theorem, which is a part of Profinite's NobelingProof, asserts the following: for any type `I` equipped with a linear order, a set `C` of Boolean-valued functions on `I`, a product `l` of elements from `I`, and a predicate `J` on `I`, if every element `a` in the product `l` satisfies the predicate `J`, then for any `j` in `I` that can be decided by `J`, the composition of the evaluation of `l` under the image of `Proj π J` with the restriction of `Proj π J` to `C`, is equal to the evaluation of `l` under `C`. \n\nIn simple terms, this theorem shows a relationship between the evaluation of a product under a set of functions and its projection restricted to a subset, assuming that all elements of the product satisfy a certain property. The mathematical operations involved are function composition and evaluation.","distance":0.41029726636665631023248579367646016180515289306640625}],["Evaluation of good products. ",{"type":"{I : Type u} →\n  [inst : LinearOrder I] →\n    (C : Set (I → Bool)) → { l // Profinite.NobelingProof.Products.isGood C l } → LocallyConstant ↑C ℤ","name":"Profinite.NobelingProof.GoodProducts.eval","isProp":false,"docString":"Evaluation of good products. ","distance":0.2961969276037359488640277049853466451168060302734375}],[" The second projection of a product space is an open map, that is, the image of an open set under the second projection is an open set in the second factor space.",{"type":"∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], IsOpenMap Prod.snd","name":"isOpenMap_snd","isProp":true,"docString":" The second projection of a product space is an open map, that is, the image of an open set under the second projection is an open set in the second factor space.","distance":0.4232715654268572880170040662051178514957427978515625}],["This theorem states that any category, denoted by `C`, which has pullbacks and a terminal object, possesses binary products. In the language of category theory, a category has binary products if for any pair of objects in the category, there exists a product object and product morphisms. This product object has the property that for any other object with morphisms to the given pair, there is a unique factorisation through the product. The theorem thus establishes how the existence of certain limit types (pullbacks and terminal objects) in a category guarantees the existence of another limit type (binary products).",{"type":"∀ (C : Type u) [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasTerminal C]\n  [inst_2 : CategoryTheory.Limits.HasPullbacks C], CategoryTheory.Limits.HasBinaryProducts C","name":"hasBinaryProducts_of_hasTerminal_and_pullbacks","isProp":true,"docString":"This theorem states that any category, denoted by `C`, which has pullbacks and a terminal object, possesses binary products. In the language of category theory, a category has binary products if for any pair of objects in the category, there exists a product object and product morphisms. This product object has the property that for any other object with morphisms to the given pair, there is a unique factorisation through the product. The theorem thus establishes how the existence of certain limit types (pullbacks and terminal objects) in a category guarantees the existence of another limit type (binary products).","distance":0.4129644739879696491158256321796216070652008056640625}],["The type of good products is equivalent to its image. ",{"type":"{I : Type u} →\n  [inst : LinearOrder I] →\n    (C : Set (I → Bool)) → ↑(Profinite.NobelingProof.GoodProducts C) ≃ ↑(Profinite.NobelingProof.GoodProducts.range C)","name":"Profinite.NobelingProof.GoodProducts.equiv_range","isProp":false,"docString":"The type of good products is equivalent to its image. ","distance":0.298953415026958546629742841105326078832149505615234375}],["The product of the factors is the original number ",{"type":"∀ (n : ℕ+), PrimeMultiset.prod (PNat.factorMultiset n) = n","name":"PNat.prod_factorMultiset","isProp":true,"docString":"The product of the factors is the original number ","distance":0.308411850069416904052133077129838056862354278564453125}],["The product is the pullback over the terminal object. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {W X Y Z : C} →\n      (f : X ⟶ Z) →\n        (g : Y ⟶ Z) →\n          (h : W ⟶ X) →\n            (k : W ⟶ Y) →\n              (H₁ : CategoryTheory.Limits.IsTerminal Z) →\n                CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.BinaryFan.mk h k) →\n                  CategoryTheory.Limits.IsLimit\n                    (CategoryTheory.Limits.PullbackCone.mk h k\n                      (_ : CategoryTheory.CategoryStruct.comp h f = CategoryTheory.CategoryStruct.comp k g))","name":"isPullbackOfIsTerminalIsProduct","isProp":false,"docString":"The product is the pullback over the terminal object. ","distance":0.309683685072000336457875846463139168918132781982421875}],["Lexicographical order for products ",{"type":"{α : Type u_1} → {β : Type u_2} → [inst : LT α] → [inst : LT β] → α × β → α × β → Prop","name":"Prod.lexLt","isProp":false,"docString":"Lexicographical order for products ","distance":0.313715505992369025900501355863525532186031341552734375}],["Products of completions ",{"type":"{α : Type u_1} →\n  [inst : UniformSpace α] →\n    AbstractCompletion α →\n      {β : Type u_2} → [inst_1 : UniformSpace β] → AbstractCompletion β → AbstractCompletion (α × β)","name":"AbstractCompletion.prod","isProp":false,"docString":"Products of completions ","distance":0.3143515146029625118018202556413598358631134033203125}],["Notation for the product ",{"type":"Lean.TrailingParserDescr","name":"CategoryTheory.Limits.«term_⨯_»","isProp":false,"docString":"Notation for the product ","distance":0.31487823999941777497468820001813583076000213623046875}],["The first projection from the product. ",{"type":"{X Y : TopCat} → TopCat.of (↑X × ↑Y) ⟶ X","name":"TopCat.prodFst","isProp":false,"docString":"The first projection from the product. ","distance":0.31581029355953182946592505686567164957523345947265625}],["introduce a product where both components are the same ",{"type":"{n : ℕ} → {α : TypeVec.{u} n} → TypeVec.Arrow α (TypeVec.prod α α)","name":"TypeVec.prod.diag","isProp":false,"docString":"introduce a product where both components are the same ","distance":0.31619910000251494341938496290822513401508331298828125}],["The product of a family of types over a list. ",{"type":"{ι : Type u} → (ι → Type v) → List ι → Type v","name":"List.TProd","isProp":false,"docString":"The product of a family of types over a list. ","distance":0.31623382368827257504761973905260674655437469482421875}],["Delaborator for simple product projections. ",{"type":"Lean.PrettyPrinter.Delaborator.Delab","name":"delabProdProjs","isProp":false,"docString":"Delaborator for simple product projections. ","distance":0.318143013334458102381319122287095524370670318603515625}],["The product of two two-pointings. ",{"type":"{α : Type u_1} → {β : Type u_2} → TwoPointing α → TwoPointing β → TwoPointing (α × β)","name":"TwoPointing.prod","isProp":false,"docString":"The product of two two-pointings. ","distance":0.3182913301065031230763224812108092010021209716796875}],["A product is regular if and only if the factors are. ",{"type":"∀ {R : Type u_1} [inst : CommSemigroup R] {a b : R}, IsRegular (a * b) ↔ IsRegular a ∧ IsRegular b","name":"isRegular_mul_iff","isProp":true,"docString":"A product is regular if and only if the factors are. ","distance":0.321925787722382172884039164273417554795742034912109375}],["The first projection of a product, as a smooth map. ",{"type":"{𝕜 : Type u_1} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {E : Type u_2} →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : NormedSpace 𝕜 E] →\n          {E' : Type u_3} →\n            [inst_3 : NormedAddCommGroup E'] →\n              [inst_4 : NormedSpace 𝕜 E'] →\n                {H : Type u_4} →\n                  [inst_5 : TopologicalSpace H] →\n                    {H' : Type u_5} →\n                      [inst_6 : TopologicalSpace H'] →\n                        {I : ModelWithCorners 𝕜 E H} →\n                          {I' : ModelWithCorners 𝕜 E' H'} →\n                            {M : Type u_6} →\n                              [inst_7 : TopologicalSpace M] →\n                                [inst_8 : ChartedSpace H M] →\n                                  {M' : Type u_7} →\n                                    [inst_9 : TopologicalSpace M'] →\n                                      [inst_10 : ChartedSpace H' M'] →\n                                        {n : ℕ∞} → ContMDiffMap (ModelWithCorners.prod I I') I (M × M') M n","name":"ContMDiffMap.fst","isProp":false,"docString":"The first projection of a product, as a smooth map. ","distance":0.32235249671461152498608271343982778489589691162109375}],["The second projection of a product, as a smooth map. ",{"type":"{𝕜 : Type u_1} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {E : Type u_2} →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : NormedSpace 𝕜 E] →\n          {E' : Type u_3} →\n            [inst_3 : NormedAddCommGroup E'] →\n              [inst_4 : NormedSpace 𝕜 E'] →\n                {H : Type u_4} →\n                  [inst_5 : TopologicalSpace H] →\n                    {H' : Type u_5} →\n                      [inst_6 : TopologicalSpace H'] →\n                        {I : ModelWithCorners 𝕜 E H} →\n                          {I' : ModelWithCorners 𝕜 E' H'} →\n                            {M : Type u_6} →\n                              [inst_7 : TopologicalSpace M] →\n                                [inst_8 : ChartedSpace H M] →\n                                  {M' : Type u_7} →\n                                    [inst_9 : TopologicalSpace M'] →\n                                      [inst_10 : ChartedSpace H' M'] →\n                                        {n : ℕ∞} → ContMDiffMap (ModelWithCorners.prod I I') I' (M × M') M' n","name":"ContMDiffMap.snd","isProp":false,"docString":"The second projection of a product, as a smooth map. ","distance":0.32264605877833585356739831695449538528919219970703125}],["The composition-product of a measure and a kernel. ",{"type":"Lean.TrailingParserDescr","name":"ProbabilityTheory.«term_⊗ₘ_»","isProp":false,"docString":"The composition-product of a measure and a kernel. ","distance":0.32632163319320783845256528366007842123508453369140625}],["The fiber product $X \\times_Y Z$. ",{"type":"{X : Type u_1} → {Y : Sort u_2} → {Z : Type u_3} → (X → Y) → (Z → Y) → Type (max 0 u_3 u_1)","name":"Function.Pullback","isProp":false,"docString":"The fiber product $X \\times_Y Z$. ","distance":0.32672102974415218046289055564557202160358428955078125}],["The product cone induced by the concrete product. ",{"type":"{R : Type u} → [inst : Ring R] → {ι : Type v} → (Z : ι → ModuleCatMax R) → CategoryTheory.Limits.Fan Z","name":"ModuleCat.productCone","isProp":false,"docString":"The product cone induced by the concrete product. ","distance":0.32783906316161581795398660688078962266445159912109375}],["The first projection of a product is a linear map. ",{"type":"(R : Type u) →\n  (M : Type v) →\n    (M₂ : Type w) →\n      [inst : Semiring R] →\n        [inst_1 : AddCommMonoid M] →\n          [inst_2 : AddCommMonoid M₂] → [inst_3 : Module R M] → [inst_4 : Module R M₂] → M × M₂ →ₗ[R] M","name":"LinearMap.fst","isProp":false,"docString":"The first projection of a product is a linear map. ","distance":0.329007585577129113563188411717419512569904327392578125}]]