[["The set of good products. ",{"type":"{I : Type u} ‚Üí [inst : LinearOrder I] ‚Üí Set (I ‚Üí Bool) ‚Üí Set (Profinite.NobelingProof.Products I)","name":"Profinite.NobelingProof.GoodProducts","isProp":false,"docString":"The set of good products. ","distance":0.279498761375946147555993093192228116095066070556640625}],[" For any category with binary products, the product of two objects exists.",{"type":"‚àÄ {C : Type u_2} [inst : CategoryTheory.Category.{u_1, u_2} C] [inst_1 : CategoryTheory.Limits.HasBinaryProducts C]\n  (X Y : C), CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair X Y)","name":"CategoryTheory.Limits.prod.functor.proof_1","isProp":true,"docString":" For any category with binary products, the product of two objects exists.","distance":0.402245254815709440965321164185297675430774688720703125}],["This theorem, which is a part of Profinite's NobelingProof, asserts the following: for any type `I` equipped with a linear order, a set `C` of Boolean-valued functions on `I`, a product `l` of elements from `I`, and a predicate `J` on `I`, if every element `a` in the product `l` satisfies the predicate `J`, then for any `j` in `I` that can be decided by `J`, the composition of the evaluation of `l` under the image of `Proj œÄ J` with the restriction of `Proj œÄ J` to `C`, is equal to the evaluation of `l` under `C`. \n\nIn simple terms, this theorem shows a relationship between the evaluation of a product under a set of functions and its projection restricted to a subset, assuming that all elements of the product satisfy a certain property. The mathematical operations involved are function composition and evaluation.",{"type":"‚àÄ {I : Type u} [inst : LinearOrder I] (C : Set (I ‚Üí Bool)) {l : Profinite.NobelingProof.Products I} (J : I ‚Üí Prop),\n  (‚àÄ a ‚àà ‚Üël, J a) ‚Üí\n    ‚àÄ [inst_1 : (j : I) ‚Üí Decidable (J j)],\n      ‚áë(Profinite.NobelingProof.Products.eval (Profinite.NobelingProof.œÄ C J) l) ‚àò\n          Profinite.NobelingProof.ProjRestrict C J =\n        ‚áë(Profinite.NobelingProof.Products.eval C l)","name":"Profinite.NobelingProof.Products.evalFacProp","isProp":true,"docString":"This theorem, which is a part of Profinite's NobelingProof, asserts the following: for any type `I` equipped with a linear order, a set `C` of Boolean-valued functions on `I`, a product `l` of elements from `I`, and a predicate `J` on `I`, if every element `a` in the product `l` satisfies the predicate `J`, then for any `j` in `I` that can be decided by `J`, the composition of the evaluation of `l` under the image of `Proj œÄ J` with the restriction of `Proj œÄ J` to `C`, is equal to the evaluation of `l` under `C`. \n\nIn simple terms, this theorem shows a relationship between the evaluation of a product under a set of functions and its projection restricted to a subset, assuming that all elements of the product satisfy a certain property. The mathematical operations involved are function composition and evaluation.","distance":0.41029726636665631023248579367646016180515289306640625}],["Evaluation of good products. ",{"type":"{I : Type u} ‚Üí\n  [inst : LinearOrder I] ‚Üí\n    (C : Set (I ‚Üí Bool)) ‚Üí { l // Profinite.NobelingProof.Products.isGood C l } ‚Üí LocallyConstant ‚ÜëC ‚Ñ§","name":"Profinite.NobelingProof.GoodProducts.eval","isProp":false,"docString":"Evaluation of good products. ","distance":0.2961969276037359488640277049853466451168060302734375}],[" The second projection of a product space is an open map, that is, the image of an open set under the second projection is an open set in the second factor space.",{"type":"‚àÄ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], IsOpenMap Prod.snd","name":"isOpenMap_snd","isProp":true,"docString":" The second projection of a product space is an open map, that is, the image of an open set under the second projection is an open set in the second factor space.","distance":0.4232715654268572880170040662051178514957427978515625}],["This theorem states that any category, denoted by `C`, which has pullbacks and a terminal object, possesses binary products. In the language of category theory, a category has binary products if for any pair of objects in the category, there exists a product object and product morphisms. This product object has the property that for any other object with morphisms to the given pair, there is a unique factorisation through the product. The theorem thus establishes how the existence of certain limit types (pullbacks and terminal objects) in a category guarantees the existence of another limit type (binary products).",{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasTerminal C]\n  [inst_2 : CategoryTheory.Limits.HasPullbacks C], CategoryTheory.Limits.HasBinaryProducts C","name":"hasBinaryProducts_of_hasTerminal_and_pullbacks","isProp":true,"docString":"This theorem states that any category, denoted by `C`, which has pullbacks and a terminal object, possesses binary products. In the language of category theory, a category has binary products if for any pair of objects in the category, there exists a product object and product morphisms. This product object has the property that for any other object with morphisms to the given pair, there is a unique factorisation through the product. The theorem thus establishes how the existence of certain limit types (pullbacks and terminal objects) in a category guarantees the existence of another limit type (binary products).","distance":0.4129644739879696491158256321796216070652008056640625}],["The type of good products is equivalent to its image. ",{"type":"{I : Type u} ‚Üí\n  [inst : LinearOrder I] ‚Üí\n    (C : Set (I ‚Üí Bool)) ‚Üí ‚Üë(Profinite.NobelingProof.GoodProducts C) ‚âÉ ‚Üë(Profinite.NobelingProof.GoodProducts.range C)","name":"Profinite.NobelingProof.GoodProducts.equiv_range","isProp":false,"docString":"The type of good products is equivalent to its image. ","distance":0.298953415026958546629742841105326078832149505615234375}],["The product of the factors is the original number ",{"type":"‚àÄ (n : ‚Ñï+), PrimeMultiset.prod (PNat.factorMultiset n) = n","name":"PNat.prod_factorMultiset","isProp":true,"docString":"The product of the factors is the original number ","distance":0.308411850069416904052133077129838056862354278564453125}],["The product is the pullback over the terminal object. ",{"type":"{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí\n    {W X Y Z : C} ‚Üí\n      (f : X ‚ü∂ Z) ‚Üí\n        (g : Y ‚ü∂ Z) ‚Üí\n          (h : W ‚ü∂ X) ‚Üí\n            (k : W ‚ü∂ Y) ‚Üí\n              (H‚ÇÅ : CategoryTheory.Limits.IsTerminal Z) ‚Üí\n                CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.BinaryFan.mk h k) ‚Üí\n                  CategoryTheory.Limits.IsLimit\n                    (CategoryTheory.Limits.PullbackCone.mk h k\n                      (_ : CategoryTheory.CategoryStruct.comp h f = CategoryTheory.CategoryStruct.comp k g))","name":"isPullbackOfIsTerminalIsProduct","isProp":false,"docString":"The product is the pullback over the terminal object. ","distance":0.309683685072000336457875846463139168918132781982421875}],["Lexicographical order for products ",{"type":"{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí [inst : LT Œ±] ‚Üí [inst : LT Œ≤] ‚Üí Œ± √ó Œ≤ ‚Üí Œ± √ó Œ≤ ‚Üí Prop","name":"Prod.lexLt","isProp":false,"docString":"Lexicographical order for products ","distance":0.313715505992369025900501355863525532186031341552734375}],["Products of completions ",{"type":"{Œ± : Type u_1} ‚Üí\n  [inst : UniformSpace Œ±] ‚Üí\n    AbstractCompletion Œ± ‚Üí\n      {Œ≤ : Type u_2} ‚Üí [inst_1 : UniformSpace Œ≤] ‚Üí AbstractCompletion Œ≤ ‚Üí AbstractCompletion (Œ± √ó Œ≤)","name":"AbstractCompletion.prod","isProp":false,"docString":"Products of completions ","distance":0.3143515146029625118018202556413598358631134033203125}],["Notation for the product ",{"type":"Lean.TrailingParserDescr","name":"CategoryTheory.Limits.¬´term_‚®Ø_¬ª","isProp":false,"docString":"Notation for the product ","distance":0.31487823999941777497468820001813583076000213623046875}],["The first projection from the product. ",{"type":"{X Y : TopCat} ‚Üí TopCat.of (‚ÜëX √ó ‚ÜëY) ‚ü∂ X","name":"TopCat.prodFst","isProp":false,"docString":"The first projection from the product. ","distance":0.31581029355953182946592505686567164957523345947265625}],["introduce a product where both components are the same ",{"type":"{n : ‚Ñï} ‚Üí {Œ± : TypeVec.{u} n} ‚Üí TypeVec.Arrow Œ± (TypeVec.prod Œ± Œ±)","name":"TypeVec.prod.diag","isProp":false,"docString":"introduce a product where both components are the same ","distance":0.31619910000251494341938496290822513401508331298828125}],["The product of a family of types over a list. ",{"type":"{Œπ : Type u} ‚Üí (Œπ ‚Üí Type v) ‚Üí List Œπ ‚Üí Type v","name":"List.TProd","isProp":false,"docString":"The product of a family of types over a list. ","distance":0.31623382368827257504761973905260674655437469482421875}],["Delaborator for simple product projections. ",{"type":"Lean.PrettyPrinter.Delaborator.Delab","name":"delabProdProjs","isProp":false,"docString":"Delaborator for simple product projections. ","distance":0.318143013334458102381319122287095524370670318603515625}],["The product of two two-pointings. ",{"type":"{Œ± : Type u_1} ‚Üí {Œ≤ : Type u_2} ‚Üí TwoPointing Œ± ‚Üí TwoPointing Œ≤ ‚Üí TwoPointing (Œ± √ó Œ≤)","name":"TwoPointing.prod","isProp":false,"docString":"The product of two two-pointings. ","distance":0.3182913301065031230763224812108092010021209716796875}],["A product is regular if and only if the factors are. ",{"type":"‚àÄ {R : Type u_1} [inst : CommSemigroup R] {a b : R}, IsRegular (a * b) ‚Üî IsRegular a ‚àß IsRegular b","name":"isRegular_mul_iff","isProp":true,"docString":"A product is regular if and only if the factors are. ","distance":0.321925787722382172884039164273417554795742034912109375}],["The first projection of a product, as a smooth map. ",{"type":"{ùïú : Type u_1} ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [inst_2 : NormedSpace ùïú E] ‚Üí\n          {E' : Type u_3} ‚Üí\n            [inst_3 : NormedAddCommGroup E'] ‚Üí\n              [inst_4 : NormedSpace ùïú E'] ‚Üí\n                {H : Type u_4} ‚Üí\n                  [inst_5 : TopologicalSpace H] ‚Üí\n                    {H' : Type u_5} ‚Üí\n                      [inst_6 : TopologicalSpace H'] ‚Üí\n                        {I : ModelWithCorners ùïú E H} ‚Üí\n                          {I' : ModelWithCorners ùïú E' H'} ‚Üí\n                            {M : Type u_6} ‚Üí\n                              [inst_7 : TopologicalSpace M] ‚Üí\n                                [inst_8 : ChartedSpace H M] ‚Üí\n                                  {M' : Type u_7} ‚Üí\n                                    [inst_9 : TopologicalSpace M'] ‚Üí\n                                      [inst_10 : ChartedSpace H' M'] ‚Üí\n                                        {n : ‚Ñï‚àû} ‚Üí ContMDiffMap (ModelWithCorners.prod I I') I (M √ó M') M n","name":"ContMDiffMap.fst","isProp":false,"docString":"The first projection of a product, as a smooth map. ","distance":0.32235249671461152498608271343982778489589691162109375}],["The second projection of a product, as a smooth map. ",{"type":"{ùïú : Type u_1} ‚Üí\n  [inst : NontriviallyNormedField ùïú] ‚Üí\n    {E : Type u_2} ‚Üí\n      [inst_1 : NormedAddCommGroup E] ‚Üí\n        [inst_2 : NormedSpace ùïú E] ‚Üí\n          {E' : Type u_3} ‚Üí\n            [inst_3 : NormedAddCommGroup E'] ‚Üí\n              [inst_4 : NormedSpace ùïú E'] ‚Üí\n                {H : Type u_4} ‚Üí\n                  [inst_5 : TopologicalSpace H] ‚Üí\n                    {H' : Type u_5} ‚Üí\n                      [inst_6 : TopologicalSpace H'] ‚Üí\n                        {I : ModelWithCorners ùïú E H} ‚Üí\n                          {I' : ModelWithCorners ùïú E' H'} ‚Üí\n                            {M : Type u_6} ‚Üí\n                              [inst_7 : TopologicalSpace M] ‚Üí\n                                [inst_8 : ChartedSpace H M] ‚Üí\n                                  {M' : Type u_7} ‚Üí\n                                    [inst_9 : TopologicalSpace M'] ‚Üí\n                                      [inst_10 : ChartedSpace H' M'] ‚Üí\n                                        {n : ‚Ñï‚àû} ‚Üí ContMDiffMap (ModelWithCorners.prod I I') I' (M √ó M') M' n","name":"ContMDiffMap.snd","isProp":false,"docString":"The second projection of a product, as a smooth map. ","distance":0.32264605877833585356739831695449538528919219970703125}],["The composition-product of a measure and a kernel. ",{"type":"Lean.TrailingParserDescr","name":"ProbabilityTheory.¬´term_‚äó‚Çò_¬ª","isProp":false,"docString":"The composition-product of a measure and a kernel. ","distance":0.32632163319320783845256528366007842123508453369140625}],["The fiber product $X \\times_Y Z$. ",{"type":"{X : Type u_1} ‚Üí {Y : Sort u_2} ‚Üí {Z : Type u_3} ‚Üí (X ‚Üí Y) ‚Üí (Z ‚Üí Y) ‚Üí Type (max 0 u_3 u_1)","name":"Function.Pullback","isProp":false,"docString":"The fiber product $X \\times_Y Z$. ","distance":0.32672102974415218046289055564557202160358428955078125}],["The product cone induced by the concrete product. ",{"type":"{R : Type u} ‚Üí [inst : Ring R] ‚Üí {Œπ : Type v} ‚Üí (Z : Œπ ‚Üí ModuleCatMax R) ‚Üí CategoryTheory.Limits.Fan Z","name":"ModuleCat.productCone","isProp":false,"docString":"The product cone induced by the concrete product. ","distance":0.32783906316161581795398660688078962266445159912109375}],["The first projection of a product is a linear map. ",{"type":"(R : Type u) ‚Üí\n  (M : Type v) ‚Üí\n    (M‚ÇÇ : Type w) ‚Üí\n      [inst : Semiring R] ‚Üí\n        [inst_1 : AddCommMonoid M] ‚Üí\n          [inst_2 : AddCommMonoid M‚ÇÇ] ‚Üí [inst_3 : Module R M] ‚Üí [inst_4 : Module R M‚ÇÇ] ‚Üí M √ó M‚ÇÇ ‚Üí‚Çó[R] M","name":"LinearMap.fst","isProp":false,"docString":"The first projection of a product is a linear map. ","distance":0.329007585577129113563188411717419512569904327392578125}]]