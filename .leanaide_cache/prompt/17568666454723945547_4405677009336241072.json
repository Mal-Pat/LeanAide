[["The product is the pullback over the terminal object. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {W X Y Z : C} →\n      (f : X ⟶ Z) →\n        (g : Y ⟶ Z) →\n          (h : W ⟶ X) →\n            (k : W ⟶ Y) →\n              (H₁ : CategoryTheory.Limits.IsTerminal Z) →\n                CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.BinaryFan.mk h k) →\n                  CategoryTheory.Limits.IsLimit\n                    (CategoryTheory.Limits.PullbackCone.mk h k\n                      (_ : CategoryTheory.CategoryStruct.comp h f = CategoryTheory.CategoryStruct.comp k g))","name":"isPullbackOfIsTerminalIsProduct","isProp":false,"docString":"The product is the pullback over the terminal object. ","distance":0.320838985149471789259933984794770367443561553955078125}],[" For any category with binary products, the product of two objects exists.",{"type":"∀ {C : Type u_2} [inst : CategoryTheory.Category.{u_1, u_2} C] [inst_1 : CategoryTheory.Limits.HasBinaryProducts C]\n  (X Y : C), CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair X Y)","name":"CategoryTheory.Limits.prod.functor.proof_1","isProp":true,"docString":" For any category with binary products, the product of two objects exists.","distance":0.41182401208058749819684862814028747379779815673828125}],["This theorem, which is a part of Profinite's NobelingProof, asserts the following: for any type `I` equipped with a linear order, a set `C` of Boolean-valued functions on `I`, a product `l` of elements from `I`, and a predicate `J` on `I`, if every element `a` in the product `l` satisfies the predicate `J`, then for any `j` in `I` that can be decided by `J`, the composition of the evaluation of `l` under the image of `Proj π J` with the restriction of `Proj π J` to `C`, is equal to the evaluation of `l` under `C`. \n\nIn simple terms, this theorem shows a relationship between the evaluation of a product under a set of functions and its projection restricted to a subset, assuming that all elements of the product satisfy a certain property. The mathematical operations involved are function composition and evaluation.",{"type":"∀ {I : Type u} [inst : LinearOrder I] (C : Set (I → Bool)) {l : Profinite.NobelingProof.Products I} (J : I → Prop),\n  (∀ a ∈ ↑l, J a) →\n    ∀ [inst_1 : (j : I) → Decidable (J j)],\n      ⇑(Profinite.NobelingProof.Products.eval (Profinite.NobelingProof.π C J) l) ∘\n          Profinite.NobelingProof.ProjRestrict C J =\n        ⇑(Profinite.NobelingProof.Products.eval C l)","name":"Profinite.NobelingProof.Products.evalFacProp","isProp":true,"docString":"This theorem, which is a part of Profinite's NobelingProof, asserts the following: for any type `I` equipped with a linear order, a set `C` of Boolean-valued functions on `I`, a product `l` of elements from `I`, and a predicate `J` on `I`, if every element `a` in the product `l` satisfies the predicate `J`, then for any `j` in `I` that can be decided by `J`, the composition of the evaluation of `l` under the image of `Proj π J` with the restriction of `Proj π J` to `C`, is equal to the evaluation of `l` under `C`. \n\nIn simple terms, this theorem shows a relationship between the evaluation of a product under a set of functions and its projection restricted to a subset, assuming that all elements of the product satisfy a certain property. The mathematical operations involved are function composition and evaluation.","distance":0.451245549427246650520118009808356873691082000732421875}],["The set of good products. ",{"type":"{I : Type u} → [inst : LinearOrder I] → Set (I → Bool) → Set (Profinite.NobelingProof.Products I)","name":"Profinite.NobelingProof.GoodProducts","isProp":false,"docString":"The set of good products. ","distance":0.32342022227215061480620761358295567333698272705078125}],[" A product set in a product space is open if and only if both factors are open or one of them is empty.",{"type":"∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {s : Set X} {t : Set Y},\n  IsOpen (s ×ˢ t) ↔ IsOpen s ∧ IsOpen t ∨ s = ∅ ∨ t = ∅","name":"isOpen_prod_iff'","isProp":true,"docString":" A product set in a product space is open if and only if both factors are open or one of them is empty.","distance":0.44378408876366304269822649075649678707122802734375}],["The theorem `Profinite.NobelingProof.Products.prop_of_isGood` states that for any type `I` equipped with a linear order, a set `C` of Boolean-valued functions on `I`, a product `l` of `I`, and a property `J` of elements of `I`, if `l` is \"good\" with respect to the image of `C` under the projection `J`, then every element `a` of `l` satisfies the property `J`. Here, a product is said to be \"good\" if the evaluation of `C` at `l` is not an integer linear combination of the evaluations of `C` at all products less than `l`. The projection of `C` by `J` is the image of `C` under the projection function `J`.",{"type":"∀ {I : Type u} [inst : LinearOrder I] (C : Set (I → Bool)) {l : Profinite.NobelingProof.Products I} (J : I → Prop)\n  [inst_1 : (j : I) → Decidable (J j)],\n  Profinite.NobelingProof.Products.isGood (Profinite.NobelingProof.π C J) l → ∀ a ∈ ↑l, J a","name":"Profinite.NobelingProof.Products.prop_of_isGood","isProp":true,"docString":"The theorem `Profinite.NobelingProof.Products.prop_of_isGood` states that for any type `I` equipped with a linear order, a set `C` of Boolean-valued functions on `I`, a product `l` of `I`, and a property `J` of elements of `I`, if `l` is \"good\" with respect to the image of `C` under the projection `J`, then every element `a` of `l` satisfies the property `J`. Here, a product is said to be \"good\" if the evaluation of `C` at `l` is not an integer linear combination of the evaluations of `C` at all products less than `l`. The projection of `C` by `J` is the image of `C` under the projection function `J`.","distance":0.453775826027404682871946306477184407413005828857421875}],["The product of the factors is the original number ",{"type":"∀ (n : ℕ+), PrimeMultiset.prod (PNat.factorMultiset n) = n","name":"PNat.prod_factorMultiset","isProp":true,"docString":"The product of the factors is the original number ","distance":0.324664124255599817470141488229273818433284759521484375}],["The first projection from the product. ",{"type":"{X Y : TopCat} → TopCat.of (↑X × ↑Y) ⟶ X","name":"TopCat.prodFst","isProp":false,"docString":"The first projection from the product. ","distance":0.329575130983856323663161447257152758538722991943359375}],["Lexicographical order for products ",{"type":"{α : Type u_1} → {β : Type u_2} → [inst : LT α] → [inst : LT β] → α × β → α × β → Prop","name":"Prod.lexLt","isProp":false,"docString":"Lexicographical order for products ","distance":0.330967067177516838238915397596429102122783660888671875}],["A limit can be realised as a subobject of a product. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {J : Type w} →\n      [inst_1 : CategoryTheory.SmallCategory J] →\n        [inst_2 : CategoryTheory.Limits.HasLimitsOfSize.{w, w, v, u} C] →\n          (F : CategoryTheory.Functor J C) → CategoryTheory.Limits.limit F ⟶ ∏ fun j => F.obj j","name":"CategoryTheory.Limits.limitSubobjectProduct","isProp":false,"docString":"A limit can be realised as a subobject of a product. ","distance":0.3355443623199947378310525891720317304134368896484375}],["The product cone induced by the concrete product. ",{"type":"{R : Type u} → [inst : Ring R] → {ι : Type v} → (Z : ι → ModuleCatMax R) → CategoryTheory.Limits.Fan Z","name":"ModuleCat.productCone","isProp":false,"docString":"The product cone induced by the concrete product. ","distance":0.33734775428670837893463385626091621816158294677734375}],["Notation for the product ",{"type":"Lean.TrailingParserDescr","name":"CategoryTheory.Limits.«term_⨯_»","isProp":false,"docString":"Notation for the product ","distance":0.339942175847698535573471190218697302043437957763671875}],["Products of completions ",{"type":"{α : Type u_1} →\n  [inst : UniformSpace α] →\n    AbstractCompletion α →\n      {β : Type u_2} → [inst_1 : UniformSpace β] → AbstractCompletion β → AbstractCompletion (α × β)","name":"AbstractCompletion.prod","isProp":false,"docString":"Products of completions ","distance":0.345331826182694923144111953661195002496242523193359375}],["The coproduct is the pushout under the initial object. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {W X Y Z : C} →\n      (f : X ⟶ Z) →\n        (g : Y ⟶ Z) →\n          (h : W ⟶ X) →\n            (k : W ⟶ Y) →\n              (H₁ : CategoryTheory.Limits.IsInitial W) →\n                CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.BinaryCofan.mk f g) →\n                  CategoryTheory.Limits.IsColimit\n                    (CategoryTheory.Limits.PushoutCocone.mk f g\n                      (_ : CategoryTheory.CategoryStruct.comp h f = CategoryTheory.CategoryStruct.comp k g))","name":"isPushoutOfIsInitialIsCoproduct","isProp":false,"docString":"The coproduct is the pushout under the initial object. ","distance":0.34677768716951151706240352723398245871067047119140625}],["The type of good products is equivalent to its image. ",{"type":"{I : Type u} →\n  [inst : LinearOrder I] →\n    (C : Set (I → Bool)) → ↑(Profinite.NobelingProof.GoodProducts C) ≃ ↑(Profinite.NobelingProof.GoodProducts.range C)","name":"Profinite.NobelingProof.GoodProducts.equiv_range","isProp":false,"docString":"The type of good products is equivalent to its image. ","distance":0.347190808216067015035122267363476566970348358154296875}],["Delaborator for simple product projections. ",{"type":"Lean.PrettyPrinter.Delaborator.Delab","name":"delabProdProjs","isProp":false,"docString":"Delaborator for simple product projections. ","distance":0.347724070857192868455598500077030621469020843505859375}],["The first projection of a product, as a smooth map. ",{"type":"{𝕜 : Type u_1} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {E : Type u_2} →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : NormedSpace 𝕜 E] →\n          {E' : Type u_3} →\n            [inst_3 : NormedAddCommGroup E'] →\n              [inst_4 : NormedSpace 𝕜 E'] →\n                {H : Type u_4} →\n                  [inst_5 : TopologicalSpace H] →\n                    {H' : Type u_5} →\n                      [inst_6 : TopologicalSpace H'] →\n                        {I : ModelWithCorners 𝕜 E H} →\n                          {I' : ModelWithCorners 𝕜 E' H'} →\n                            {M : Type u_6} →\n                              [inst_7 : TopologicalSpace M] →\n                                [inst_8 : ChartedSpace H M] →\n                                  {M' : Type u_7} →\n                                    [inst_9 : TopologicalSpace M'] →\n                                      [inst_10 : ChartedSpace H' M'] →\n                                        {n : ℕ∞} → ContMDiffMap (ModelWithCorners.prod I I') I (M × M') M n","name":"ContMDiffMap.fst","isProp":false,"docString":"The first projection of a product, as a smooth map. ","distance":0.3510815541049947530183317212504334747791290283203125}],["Evaluation of good products. ",{"type":"{I : Type u} →\n  [inst : LinearOrder I] →\n    (C : Set (I → Bool)) → { l // Profinite.NobelingProof.Products.isGood C l } → LocallyConstant ↑C ℤ","name":"Profinite.NobelingProof.GoodProducts.eval","isProp":false,"docString":"Evaluation of good products. ","distance":0.35161907302848327550037765831802971661090850830078125}],["The second projection from the product. ",{"type":"{X Y : TopCat} → TopCat.of (↑X × ↑Y) ⟶ Y","name":"TopCat.prodSnd","isProp":false,"docString":"The second projection from the product. ","distance":0.3518563639153795552516612588078714907169342041015625}],["The second projection of a product, as a smooth map. ",{"type":"{𝕜 : Type u_1} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {E : Type u_2} →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : NormedSpace 𝕜 E] →\n          {E' : Type u_3} →\n            [inst_3 : NormedAddCommGroup E'] →\n              [inst_4 : NormedSpace 𝕜 E'] →\n                {H : Type u_4} →\n                  [inst_5 : TopologicalSpace H] →\n                    {H' : Type u_5} →\n                      [inst_6 : TopologicalSpace H'] →\n                        {I : ModelWithCorners 𝕜 E H} →\n                          {I' : ModelWithCorners 𝕜 E' H'} →\n                            {M : Type u_6} →\n                              [inst_7 : TopologicalSpace M] →\n                                [inst_8 : ChartedSpace H M] →\n                                  {M' : Type u_7} →\n                                    [inst_9 : TopologicalSpace M'] →\n                                      [inst_10 : ChartedSpace H' M'] →\n                                        {n : ℕ∞} → ContMDiffMap (ModelWithCorners.prod I I') I' (M × M') M' n","name":"ContMDiffMap.snd","isProp":false,"docString":"The second projection of a product, as a smooth map. ","distance":0.352743491876557568875938386554480530321598052978515625}],["the image of a product is less or equal than the product of the images. ",{"type":"∀ {F : Type u_7} {α : outParam (Type u_8)} {β : outParam (Type u_9)} [inst : NonUnitalNonAssocRing α]\n  [inst_1 : OrderedSemiring β] [self : RingSeminormClass F α β] (f : F) (a b : α), f (a * b) ≤ f a * f b","name":"RingSeminormClass.map_mul_le_mul","isProp":true,"docString":"the image of a product is less or equal than the product of the images. ","distance":0.353634205944298229962186042030225507915019989013671875}],["The pullback over the zero object is the product. ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroObject C] →\n      [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] →\n        (X Y : C) → [inst_3 : CategoryTheory.Limits.HasBinaryProduct X Y] → CategoryTheory.Limits.pullback 0 0 ≅ X ⨯ Y","name":"CategoryTheory.Limits.pullbackZeroZeroIso","isProp":false,"docString":"The pullback over the zero object is the product. ","distance":0.35517593456665197404475975417881272733211517333984375}],["The limit cone for the product with a zero object. ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroObject C] →\n      [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] → (X : C) → CategoryTheory.Limits.BinaryFan X 0","name":"CategoryTheory.Limits.binaryFanZeroRight","isProp":false,"docString":"The limit cone for the product with a zero object. ","distance":0.35907956543732544307800935712293721735477447509765625}],["introduce a product where both components are the same ",{"type":"{n : ℕ} → {α : TypeVec.{u} n} → TypeVec.Arrow α (TypeVec.prod α α)","name":"TypeVec.prod.diag","isProp":false,"docString":"introduce a product where both components are the same ","distance":0.36175788478721726537656877553672529757022857666015625}]]