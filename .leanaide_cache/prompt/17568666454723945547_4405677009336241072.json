[["The product is the pullback over the terminal object. ",{"type":"{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    {W X Y Z : C} â†’\n      (f : X âŸ¶ Z) â†’\n        (g : Y âŸ¶ Z) â†’\n          (h : W âŸ¶ X) â†’\n            (k : W âŸ¶ Y) â†’\n              (Hâ‚ : CategoryTheory.Limits.IsTerminal Z) â†’\n                CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.BinaryFan.mk h k) â†’\n                  CategoryTheory.Limits.IsLimit\n                    (CategoryTheory.Limits.PullbackCone.mk h k\n                      (_ : CategoryTheory.CategoryStruct.comp h f = CategoryTheory.CategoryStruct.comp k g))","name":"isPullbackOfIsTerminalIsProduct","isProp":false,"docString":"The product is the pullback over the terminal object. ","distance":0.320838985149471789259933984794770367443561553955078125}],[" For any category with binary products, the product of two objects exists.",{"type":"âˆ€ {C : Type u_2} [inst : CategoryTheory.Category.{u_1, u_2} C] [inst_1 : CategoryTheory.Limits.HasBinaryProducts C]\n  (X Y : C), CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair X Y)","name":"CategoryTheory.Limits.prod.functor.proof_1","isProp":true,"docString":" For any category with binary products, the product of two objects exists.","distance":0.41182401208058749819684862814028747379779815673828125}],["This theorem, which is a part of Profinite's NobelingProof, asserts the following: for any type `I` equipped with a linear order, a set `C` of Boolean-valued functions on `I`, a product `l` of elements from `I`, and a predicate `J` on `I`, if every element `a` in the product `l` satisfies the predicate `J`, then for any `j` in `I` that can be decided by `J`, the composition of the evaluation of `l` under the image of `Proj Ï€ J` with the restriction of `Proj Ï€ J` to `C`, is equal to the evaluation of `l` under `C`. \n\nIn simple terms, this theorem shows a relationship between the evaluation of a product under a set of functions and its projection restricted to a subset, assuming that all elements of the product satisfy a certain property. The mathematical operations involved are function composition and evaluation.",{"type":"âˆ€ {I : Type u} [inst : LinearOrder I] (C : Set (I â†’ Bool)) {l : Profinite.NobelingProof.Products I} (J : I â†’ Prop),\n  (âˆ€ a âˆˆ â†‘l, J a) â†’\n    âˆ€ [inst_1 : (j : I) â†’ Decidable (J j)],\n      â‡‘(Profinite.NobelingProof.Products.eval (Profinite.NobelingProof.Ï€ C J) l) âˆ˜\n          Profinite.NobelingProof.ProjRestrict C J =\n        â‡‘(Profinite.NobelingProof.Products.eval C l)","name":"Profinite.NobelingProof.Products.evalFacProp","isProp":true,"docString":"This theorem, which is a part of Profinite's NobelingProof, asserts the following: for any type `I` equipped with a linear order, a set `C` of Boolean-valued functions on `I`, a product `l` of elements from `I`, and a predicate `J` on `I`, if every element `a` in the product `l` satisfies the predicate `J`, then for any `j` in `I` that can be decided by `J`, the composition of the evaluation of `l` under the image of `Proj Ï€ J` with the restriction of `Proj Ï€ J` to `C`, is equal to the evaluation of `l` under `C`. \n\nIn simple terms, this theorem shows a relationship between the evaluation of a product under a set of functions and its projection restricted to a subset, assuming that all elements of the product satisfy a certain property. The mathematical operations involved are function composition and evaluation.","distance":0.451245549427246650520118009808356873691082000732421875}],["The set of good products. ",{"type":"{I : Type u} â†’ [inst : LinearOrder I] â†’ Set (I â†’ Bool) â†’ Set (Profinite.NobelingProof.Products I)","name":"Profinite.NobelingProof.GoodProducts","isProp":false,"docString":"The set of good products. ","distance":0.32342022227215061480620761358295567333698272705078125}],[" A product set in a product space is open if and only if both factors are open or one of them is empty.",{"type":"âˆ€ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {s : Set X} {t : Set Y},\n  IsOpen (s Ã—Ë¢ t) â†” IsOpen s âˆ§ IsOpen t âˆ¨ s = âˆ… âˆ¨ t = âˆ…","name":"isOpen_prod_iff'","isProp":true,"docString":" A product set in a product space is open if and only if both factors are open or one of them is empty.","distance":0.44378408876366304269822649075649678707122802734375}],["The theorem `Profinite.NobelingProof.Products.prop_of_isGood` states that for any type `I` equipped with a linear order, a set `C` of Boolean-valued functions on `I`, a product `l` of `I`, and a property `J` of elements of `I`, if `l` is \"good\" with respect to the image of `C` under the projection `J`, then every element `a` of `l` satisfies the property `J`. Here, a product is said to be \"good\" if the evaluation of `C` at `l` is not an integer linear combination of the evaluations of `C` at all products less than `l`. The projection of `C` by `J` is the image of `C` under the projection function `J`.",{"type":"âˆ€ {I : Type u} [inst : LinearOrder I] (C : Set (I â†’ Bool)) {l : Profinite.NobelingProof.Products I} (J : I â†’ Prop)\n  [inst_1 : (j : I) â†’ Decidable (J j)],\n  Profinite.NobelingProof.Products.isGood (Profinite.NobelingProof.Ï€ C J) l â†’ âˆ€ a âˆˆ â†‘l, J a","name":"Profinite.NobelingProof.Products.prop_of_isGood","isProp":true,"docString":"The theorem `Profinite.NobelingProof.Products.prop_of_isGood` states that for any type `I` equipped with a linear order, a set `C` of Boolean-valued functions on `I`, a product `l` of `I`, and a property `J` of elements of `I`, if `l` is \"good\" with respect to the image of `C` under the projection `J`, then every element `a` of `l` satisfies the property `J`. Here, a product is said to be \"good\" if the evaluation of `C` at `l` is not an integer linear combination of the evaluations of `C` at all products less than `l`. The projection of `C` by `J` is the image of `C` under the projection function `J`.","distance":0.453775826027404682871946306477184407413005828857421875}],["The product of the factors is the original number ",{"type":"âˆ€ (n : â„•+), PrimeMultiset.prod (PNat.factorMultiset n) = n","name":"PNat.prod_factorMultiset","isProp":true,"docString":"The product of the factors is the original number ","distance":0.324664124255599817470141488229273818433284759521484375}],["The first projection from the product. ",{"type":"{X Y : TopCat} â†’ TopCat.of (â†‘X Ã— â†‘Y) âŸ¶ X","name":"TopCat.prodFst","isProp":false,"docString":"The first projection from the product. ","distance":0.329575130983856323663161447257152758538722991943359375}],["Lexicographical order for products ",{"type":"{Î± : Type u_1} â†’ {Î² : Type u_2} â†’ [inst : LT Î±] â†’ [inst : LT Î²] â†’ Î± Ã— Î² â†’ Î± Ã— Î² â†’ Prop","name":"Prod.lexLt","isProp":false,"docString":"Lexicographical order for products ","distance":0.330967067177516838238915397596429102122783660888671875}],["A limit can be realised as a subobject of a product. ",{"type":"{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    {J : Type w} â†’\n      [inst_1 : CategoryTheory.SmallCategory J] â†’\n        [inst_2 : CategoryTheory.Limits.HasLimitsOfSize.{w, w, v, u} C] â†’\n          (F : CategoryTheory.Functor J C) â†’ CategoryTheory.Limits.limit F âŸ¶ âˆ fun j => F.obj j","name":"CategoryTheory.Limits.limitSubobjectProduct","isProp":false,"docString":"A limit can be realised as a subobject of a product. ","distance":0.3355443623199947378310525891720317304134368896484375}],["The product cone induced by the concrete product. ",{"type":"{R : Type u} â†’ [inst : Ring R] â†’ {Î¹ : Type v} â†’ (Z : Î¹ â†’ ModuleCatMax R) â†’ CategoryTheory.Limits.Fan Z","name":"ModuleCat.productCone","isProp":false,"docString":"The product cone induced by the concrete product. ","distance":0.33734775428670837893463385626091621816158294677734375}],["Notation for the product ",{"type":"Lean.TrailingParserDescr","name":"CategoryTheory.Limits.Â«term_â¨¯_Â»","isProp":false,"docString":"Notation for the product ","distance":0.339942175847698535573471190218697302043437957763671875}],["Products of completions ",{"type":"{Î± : Type u_1} â†’\n  [inst : UniformSpace Î±] â†’\n    AbstractCompletion Î± â†’\n      {Î² : Type u_2} â†’ [inst_1 : UniformSpace Î²] â†’ AbstractCompletion Î² â†’ AbstractCompletion (Î± Ã— Î²)","name":"AbstractCompletion.prod","isProp":false,"docString":"Products of completions ","distance":0.345331826182694923144111953661195002496242523193359375}],["The coproduct is the pushout under the initial object. ",{"type":"{C : Type u} â†’\n  [inst : CategoryTheory.Category.{v, u} C] â†’\n    {W X Y Z : C} â†’\n      (f : X âŸ¶ Z) â†’\n        (g : Y âŸ¶ Z) â†’\n          (h : W âŸ¶ X) â†’\n            (k : W âŸ¶ Y) â†’\n              (Hâ‚ : CategoryTheory.Limits.IsInitial W) â†’\n                CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.BinaryCofan.mk f g) â†’\n                  CategoryTheory.Limits.IsColimit\n                    (CategoryTheory.Limits.PushoutCocone.mk f g\n                      (_ : CategoryTheory.CategoryStruct.comp h f = CategoryTheory.CategoryStruct.comp k g))","name":"isPushoutOfIsInitialIsCoproduct","isProp":false,"docString":"The coproduct is the pushout under the initial object. ","distance":0.34677768716951151706240352723398245871067047119140625}],["The type of good products is equivalent to its image. ",{"type":"{I : Type u} â†’\n  [inst : LinearOrder I] â†’\n    (C : Set (I â†’ Bool)) â†’ â†‘(Profinite.NobelingProof.GoodProducts C) â‰ƒ â†‘(Profinite.NobelingProof.GoodProducts.range C)","name":"Profinite.NobelingProof.GoodProducts.equiv_range","isProp":false,"docString":"The type of good products is equivalent to its image. ","distance":0.347190808216067015035122267363476566970348358154296875}],["Delaborator for simple product projections. ",{"type":"Lean.PrettyPrinter.Delaborator.Delab","name":"delabProdProjs","isProp":false,"docString":"Delaborator for simple product projections. ","distance":0.347724070857192868455598500077030621469020843505859375}],["The first projection of a product, as a smooth map. ",{"type":"{ğ•œ : Type u_1} â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    {E : Type u_2} â†’\n      [inst_1 : NormedAddCommGroup E] â†’\n        [inst_2 : NormedSpace ğ•œ E] â†’\n          {E' : Type u_3} â†’\n            [inst_3 : NormedAddCommGroup E'] â†’\n              [inst_4 : NormedSpace ğ•œ E'] â†’\n                {H : Type u_4} â†’\n                  [inst_5 : TopologicalSpace H] â†’\n                    {H' : Type u_5} â†’\n                      [inst_6 : TopologicalSpace H'] â†’\n                        {I : ModelWithCorners ğ•œ E H} â†’\n                          {I' : ModelWithCorners ğ•œ E' H'} â†’\n                            {M : Type u_6} â†’\n                              [inst_7 : TopologicalSpace M] â†’\n                                [inst_8 : ChartedSpace H M] â†’\n                                  {M' : Type u_7} â†’\n                                    [inst_9 : TopologicalSpace M'] â†’\n                                      [inst_10 : ChartedSpace H' M'] â†’\n                                        {n : â„•âˆ} â†’ ContMDiffMap (ModelWithCorners.prod I I') I (M Ã— M') M n","name":"ContMDiffMap.fst","isProp":false,"docString":"The first projection of a product, as a smooth map. ","distance":0.3510815541049947530183317212504334747791290283203125}],["Evaluation of good products. ",{"type":"{I : Type u} â†’\n  [inst : LinearOrder I] â†’\n    (C : Set (I â†’ Bool)) â†’ { l // Profinite.NobelingProof.Products.isGood C l } â†’ LocallyConstant â†‘C â„¤","name":"Profinite.NobelingProof.GoodProducts.eval","isProp":false,"docString":"Evaluation of good products. ","distance":0.35161907302848327550037765831802971661090850830078125}],["The second projection from the product. ",{"type":"{X Y : TopCat} â†’ TopCat.of (â†‘X Ã— â†‘Y) âŸ¶ Y","name":"TopCat.prodSnd","isProp":false,"docString":"The second projection from the product. ","distance":0.3518563639153795552516612588078714907169342041015625}],["The second projection of a product, as a smooth map. ",{"type":"{ğ•œ : Type u_1} â†’\n  [inst : NontriviallyNormedField ğ•œ] â†’\n    {E : Type u_2} â†’\n      [inst_1 : NormedAddCommGroup E] â†’\n        [inst_2 : NormedSpace ğ•œ E] â†’\n          {E' : Type u_3} â†’\n            [inst_3 : NormedAddCommGroup E'] â†’\n              [inst_4 : NormedSpace ğ•œ E'] â†’\n                {H : Type u_4} â†’\n                  [inst_5 : TopologicalSpace H] â†’\n                    {H' : Type u_5} â†’\n                      [inst_6 : TopologicalSpace H'] â†’\n                        {I : ModelWithCorners ğ•œ E H} â†’\n                          {I' : ModelWithCorners ğ•œ E' H'} â†’\n                            {M : Type u_6} â†’\n                              [inst_7 : TopologicalSpace M] â†’\n                                [inst_8 : ChartedSpace H M] â†’\n                                  {M' : Type u_7} â†’\n                                    [inst_9 : TopologicalSpace M'] â†’\n                                      [inst_10 : ChartedSpace H' M'] â†’\n                                        {n : â„•âˆ} â†’ ContMDiffMap (ModelWithCorners.prod I I') I' (M Ã— M') M' n","name":"ContMDiffMap.snd","isProp":false,"docString":"The second projection of a product, as a smooth map. ","distance":0.352743491876557568875938386554480530321598052978515625}],["the image of a product is less or equal than the product of the images. ",{"type":"âˆ€ {F : Type u_7} {Î± : outParam (Type u_8)} {Î² : outParam (Type u_9)} [inst : NonUnitalNonAssocRing Î±]\n  [inst_1 : OrderedSemiring Î²] [self : RingSeminormClass F Î± Î²] (f : F) (a b : Î±), f (a * b) â‰¤ f a * f b","name":"RingSeminormClass.map_mul_le_mul","isProp":true,"docString":"the image of a product is less or equal than the product of the images. ","distance":0.353634205944298229962186042030225507915019989013671875}],["The pullback over the zero object is the product. ",{"type":"{C : Type u_1} â†’\n  [inst : CategoryTheory.Category.{u_2, u_1} C] â†’\n    [inst_1 : CategoryTheory.Limits.HasZeroObject C] â†’\n      [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] â†’\n        (X Y : C) â†’ [inst_3 : CategoryTheory.Limits.HasBinaryProduct X Y] â†’ CategoryTheory.Limits.pullback 0 0 â‰… X â¨¯ Y","name":"CategoryTheory.Limits.pullbackZeroZeroIso","isProp":false,"docString":"The pullback over the zero object is the product. ","distance":0.35517593456665197404475975417881272733211517333984375}],["The limit cone for the product with a zero object. ",{"type":"{C : Type u_1} â†’\n  [inst : CategoryTheory.Category.{u_2, u_1} C] â†’\n    [inst_1 : CategoryTheory.Limits.HasZeroObject C] â†’\n      [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] â†’ (X : C) â†’ CategoryTheory.Limits.BinaryFan X 0","name":"CategoryTheory.Limits.binaryFanZeroRight","isProp":false,"docString":"The limit cone for the product with a zero object. ","distance":0.35907956543732544307800935712293721735477447509765625}],["introduce a product where both components are the same ",{"type":"{n : â„•} â†’ {Î± : TypeVec.{u} n} â†’ TypeVec.Arrow Î± (TypeVec.prod Î± Î±)","name":"TypeVec.prod.diag","isProp":false,"docString":"introduce a product where both components are the same ","distance":0.36175788478721726537656877553672529757022857666015625}]]