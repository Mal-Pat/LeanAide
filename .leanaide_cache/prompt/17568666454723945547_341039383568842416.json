[["The program. ",{"type":"{Γ : Type u_1} →\n  {Λ : Type u_2} →\n    [inst : Inhabited Λ] → Turing.TM0.Machine Γ Λ → Turing.TM0to1.Λ' → Turing.TM1.Stmt Γ Turing.TM0to1.Λ' Unit","name":"Turing.TM0to1.tr","isProp":false,"docString":"The program. ","distance":0.383658070076880186594081578732584603130817413330078125}],[" For any pre-games x and y in set theory, if the Left player has a winning strategy as the first player in game x then y is strictly greater than x (i.e., y > x).",{"type":"∀ {x y : SetTheory.PGame}, x.LF y → ¬y ≤ x","name":"SetTheory.PGame.LF.not_ge","isProp":true,"docString":" For any pre-games x and y in set theory, if the Left player has a winning strategy as the first player in game x then y is strictly greater than x (i.e., y > x).","distance":0.51106482876646130986131311146891675889492034912109375}],["This theorem, which is a part of Profinite's NobelingProof, asserts the following: for any type `I` equipped with a linear order, a set `C` of Boolean-valued functions on `I`, a product `l` of elements from `I`, and a predicate `J` on `I`, if every element `a` in the product `l` satisfies the predicate `J`, then for any `j` in `I` that can be decided by `J`, the composition of the evaluation of `l` under the image of `Proj π J` with the restriction of `Proj π J` to `C`, is equal to the evaluation of `l` under `C`. \n\nIn simple terms, this theorem shows a relationship between the evaluation of a product under a set of functions and its projection restricted to a subset, assuming that all elements of the product satisfy a certain property. The mathematical operations involved are function composition and evaluation.",{"type":"∀ {I : Type u} [inst : LinearOrder I] (C : Set (I → Bool)) {l : Profinite.NobelingProof.Products I} (J : I → Prop),\n  (∀ a ∈ ↑l, J a) →\n    ∀ [inst_1 : (j : I) → Decidable (J j)],\n      ⇑(Profinite.NobelingProof.Products.eval (Profinite.NobelingProof.π C J) l) ∘\n          Profinite.NobelingProof.ProjRestrict C J =\n        ⇑(Profinite.NobelingProof.Products.eval C l)","name":"Profinite.NobelingProof.Products.evalFacProp","isProp":true,"docString":"This theorem, which is a part of Profinite's NobelingProof, asserts the following: for any type `I` equipped with a linear order, a set `C` of Boolean-valued functions on `I`, a product `l` of elements from `I`, and a predicate `J` on `I`, if every element `a` in the product `l` satisfies the predicate `J`, then for any `j` in `I` that can be decided by `J`, the composition of the evaluation of `l` under the image of `Proj π J` with the restriction of `Proj π J` to `C`, is equal to the evaluation of `l` under `C`. \n\nIn simple terms, this theorem shows a relationship between the evaluation of a product under a set of functions and its projection restricted to a subset, assuming that all elements of the product satisfy a certain property. The mathematical operations involved are function composition and evaluation.","distance":0.489848117790524228976067888652323745191097259521484375}],["The positive part function. ",{"type":"Lean.TrailingParserDescr","name":"«term_⁺»","isProp":false,"docString":"The positive part function. ","distance":0.387152586102157580949523207891616038978099822998046875}],[" For an impartial pre-game G in set theory, G is fuzzy relative to the zero game if and only if the Left player can win the less or fuzzy version of G.",{"type":"∀ (G : SetTheory.PGame) [inst : G.Impartial], G.Fuzzy 0 ↔ G.LF 0","name":"SetTheory.PGame.Impartial.fuzzy_zero_iff_lf","isProp":true,"docString":" For an impartial pre-game G in set theory, G is fuzzy relative to the zero game if and only if the Left player can win the less or fuzzy version of G.","distance":0.51771030882939139683429630167665891349315643310546875}],["The theorem `Nat.Prime.pos` states that for every natural number `p`, if `p` is prime, then `p` is greater than 0. In other words, any prime number is positive.",{"type":"∀ {p : ℕ}, p.Prime → 0 < p","name":"Nat.Prime.pos","isProp":true,"docString":"The theorem `Nat.Prime.pos` states that for every natural number `p`, if `p` is prime, then `p` is greater than 0. In other words, any prime number is positive.","distance":0.49480338026737269441213129539391957223415374755859375}],["Delaborator for simple product projections. ",{"type":"Lean.PrettyPrinter.Delaborator.Delab","name":"delabProdProjs","isProp":false,"docString":"Delaborator for simple product projections. ","distance":0.3931064245705198079150477497023530304431915283203125}],["The top level program. ",{"type":"{Γ : Type u_1} →\n  {Λ : Type u_2} →\n    {σ : Type u_3} →\n      {n : ℕ} →\n        (Γ → Vector Bool n) →\n          (Vector Bool n → Γ) → (Λ → Turing.TM1.Stmt Γ Λ σ) → Turing.TM1to1.Λ' → Turing.TM1.Stmt Bool Turing.TM1to1.Λ' σ","name":"Turing.TM1to1.tr","isProp":false,"docString":"The top level program. ","distance":0.4142671394393200312578073862823657691478729248046875}],["an arrow ",{"type":"{V : Type u} → [inst : Quiver V] → (self : Quiver.Total V) → self.left ⟶ self.right","name":"Quiver.Total.hom","isProp":false,"docString":"an arrow ","distance":0.415955674891150095628944427517126314342021942138671875}],["The proof that is the limit cone ",{"type":"{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {C : Type u} →\n      [inst_1 : CategoryTheory.Category.{v, u} C] →\n        {F : CategoryTheory.Functor J C} →\n          (self : CategoryTheory.Limits.LimitCone F) → CategoryTheory.Limits.IsLimit self.cone","name":"CategoryTheory.Limits.LimitCone.isLimit","isProp":false,"docString":"The proof that is the limit cone ","distance":0.41727209652778352033664077680441550910472869873046875}],["projection expression ",{"type":"Simps.ParsedProjectionData → Option Lean.Expr","name":"Simps.ParsedProjectionData.expr?","isProp":false,"docString":"projection expression ","distance":0.419828413868354954896489061866304837167263031005859375}],["Evaluation of good products. ",{"type":"{I : Type u} →\n  [inst : LinearOrder I] →\n    (C : Set (I → Bool)) → { l // Profinite.NobelingProof.Products.isGood C l } → LocallyConstant ↑C ℤ","name":"Profinite.NobelingProof.GoodProducts.eval","isProp":false,"docString":"Evaluation of good products. ","distance":0.4208509972699909784665806000703014433383941650390625}],["The property of preserving products expressed in terms of fans. ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        (G : CategoryTheory.Functor C D) →\n          {J : Type w} →\n            (f : J → C) →\n              [inst_2 : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Discrete.functor f) G] →\n                {P : C} →\n                  (g : (j : J) → P ⟶ f j) →\n                    CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.Fan.mk P g) →\n                      CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.Fan.mk (G.obj P) fun j => G.map (g j))","name":"CategoryTheory.Limits.isLimitFanMkObjOfIsLimit","isProp":false,"docString":"The property of preserving products expressed in terms of fans. ","distance":0.423231121038369961784297856866032816469669342041015625}],["The absolute value is positive definitive ",{"type":"∀ {S : Type u_1} [inst : OrderedSemiring S] {R : Type u_2} [inst_1 : Semiring R] {f : R → S} [self : IsAbsoluteValue f]\n  {x : R}, f x = 0 ↔ x = 0","name":"IsAbsoluteValue.abv_eq_zero'","isProp":true,"docString":"The absolute value is positive definitive ","distance":0.424150363746067515791082769283093512058258056640625}],["Spec preserves limits. ",{"type":"CategoryTheory.Limits.PreservesLimits AlgebraicGeometry.Spec.toLocallyRingedSpace","name":"AlgebraicGeometry.instPreservesLimitsOppositeCommRingCatOppositeInstCommRingCatLargeCategoryLocallyRingedSpaceInstCategoryLocallyRingedSpaceToLocallyRingedSpace","isProp":false,"docString":"Spec preserves limits. ","distance":0.4241799733503057723282836377620697021484375}],["The right arrow of the walking cospan. ",{"type":"CategoryTheory.Limits.WalkingCospan.right ⟶ CategoryTheory.Limits.WalkingCospan.one","name":"CategoryTheory.Limits.WalkingCospan.Hom.inr","isProp":false,"docString":"The right arrow of the walking cospan. ","distance":0.425210158672356286491123000814695842564105987548828125}],["The proposition that the function preserves the action. ",{"type":"∀ {F : Type u_16} {M : outParam (Type u_17)} {X : outParam (Type u_18)} {Y : outParam (Type u_19)} [inst : SMul M X]\n  [inst_1 : SMul M Y] [self : SMulHomClass F M X Y] (f : F) (c : M) (x : X), f (c • x) = c • f x","name":"SMulHomClass.map_smul","isProp":true,"docString":"The proposition that the function preserves the action. ","distance":0.425625274694298838529249451312352903187274932861328125}],["The negative part function. ",{"type":"{α : Type u_1} → [self : NegPart α] → α → α","name":"NegPart.neg","isProp":false,"docString":"The negative part function. ","distance":0.42592000052678546939688430938986130058765411376953125}],["Function value ",{"type":"Lean.TrailingParserDescr","name":"Class.«term_′_»","isProp":false,"docString":"Function value ","distance":0.42634607004628921611555369963753037154674530029296875}],["The supremum of the principal segment ",{"type":"{α : Type u_4} → {β : Type u_5} → {r : α → α → Prop} → {s : β → β → Prop} → r ≺i s → β","name":"PrincipalSeg.top","isProp":false,"docString":"The supremum of the principal segment ","distance":0.426378246498808177733508273377083241939544677734375}],["Positive part of a simple function. ",{"type":"{α : Type u_1} →\n  {E : Type u_2} →\n    [inst : LinearOrder E] →\n      [inst : Zero E] → [inst : MeasurableSpace α] → MeasureTheory.SimpleFunc α E → MeasureTheory.SimpleFunc α E","name":"MeasureTheory.SimpleFunc.posPart","isProp":false,"docString":"Positive part of a simple function. ","distance":0.426965574603941189213429652227205224335193634033203125}],["Standard part predicate ",{"type":"ℝ* → ℝ → Prop","name":"Hyperreal.IsSt","isProp":false,"docString":"Standard part predicate ","distance":0.427555161123508498111078779402305372059345245361328125}],["Delaborator for indexed supremum. ",{"type":"Lean.PrettyPrinter.Delaborator.Delab","name":"iSup_delab","isProp":false,"docString":"Delaborator for indexed supremum. ","distance":0.427583114568754585338439255792764015495777130126953125}],["The proposition that the function preserves 1 ",{"type":"∀ {M : Type u_9} {N : Type u_10} [inst : One M] [inst_1 : One N] (self : OneHom M N), OneHom.toFun self 1 = 1","name":"OneHom.map_one'","isProp":true,"docString":"The proposition that the function preserves 1 ","distance":0.4277793880112963353923305476200766861438751220703125}]]