[["Notation for the product ",{"type":"Lean.TrailingParserDescr","name":"CategoryTheory.Limits.«term_⨯_»","isProp":false,"docString":"Notation for the product ","distance":0.209157658257613399133134635121678002178668975830078125}],[" For any category with binary products, the product of two objects exists.",{"type":"∀ {C : Type u_2} [inst : CategoryTheory.Category.{u_1, u_2} C] [inst_1 : CategoryTheory.Limits.HasBinaryProducts C]\n  (X Y : C), CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair X Y)","name":"CategoryTheory.Limits.prod.functor.proof_1","isProp":true,"docString":" For any category with binary products, the product of two objects exists.","distance":0.349800340482970206767987519924645312130451202392578125}],["This theorem states that for any integer 'a', the product of 0 and 'a' is always 0. It's a formal expression of the well-known mathematical rule that multiplying any number by zero results in zero.",{"type":"∀ (a : ℤ), 0 * a = 0","name":"Int.zero_mul","isProp":true,"docString":"This theorem states that for any integer 'a', the product of 0 and 'a' is always 0. It's a formal expression of the well-known mathematical rule that multiplying any number by zero results in zero.","distance":0.354246858607369097260431090035126544535160064697265625}],["The product of the factors is the original number ",{"type":"∀ (n : ℕ+), PrimeMultiset.prod (PNat.factorMultiset n) = n","name":"PNat.prod_factorMultiset","isProp":true,"docString":"The product of the factors is the original number ","distance":0.228395289305545257096952127540134824812412261962890625}],[" The second component of the product of two dual numbers is equal to the sum of the product of their first components and the product of their second components.",{"type":"∀ {R : Type u_1} [inst : Semiring R] (x y : DualNumber R),\n  TrivSqZeroExt.snd (x * y) = TrivSqZeroExt.fst x * TrivSqZeroExt.snd y + TrivSqZeroExt.snd x * TrivSqZeroExt.fst y","name":"DualNumber.snd_mul","isProp":true,"docString":" The second component of the product of two dual numbers is equal to the sum of the product of their first components and the product of their second components.","distance":0.36104088733774652997254861475084908306598663330078125}],["This theorem is known as the *Euler Product* for completely multiplicative functions. If you have a completely multiplicative function `f` from natural numbers to a complete normed field `F`, and the norm of `f` is summable (i.e., the series of the norms of `f` converges), then the product over all prime numbers `p` of `(1 - f p)⁻¹` converges to the sum over all natural numbers `n` of `f n`. Concretely, this says the infinite product `∏' p : Nat.Primes, (1 - f p)⁻¹` equals the infinite sum `∑' n, f n`. This theorem is stated in the form of convergence of finite partial products, meaning that as you consider more and more terms in the product, the value of the product gets closer and closer to the value of the infinite sum.",{"type":"∀ {F : Type u_1} [inst : NormedField F] [inst_1 : CompleteSpace F] {f : ℕ →*₀ F},\n  (Summable fun x => ‖f x‖) →\n    Filter.Tendsto (fun n => n.primesBelow.prod fun p => (1 - f p)⁻¹) Filter.atTop (nhds (∑' (n : ℕ), f n))","name":"EulerProduct.eulerProduct_completely_multiplicative","isProp":true,"docString":"This theorem is known as the *Euler Product* for completely multiplicative functions. If you have a completely multiplicative function `f` from natural numbers to a complete normed field `F`, and the norm of `f` is summable (i.e., the series of the norms of `f` converges), then the product over all prime numbers `p` of `(1 - f p)⁻¹` converges to the sum over all natural numbers `n` of `f n`. Concretely, this says the infinite product `∏' p : Nat.Primes, (1 - f p)⁻¹` equals the infinite sum `∑' n, f n`. This theorem is stated in the form of convergence of finite partial products, meaning that as you consider more and more terms in the product, the value of the product gets closer and closer to the value of the infinite sum.","distance":0.35610674228937566621056021176627837121486663818359375}],["The first projection from the product. ",{"type":"{X Y : TopCat} → TopCat.of (↑X × ↑Y) ⟶ X","name":"TopCat.prodFst","isProp":false,"docString":"The first projection from the product. ","distance":0.25530643694404264731900866536307148635387420654296875}],["Product of partial functions. ",{"type":"{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α →. β) → (α →. γ) → α →. β × γ","name":"PFun.prodLift","isProp":false,"docString":"Product of partial functions. ","distance":0.255922816791550988835268753973650746047496795654296875}],["Product of two rings is a ring. ",{"type":"{R : Type u_3} → {S : Type u_5} → [inst : Ring R] → [inst : Ring S] → Ring (R × S)","name":"Prod.instRing","isProp":false,"docString":"Product of two rings is a ring. ","distance":0.257434325487692294842645424068905413150787353515625}],["Tensor products distribute over a product on the left . ",{"type":"(R : Type uR) →\n  (M₁ : Type uM₁) →\n    (M₂ : Type uM₂) →\n      (M₃ : Type uM₃) →\n        [inst : CommSemiring R] →\n          [inst_1 : AddCommMonoid M₁] →\n            [inst_2 : AddCommMonoid M₂] →\n              [inst_3 : AddCommMonoid M₃] →\n                [inst_4 : Module R M₁] →\n                  [inst_5 : Module R M₂] →\n                    [inst_6 : Module R M₃] →\n                      TensorProduct R (M₁ × M₂) M₃ ≃ₗ[R] TensorProduct R M₁ M₃ × TensorProduct R M₂ M₃","name":"TensorProduct.prodLeft","isProp":false,"docString":"Tensor products distribute over a product on the left . ","distance":0.259397944019896631306920653514680452644824981689453125}],["The second projection from the product. ",{"type":"{X Y : TopCat} → TopCat.of (↑X × ↑Y) ⟶ Y","name":"TopCat.prodSnd","isProp":false,"docString":"The second projection from the product. ","distance":0.260577525418761946074397428674274124205112457275390625}],["The product of two two-pointings. ",{"type":"{α : Type u_1} → {β : Type u_2} → TwoPointing α → TwoPointing β → TwoPointing (α × β)","name":"TwoPointing.prod","isProp":false,"docString":"The product of two two-pointings. ","distance":0.2607550958334610147204557506483979523181915283203125}],["The set of good products. ",{"type":"{I : Type u} → [inst : LinearOrder I] → Set (I → Bool) → Set (Profinite.NobelingProof.Products I)","name":"Profinite.NobelingProof.GoodProducts","isProp":false,"docString":"The set of good products. ","distance":0.263512379040257649354117575057898648083209991455078125}],["The product of a family of triangles. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.HasShift C ℤ] →\n      {J : Type u_1} →\n        (T : J → CategoryTheory.Pretriangulated.Triangle C) →\n          [inst_2 : CategoryTheory.Limits.HasProduct fun j => (T j).obj₁] →\n            [inst_3 : CategoryTheory.Limits.HasProduct fun j => (T j).obj₂] →\n              [inst_4 : CategoryTheory.Limits.HasProduct fun j => (T j).obj₃] →\n                [inst_5 : CategoryTheory.Limits.HasProduct fun j => (CategoryTheory.shiftFunctor C 1).obj (T j).obj₁] →\n                  CategoryTheory.Pretriangulated.Triangle C","name":"CategoryTheory.Pretriangulated.productTriangle","isProp":false,"docString":"The product of a family of triangles. ","distance":0.264847875894971107602060556018841452896595001220703125}],["Tensor products distribute over a product on the right. ",{"type":"(R : Type uR) →\n  (M₁ : Type uM₁) →\n    (M₂ : Type uM₂) →\n      (M₃ : Type uM₃) →\n        [inst : CommSemiring R] →\n          [inst_1 : AddCommMonoid M₁] →\n            [inst_2 : AddCommMonoid M₂] →\n              [inst_3 : AddCommMonoid M₃] →\n                [inst_4 : Module R M₁] →\n                  [inst_5 : Module R M₂] →\n                    [inst_6 : Module R M₃] →\n                      TensorProduct R M₁ (M₂ × M₃) ≃ₗ[R] TensorProduct R M₁ M₂ × TensorProduct R M₁ M₃","name":"TensorProduct.prodRight","isProp":false,"docString":"Tensor products distribute over a product on the right. ","distance":0.2656351294845997745852628213469870388507843017578125}],["The equivalence between the opposite of a product and the product of the opposites. ",{"type":"(C : Type u₃) →\n  [inst : CategoryTheory.Category.{v₃, u₃} C] →\n    {D : Type u₄} → [inst_1 : CategoryTheory.Category.{v₄, u₄} D] → (C × D)ᵒᵖ ≌ Cᵒᵖ × Dᵒᵖ","name":"CategoryTheory.prodOpEquiv","isProp":false,"docString":"The equivalence between the opposite of a product and the product of the opposites. ","distance":0.26914978559692148696314006883767433464527130126953125}],["Products of completions ",{"type":"{α : Type u_1} →\n  [inst : UniformSpace α] →\n    AbstractCompletion α →\n      {β : Type u_2} → [inst_1 : UniformSpace β] → AbstractCompletion β → AbstractCompletion (α × β)","name":"AbstractCompletion.prod","isProp":false,"docString":"Products of completions ","distance":0.271631923602653702065623519956716336309909820556640625}],["The product of a family of types over a list. ",{"type":"{ι : Type u} → (ι → Type v) → List ι → Type v","name":"List.TProd","isProp":false,"docString":"The product of a family of types over a list. ","distance":0.271707642622580569646828507757163606584072113037109375}],["A product of distinguished triangles is distinguished ",{"type":"∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.HasShift C ℤ] [inst_3 : CategoryTheory.Preadditive C]\n  [inst_4 : ∀ (n : ℤ), CategoryTheory.Functor.Additive (CategoryTheory.shiftFunctor C n)]\n  [hC : CategoryTheory.Pretriangulated C] {J : Type u_1} (T : J → CategoryTheory.Pretriangulated.Triangle C),\n  (∀ (j : J), T j ∈ CategoryTheory.Pretriangulated.distinguishedTriangles) →\n    ∀ [inst_5 : CategoryTheory.Limits.HasProduct fun j => (T j).obj₁]\n      [inst_6 : CategoryTheory.Limits.HasProduct fun j => (T j).obj₂]\n      [inst_7 : CategoryTheory.Limits.HasProduct fun j => (T j).obj₃]\n      [inst_8 : CategoryTheory.Limits.HasProduct fun j => (CategoryTheory.shiftFunctor C 1).obj (T j).obj₁],\n      CategoryTheory.Pretriangulated.productTriangle T ∈ CategoryTheory.Pretriangulated.distinguishedTriangles","name":"CategoryTheory.Pretriangulated.productTriangle_distinguished","isProp":true,"docString":"A product of distinguished triangles is distinguished ","distance":0.272230229902697351551665860824869014322757720947265625}],["An inner product with a sum on the right. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_4} (s : Finset ι) (f : ι → E) (x : E), ⟪x, Finset.sum s fun i => f i⟫_𝕜 = Finset.sum s fun i => ⟪x, f i⟫_𝕜","name":"inner_sum","isProp":true,"docString":"An inner product with a sum on the right. ","distance":0.2731185132134588133823172029224224388599395751953125}],["The alternating product of a list. ",{"type":"{G : Type u_1} → [inst : One G] → [inst : Mul G] → [inst : Inv G] → List G → G","name":"List.alternatingProd","isProp":false,"docString":"The alternating product of a list. ","distance":0.27330289787407380242001408987562172114849090576171875}],["The tensor product of two holors. ",{"type":"{α : Type} → {ds₁ ds₂ : List ℕ} → [inst : Mul α] → Holor α ds₁ → Holor α ds₂ → Holor α (ds₁ ++ ds₂)","name":"Holor.mul","isProp":false,"docString":"The tensor product of two holors. ","distance":0.2734412289068124390922776001389138400554656982421875}],["An inner product with a sum on the left. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_4} (s : Finset ι) (f : ι → E) (x : E), ⟪Finset.sum s fun i => f i, x⟫_𝕜 = Finset.sum s fun i => ⟪f i, x⟫_𝕜","name":"sum_inner","isProp":true,"docString":"An inner product with a sum on the left. ","distance":0.27618499047484934560969804806518368422985076904296875}],["The inclusion of a summand into the free product. ",{"type":"{ι : Type u_1} → {M : ι → Type u_2} → [inst : (i : ι) → Monoid (M i)] → {i : ι} → M i →* Monoid.CoprodI M","name":"Monoid.CoprodI.of","isProp":false,"docString":"The inclusion of a summand into the free product. ","distance":0.276361269959365107862225841017789207398891448974609375}]]